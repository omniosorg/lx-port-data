.gitignore
--- /export/home/danmcd/ws/illumos-omnios/.gitignore	Tue Jul 21 14:14:22 2015
+++ /export/home/danmcd/ws/illumos-joyent/.gitignore	Wed Jun 17 17:43:36 2015
@@ -7,19 +7,9104 @@
 cscope.in.out
 cscope.po.out
 .make.state*
+*.o
+*.po
+*.so
+*.so.1
+*.a
+*.pyc
+/closed
+/illumos.sh
 /log
+/nightly
+/on-closed-bins-nd.i386.tar.bz2
+/on-closed-bins.i386.tar.bz2
 /packages
 /proto
 /webrev
-/usr/src/.build.tstamp
-/usr/src/ELF-data.*
-/usr/src/check-*.out
-/usr/src/clobber-*.out
-/usr/src/install-*.out
-/usr/src/lint-*.out
-/usr/src/lint-noise-*.out
-/usr/src/lint-noise-*.ref
-/usr/src/noise-*.out
-/usr/src/noise-*.ref
-/usr/src/tools/clobber-*.out
-/usr/src/tools/install-*.out
+.make.state
+.build.tstamp
+usr/src/ELF-data.*
+usr/src/check-i386.out
+usr/src/cmd/Adm/sun/motd
+usr/src/cmd/Adm/sun/smbpasswd
+usr/src/cmd/abi/appcert/etc/etc.alt
+usr/src/cmd/abi/appcert/etc/etc.scoped
+usr/src/cmd/abi/appcert/etc/etc.tweaks
+usr/src/cmd/abi/appcert/etc/etc.warn
+usr/src/cmd/abi/appcert/scripts/abi_index
+usr/src/cmd/abi/appcert/scripts/appcert
+usr/src/cmd/abi/appcert/scripts/symcheck
+usr/src/cmd/abi/appcert/scripts/symprof
+usr/src/cmd/abi/appcert/scripts/symreport
+usr/src/cmd/abi/appcert/static_prof/i386/static_prof
+usr/src/cmd/abi/apptracecmd/apptrace
+usr/src/cmd/abi/spectrans/spec2map/i386/spec2map
+usr/src/cmd/abi/spectrans/spec2trace/i386/spec2trace
+usr/src/cmd/acct/acct
+usr/src/cmd/acct/acctcms
+usr/src/cmd/acct/acctcom
+usr/src/cmd/acct/acctcon
+usr/src/cmd/acct/acctcon1
+usr/src/cmd/acct/acctcon2
+usr/src/cmd/acct/acctdisk
+usr/src/cmd/acct/acctdusg
+usr/src/cmd/acct/acctmerg
+usr/src/cmd/acct/accton
+usr/src/cmd/acct/acctprc
+usr/src/cmd/acct/acctprc1
+usr/src/cmd/acct/acctprc2
+usr/src/cmd/acct/acctwtmp
+usr/src/cmd/acct/chargefee
+usr/src/cmd/acct/ckpacct
+usr/src/cmd/acct/closewtmp
+usr/src/cmd/acct/dodisk
+usr/src/cmd/acct/fwtmp
+usr/src/cmd/acct/holidays
+usr/src/cmd/acct/lastlogin
+usr/src/cmd/acct/monacct
+usr/src/cmd/acct/nulladm
+usr/src/cmd/acct/prctmp
+usr/src/cmd/acct/prdaily
+usr/src/cmd/acct/prtacct
+usr/src/cmd/acct/remove
+usr/src/cmd/acct/runacct
+usr/src/cmd/acct/shutacct
+usr/src/cmd/acct/startup
+usr/src/cmd/acct/turnacct
+usr/src/cmd/acct/utmp2wtmp
+usr/src/cmd/acct/wtmpfix
+usr/src/cmd/acctadm/acctadm
+usr/src/cmd/acpihpd/THIRDPARTYLICENSE
+usr/src/cmd/acpihpd/i386/acpihpd
+usr/src/cmd/adbgen/i386/adbgen
+usr/src/cmd/adbgen/i386/adbgen1
+usr/src/cmd/adbgen/i386/adbgen3
+usr/src/cmd/adbgen/i386/adbgen4
+usr/src/cmd/addbadsec/addbadsec
+usr/src/cmd/allocate/add_allocatable
+usr/src/cmd/allocate/allocate
+usr/src/cmd/allocate/allscripts.sh
+usr/src/cmd/allocate/audio
+usr/src/cmd/allocate/audio_clean
+usr/src/cmd/allocate/disk_clean
+usr/src/cmd/allocate/dminfo
+usr/src/cmd/allocate/fd0
+usr/src/cmd/allocate/mkdevalloc
+usr/src/cmd/allocate/sr0
+usr/src/cmd/allocate/st0
+obj32
+obj64
+debug32
+debug64
+usr/src/cmd/allocate/st1
+usr/src/cmd/allocate/st_clean
+usr/src/cmd/amt/amd64/amt
+usr/src/cmd/amt/amt
+usr/src/cmd/amt/i386/amt
+usr/src/cmd/arch/arch
+usr/src/cmd/asa/asa
+usr/src/cmd/ast/msgcc/msgcc
+usr/src/cmd/ast/msgcc/msgcpp
+usr/src/cmd/ast/msgcc/msgcvt
+usr/src/cmd/ast/msgcc/msggen
+usr/src/cmd/ast/msgcc/msgget
+usr/src/cmd/audio/audioconvert/audioconvert
+usr/src/cmd/audio/audioctl/audioctl
+usr/src/cmd/audio/audioplay/audioplay
+usr/src/cmd/audio/audiorecord/audiorecord
+usr/src/cmd/audio/audiotest/audiotest
+usr/src/cmd/audit/audit
+usr/src/cmd/audit_warn/audit_warn
+usr/src/cmd/auditconfig/auditconfig
+usr/src/cmd/auditd/auditd
+usr/src/cmd/auditrecord/audit_record_attr
+usr/src/cmd/auditrecord/auditrecord
+usr/src/cmd/auditrecord/filter_txt
+usr/src/cmd/auditrecord/mkmsg
+usr/src/cmd/auditreduce/auditreduce
+usr/src/cmd/auditset/svc-auditset
+usr/src/cmd/auditstat/auditstat
+usr/src/cmd/auths/auths
+usr/src/cmd/autopush/autopush
+usr/src/cmd/availdevs/availdevs
+usr/src/cmd/avs/dsbitmap/dsbitmap
+usr/src/cmd/avs/dscfg/dscfg
+usr/src/cmd/avs/dscfg/dscfgadm
+usr/src/cmd/avs/dscfglockd/dscfgcli
+usr/src/cmd/avs/dscfglockd/dscfglockd
+usr/src/cmd/avs/dsstat/dsstat
+usr/src/cmd/avs/dsw/etc/ii
+usr/src/cmd/avs/dsw/etc/ii.cluster
+usr/src/cmd/avs/dsw/iiadm
+usr/src/cmd/avs/dsw/iiboot
+usr/src/cmd/avs/dsw/iicpbmp
+usr/src/cmd/avs/dsw/iicpshd
+usr/src/cmd/avs/errgen/errgen
+usr/src/cmd/avs/ncall/ncalladm
+usr/src/cmd/avs/nsctl/nscadm
+usr/src/cmd/avs/nsctl/nskernd
+usr/src/cmd/avs/rdc/etc/rdc
+usr/src/cmd/avs/rdc/etc/rdc.cluster
+usr/src/cmd/avs/rdc/etc/rdcfinish
+usr/src/cmd/avs/rdc/sndradm
+usr/src/cmd/avs/rdc/sndrboot
+usr/src/cmd/avs/rdc/sndrd
+usr/src/cmd/avs/rdc/sndrsyncd
+usr/src/cmd/avs/sdbc/etc/dscfg_reconfigure.cluster
+usr/src/cmd/avs/sdbc/etc/scm
+usr/src/cmd/avs/sdbc/scmadm
+usr/src/cmd/avs/sdbc/sd_diag
+usr/src/cmd/avs/sdbc/sd_stats
+usr/src/cmd/avs/sv/etc/sv
+usr/src/cmd/avs/sv/etc/sv.cluster
+usr/src/cmd/avs/sv/svadm
+usr/src/cmd/avs/sv/svboot
+usr/src/cmd/avs/svc/nws_ii.xml
+usr/src/cmd/avs/svc/nws_rdc.xml
+usr/src/cmd/avs/svc/nws_rdcsyncd.xml
+usr/src/cmd/avs/svc/nws_scm.xml
+usr/src/cmd/avs/svc/nws_sv.xml
+usr/src/cmd/awk/awk.g.c
+usr/src/cmd/awk/awk.lx.c
+usr/src/cmd/awk/maketab
+usr/src/cmd/awk/nawk
+usr/src/cmd/awk/proctab.c
+usr/src/cmd/awk/y.tab.h
+usr/src/cmd/awk_xpg4/awk.c
+usr/src/cmd/awk_xpg4/awk.xpg4
+usr/src/cmd/awk_xpg4/y.tab.h
+usr/src/cmd/backup/dump/dumpdates
+usr/src/cmd/backup/dump/ufsdump
+usr/src/cmd/backup/lib/getdate.c
+usr/src/cmd/backup/restore/ufsrestore
+usr/src/cmd/banner/banner
+usr/src/cmd/bart/bart
+usr/src/cmd/basename/basename
+usr/src/cmd/basename/basename.xpg4
+usr/src/cmd/bc/bc
+usr/src/cmd/bc/bc.xpg6
+usr/src/cmd/bc/lib.b
+usr/src/cmd/bdiff/bdiff
+usr/src/cmd/beadm/beadm
+usr/src/cmd/bfs/bfs
+usr/src/cmd/biosdev/biosdev
+usr/src/cmd/bnu/bnuconvert
+usr/src/cmd/bnu/bnuconvert.cat
+usr/src/cmd/bnu/ct
+usr/src/cmd/bnu/ct.cat
+usr/src/cmd/bnu/cu
+usr/src/cmd/bnu/cu.cat
+usr/src/cmd/bnu/in.uucpd
+usr/src/cmd/bnu/in.uucpd.cat
+usr/src/cmd/bnu/remote.unknown
+usr/src/cmd/bnu/remote.unknown.cat
+usr/src/cmd/bnu/uucheck
+usr/src/cmd/bnu/uucheck.cat
+usr/src/cmd/bnu/uucico
+usr/src/cmd/bnu/uucico.cat
+usr/src/cmd/bnu/uucleanup
+usr/src/cmd/bnu/uucleanup.cat
+usr/src/cmd/bnu/uucp
+usr/src/cmd/bnu/uucp.cat
+usr/src/cmd/bnu/uudecode
+usr/src/cmd/bnu/uudecode.cat
+usr/src/cmd/bnu/uuencode
+usr/src/cmd/bnu/uuencode.cat
+usr/src/cmd/bnu/uuglist
+usr/src/cmd/bnu/uuglist.cat
+usr/src/cmd/bnu/uuname
+usr/src/cmd/bnu/uuname.cat
+usr/src/cmd/bnu/uusched
+usr/src/cmd/bnu/uusched.cat
+usr/src/cmd/bnu/uustat
+usr/src/cmd/bnu/uustat.cat
+usr/src/cmd/bnu/uux
+usr/src/cmd/bnu/uux.cat
+usr/src/cmd/bnu/uuxqt
+usr/src/cmd/bnu/uuxqt.cat
+usr/src/cmd/boot/bootadm/bootadm
+usr/src/cmd/boot/fiocompress/fiocompress
+usr/src/cmd/boot/installgrub/installgrub
+usr/src/cmd/boot/mbr/mbr
+usr/src/cmd/boot/scripts/boot-archive-update
+usr/src/cmd/boot/scripts/create_diskmap
+usr/src/cmd/boot/scripts/create_ramdisk
+usr/src/cmd/boot/scripts/extract_boot_filelist
+usr/src/cmd/boot/scripts/root_archive
+usr/src/cmd/boot/scripts/update_grub
+usr/src/cmd/boot/symdef/symdef
+usr/src/cmd/busstat/busstat
+usr/src/cmd/cal/cal
+usr/src/cmd/cal/cal.dc
+usr/src/cmd/calendar/calendar
+usr/src/cmd/calendar/calprog
+usr/src/cmd/captoinfo/captoinfo
+usr/src/cmd/cat/cat
+usr/src/cmd/cdrw/cdrw
+usr/src/cmd/cfgadm/cfgadm
+usr/src/cmd/cfgadm/cfgadm.dc
+usr/src/cmd/checkeq/checkeq
+usr/src/cmd/checknr/checknr
+usr/src/cmd/chgrp/chgrp
+usr/src/cmd/chgrp/chgrp.xpg4
+usr/src/cmd/chmod/chmod
+usr/src/cmd/chown/chown
+usr/src/cmd/chown/chown.xpg4
+usr/src/cmd/chroot/chroot
+usr/src/cmd/clear/clear
+usr/src/cmd/clinfo/clinfo
+usr/src/cmd/cmd-crypto/cryptoadm/cryptoadm
+usr/src/cmd/cmd-crypto/decrypt/amd64/decrypt
+usr/src/cmd/cmd-crypto/decrypt/i386/decrypt
+usr/src/cmd/cmd-crypto/digest/amd64/digest
+usr/src/cmd/cmd-crypto/digest/i386/digest
+usr/src/cmd/cmd-crypto/elfsign/elfsign
+usr/src/cmd/cmd-crypto/etc/certs/SUNWObjectCA
+usr/src/cmd/cmd-crypto/kmfcfg/kmfcfg
+usr/src/cmd/cmd-crypto/kmscfg/kmscfg
+usr/src/cmd/cmd-crypto/pktool/pktool
+usr/src/cmd/cmd-crypto/tpmadm/tpmadm
+usr/src/cmd/cmd-inet/etc/datemsk.ndpd
+usr/src/cmd/cmd-inet/lib/ipmgmtd/ipmgmtd
+usr/src/cmd/cmd-inet/lib/netcfgd/netcfgd
+usr/src/cmd/cmd-inet/lib/nwamd/nwamd
+usr/src/cmd/cmd-inet/sbin/dhcpagent/dhcpagent
+usr/src/cmd/cmd-inet/sbin/dhcpinfo/dhcpinfo
+usr/src/cmd/cmd-inet/sbin/ifparse/ifparse
+usr/src/cmd/cmd-inet/sbin/netstrategy/netstrategy
+usr/src/cmd/cmd-inet/usr.bin/chat/chat
+usr/src/cmd/cmd-inet/usr.bin/dns-sd
+usr/src/cmd/cmd-inet/usr.bin/finger
+usr/src/cmd/cmd-inet/usr.bin/ftp/ftp
+usr/src/cmd/cmd-inet/usr.bin/nc/nc
+usr/src/cmd/cmd-inet/usr.bin/nca/ncab2clf
+usr/src/cmd/cmd-inet/usr.bin/netstat/netstat
+usr/src/cmd/cmd-inet/usr.bin/pppd/pppd
+usr/src/cmd/cmd-inet/usr.bin/pppdump/THIRDPARTYLICENSE
+usr/src/cmd/cmd-inet/usr.bin/pppdump/pppdump
+usr/src/cmd/cmd-inet/usr.bin/pppstats/pppstats
+usr/src/cmd/cmd-inet/usr.bin/rcp
+usr/src/cmd/cmd-inet/usr.bin/rdate
+usr/src/cmd/cmd-inet/usr.bin/rdist/rdist
+usr/src/cmd/cmd-inet/usr.bin/rlogin
+usr/src/cmd/cmd-inet/usr.bin/rsh
+usr/src/cmd/cmd-inet/usr.bin/ruptime
+usr/src/cmd/cmd-inet/usr.bin/rwho
+usr/src/cmd/cmd-inet/usr.bin/talk/talk
+usr/src/cmd/cmd-inet/usr.bin/telnet/telnet
+usr/src/cmd/cmd-inet/usr.bin/tftp/tftp
+usr/src/cmd/cmd-inet/usr.bin/whois
+usr/src/cmd/cmd-inet/usr.lib/bridged/bridged
+usr/src/cmd/cmd-inet/usr.lib/dhcp/dhcpconfig
+usr/src/cmd/cmd-inet/usr.lib/dhcp/dhtadm
+usr/src/cmd/cmd-inet/usr.lib/dhcp/pntadm
+usr/src/cmd/cmd-inet/usr.lib/dsvclockd/dsvclockd
+usr/src/cmd/cmd-inet/usr.lib/ilbd/ilb/ilb_probe
+usr/src/cmd/cmd-inet/usr.lib/ilbd/ilbd
+usr/src/cmd/cmd-inet/usr.lib/in.chargend/in.chargend
+usr/src/cmd/cmd-inet/usr.lib/in.daytimed/in.daytimed
+usr/src/cmd/cmd-inet/usr.lib/in.dhcpd/in.dhcpd
+usr/src/cmd/cmd-inet/usr.lib/in.discardd/in.discardd
+usr/src/cmd/cmd-inet/usr.lib/in.echod/in.echod
+usr/src/cmd/cmd-inet/usr.lib/in.mpathd/in.mpathd
+usr/src/cmd/cmd-inet/usr.lib/in.ndpd/in.ndpd
+usr/src/cmd/cmd-inet/usr.lib/in.ripngd/in.ripngd
+usr/src/cmd/cmd-inet/usr.lib/in.timed/in.timed
+usr/src/cmd/cmd-inet/usr.lib/inetd/inetd
+usr/src/cmd/cmd-inet/usr.lib/inetd/inetd-upgrade
+usr/src/cmd/cmd-inet/usr.lib/mdnsd/mdnsd
+usr/src/cmd/cmd-inet/usr.lib/ncaconfd/ncaconfd
+usr/src/cmd/cmd-inet/usr.lib/pppoe/pppoec
+usr/src/cmd/cmd-inet/usr.lib/pppoe/pppoed
+usr/src/cmd/cmd-inet/usr.lib/slpd/slpd
+usr/src/cmd/cmd-inet/usr.lib/vrrpd/vrrpd
+usr/src/cmd/cmd-inet/usr.lib/wanboot/encr/encr
+usr/src/cmd/cmd-inet/usr.lib/wanboot/hmac/hmac
+usr/src/cmd/cmd-inet/usr.lib/wanboot/ickey/ickey
+usr/src/cmd/cmd-inet/usr.lib/wanboot/keygen/keygen
+usr/src/cmd/cmd-inet/usr.lib/wanboot/keymgmt/keymgmt
+usr/src/cmd/cmd-inet/usr.lib/wanboot/netbootinfo/netbootinfo
+usr/src/cmd/cmd-inet/usr.lib/wanboot/p12split/p12split
+usr/src/cmd/cmd-inet/usr.lib/wanboot/wanboot-cgi/wanboot-cgi
+usr/src/cmd/cmd-inet/usr.lib/wpad/wpad
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/SUNWbinfiles.jar
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/SUNWbinfiles.manifest
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/SUNWfiles.jar
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/SUNWfiles.manifest
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/bin/dhcpmgr
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/Bridge.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/BridgeException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/DsymException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/ExistsException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/HostExistsException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/InvalidPathException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/InvalidRsrcException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/NoDefaultsException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/NoEntryException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/NoHostsEntryException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/NoTableException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/NotRunningException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/TableExistsException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/WordexpException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/bridge/com_sun_dhcpmgr_bridge_Bridge.h
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/Console.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/DhcpCliFunction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/DhcpCliOption.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/DhcpCliOptions.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/DhcpCliPrint.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/DhcpCliProgram.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/Format.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/GetOpt.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/GetSubOpt.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/common/Util.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpbatch/DhcpBatch.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpbatch/DhcpCommand.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpbatch/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureBootp.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureDhcp.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureNetwork.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$Action.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$ActionDisable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$ActionEnable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$ActionImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$ActionQuery.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService$ActionReenable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConfigureService.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ConvertDataStore.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/DhcpCfg.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/DhcpCfgFunction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ExportData.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/IPAddressList.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ImportData.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter$Action.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter$ActionDelete.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter$ActionGet.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter$ActionGetAll.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter$ActionImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter$ActionSet.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/ServerParameter.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhcpconfig/UnconfigureDhcp.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/AddEntry.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/CreateTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/DeleteEntry.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/DhtAdm.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/DhtAdmBatch.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/DhtAdmFunction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/DisplayTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/ModifyEntry.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/RemoveTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/dhtadm/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/AddClientEntry.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/CreateNetworkTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/DeleteClientEntry.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/DisplayNetworkTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/ListNetworkTables.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/ModifyClientEntry.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/PntAdm.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/PntAdmBatch.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/PntAdmFunction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/RemoveNetworkTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/cli/pntadm/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$10.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$11.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$5.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$6$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$6.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$7$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$7.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$8.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$9.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$AddressLoader$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$AddressLoader.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$AddressTableCellRenderer.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$AddressTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$DialogListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView$NetworkListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressView.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$2$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$Address.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ConfigureStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ConfigureStep$MacroListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ConfigureStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ConfirmStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$LeaseStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$NumberStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$NumberStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ReviewStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ServerStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$ServerStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard$WizardTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/AddressWizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$DnsStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$LeaseStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetTypeStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetTypeStep$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetTypeStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetworkStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetworkStep$NetworkComboBoxEditor.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetworkStep$NetworkListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NetworkStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$NisStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard$ReviewStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigWizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigureChoiceDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConfigureRelayDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConvertWizard$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConvertWizard$2$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConvertWizard$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConvertWizard$ReviewStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConvertWizard$SaveTablesStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ConvertWizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateAddressDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateAddressDialog$MacroListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateAddressDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateMacroDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateMacroDialog$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateMacroDialog$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateMacroDialog$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateMacroDialog$MacroTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateMacroDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$5.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$6.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog$ClassListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/CreateOptionDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSModule.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSModuleEvent.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSModuleListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard$DSConf.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard$DSConfButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard$DSConfList.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard$DatastoreModuleStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard$DatastoreStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard$DatastoreStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DSWizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DataManager.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteAddressDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteAddressDialog$AddressTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteAddressDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteMacroDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog$5.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog$NetworkListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteNetworksDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DeleteOptionDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ConversionTransition.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ConvertAction$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ConvertAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$DisableAction$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$DisableAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$EnableAction$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$EnableAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ExportAction$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ExportAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$HowToAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ImportAction$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ImportAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$IndexAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ModifyServiceAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$OverviewAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$RestartAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$ServiceAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$StartAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$StopAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$UnconfigureServiceAction$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$UnconfigureServiceAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet$WizardTransition.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrApplet.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcpmgrDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcptabNameDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DhcptabNameField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DialogActions.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/DisableServiceDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ErrorTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ErrorTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$ErrorDisplay.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$FileStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$FileStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$MacroStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$NetworkStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$OptionStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$OverwritePrompter.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$ReviewStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard$WarningDisplay.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ExportWizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$ErrorDisplay.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$LocationStep$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$LocationStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard$ReviewStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ImportWizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroLoader$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroLoader.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroNameField$MacroNameDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroNameField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$DialogListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$MacroTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$MacroTreeModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$MacroTreeNode.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView$MacroTreeRootNode.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MacroView.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ModifyAddressesDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ModifyAddressesDialog$MacroListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ModifyAddressesDialog$ServerListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ModifyAddressesDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MultipleOperationDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MultipleOperationDialog$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/MultipleOperationDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionNameField$OptionNameDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionNameField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$5.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$DialogListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$OptionLoader$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$OptionLoader.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView$OptionTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/OptionView.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/RelayView.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ReleaseAddressDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ReleaseAddressDialog$AddressTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ReleaseAddressDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SUNWModule$PathListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SUNWModule.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SUNWbinfiles/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SUNWbinfiles/SUNWbinfiles.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SUNWfiles/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SUNWfiles/SUNWfiles.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SelectOptionDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SelectOptionDialog$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SelectOptionDialog$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SelectOptionDialog$OptionTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/SelectOptionDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$5.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$6.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$7.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$8.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog$InterfaceTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ServerOptionsDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/UnconfigureDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/UnconfigureDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ViewMacroDialog$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ViewMacroDialog$MacroTableModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/client/ViewMacroDialog.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/common/ExportController.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/common/Exporter.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/common/ImportController.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/common/Importer.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/common/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/ActionError.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/AsciiOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/BogusOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/BooleanOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpClientFlagType.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpClientFlagTypes.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpClientRecord.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpConfigOpts.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpConfigOpts.java
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpDatastore.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpResource.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcpdOptions.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/DhcptabRecord.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/ExportHeader.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/IPAddress.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/IPInterface.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/IPOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/IncludeOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/Macro.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/Network.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/NumberOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/NumberValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/OctetOptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/Option.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/OptionContext.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/OptionType.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/OptionValue.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/OptionValueFactory.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/OptionsTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/StandardOptions$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/StandardOptions.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/ValidationException.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/Qualifier.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierAnd.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierArray.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierBoolean.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierEnum.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierFQDN.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierIPv4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierIPv6.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierInteger.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierIntegerEnum.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierIntegerRange.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierOr.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierRange.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierString.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierStringEnum.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierType.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/data/qualifier/QualifierTypeImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcpMgr.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcpMgrImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcpNetMgr.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcpNetMgrImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcpServiceMgr.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcpServiceMgrImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcptabMgr.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/server/DhcptabMgrImpl.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ALIGNMENT.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/AutosizingTable.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ButtonLayout.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ButtonPanel$ButtonAdaptor.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ButtonPanel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ButtonPanelListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/DownButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ExtendedCellRenderer.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/FieldLayout$Row.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/FieldLayout.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/FixedSelectionModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/HelpIds.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/HostnameField$HostnameDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/HostnameField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressField$IPAddressDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressList$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressList$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressList$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressList$IPAddressListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IPAddressList.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ImageButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IntegerField$IntegerDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/IntegerField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/LeftButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ListPair$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ListPair$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ListPair$3.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ListPair$4.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ListPair.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ListPairLayout.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$CreateAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$DeleteAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$DuplicateAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$ExitAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$FindPanel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$PropertiesAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$StatusBar.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$UpdateAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame$ViewSelectionListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MainFrame.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Mnemonic.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/MnemonicAction.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/NextButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/NoSpaceField$NoSpaceDocument.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/NoSpaceField.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/OurListModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/PreviousButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ProgressManager$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ProgressManager.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ProportionalLayout.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/ResourceStrings.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/RightButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/SelectionListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/SortedHeaderRenderer.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/SwingWorker$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/SwingWorker$2.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/SwingWorker.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/TableMap.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/TableSorter$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/TableSorter.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/UpButton.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/VerticalButtonLayout.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/View.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/WizButtonListener.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$1.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$1MyTextArea.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizButtonPanel$ButtonAdaptor.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizButtonPanel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizContentsPanel$ContentsModel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizContentsPanel$ContentsRenderer.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizContentsPanel$MyList.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizContentsPanel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard$WizStepPanel.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/Wizard.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/com/sun/dhcpmgr/ui/WizardStep.class
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/dhcpcli.jar
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/dhcpcommon.jar
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/dhcpmgr.jar
+usr/src/cmd/cmd-inet/usr.sadm/dhcpmgr/dhcpsvc.jar
+usr/src/cmd/cmd-inet/usr.sbin/6to4relay
+usr/src/cmd/cmd-inet/usr.sbin/THIRDPARTYLICENSE.arp
+usr/src/cmd/cmd-inet/usr.sbin/arp
+usr/src/cmd/cmd-inet/usr.sbin/bootconfchk/bootconfchk
+usr/src/cmd/cmd-inet/usr.sbin/dhcpconfig
+usr/src/cmd/cmd-inet/usr.sbin/dhtadm
+usr/src/cmd/cmd-inet/usr.sbin/gettable
+usr/src/cmd/cmd-inet/usr.sbin/hostconfig
+usr/src/cmd/cmd-inet/usr.sbin/htable/htable
+usr/src/cmd/cmd-inet/usr.sbin/htable/y.tab.h
+usr/src/cmd/cmd-inet/usr.sbin/if_mpadm
+usr/src/cmd/cmd-inet/usr.sbin/ifconfig/ifconfig
+usr/src/cmd/cmd-inet/usr.sbin/ilbadm/ilbadm
+usr/src/cmd/cmd-inet/usr.sbin/in.comsat
+usr/src/cmd/cmd-inet/usr.sbin/in.fingerd
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ckconfig
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftpaddhost
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftpcmd.c
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftpconfig
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftpcount
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftprestart
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftpshut
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/ftpwho
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/in.ftpd
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/privatepw
+usr/src/cmd/cmd-inet/usr.sbin/in.ftpd/y.tab.h
+usr/src/cmd/cmd-inet/usr.sbin/in.rarpd
+usr/src/cmd/cmd-inet/usr.sbin/in.rdisc/in.rdisc
+usr/src/cmd/cmd-inet/usr.sbin/in.rexecd
+usr/src/cmd/cmd-inet/usr.sbin/in.rlogind
+usr/src/cmd/cmd-inet/usr.sbin/in.routed/in.routed
+usr/src/cmd/cmd-inet/usr.sbin/in.routed/rtquery
+usr/src/cmd/cmd-inet/usr.sbin/in.rshd
+usr/src/cmd/cmd-inet/usr.sbin/in.rwhod
+usr/src/cmd/cmd-inet/usr.sbin/in.talkd/in.talkd
+usr/src/cmd/cmd-inet/usr.sbin/in.telnetd
+usr/src/cmd/cmd-inet/usr.sbin/in.tftpd
+usr/src/cmd/cmd-inet/usr.sbin/inetadm/inetadm
+usr/src/cmd/cmd-inet/usr.sbin/inetconv/inetconv
+usr/src/cmd/cmd-inet/usr.sbin/ipaddrsel
+usr/src/cmd/cmd-inet/usr.sbin/ipadm/ipadm
+usr/src/cmd/cmd-inet/usr.sbin/ipmpstat/ipmpstat
+usr/src/cmd/cmd-inet/usr.sbin/ipqosconf/ipqosconf
+usr/src/cmd/cmd-inet/usr.sbin/ipsecutils/ikeadm
+usr/src/cmd/cmd-inet/usr.sbin/ipsecutils/ikecert
+usr/src/cmd/cmd-inet/usr.sbin/ipsecutils/ipsecalgs
+usr/src/cmd/cmd-inet/usr.sbin/ipsecutils/ipsecconf
+usr/src/cmd/cmd-inet/usr.sbin/ipsecutils/ipseckey
+usr/src/cmd/cmd-inet/usr.sbin/kssl/kssladm/kssladm
+usr/src/cmd/cmd-inet/usr.sbin/kssl/ksslcfg/ksslcfg
+usr/src/cmd/cmd-inet/usr.sbin/ndd
+usr/src/cmd/cmd-inet/usr.sbin/nwamadm/nwamadm
+usr/src/cmd/cmd-inet/usr.sbin/nwamcfg/nwamcfg
+usr/src/cmd/cmd-inet/usr.sbin/nwamcfg/nwamcfg_grammar.tab.c
+usr/src/cmd/cmd-inet/usr.sbin/nwamcfg/nwamcfg_grammar.tab.h
+usr/src/cmd/cmd-inet/usr.sbin/nwamcfg/nwamcfg_lex.c
+usr/src/cmd/cmd-inet/usr.sbin/ping/ping
+usr/src/cmd/cmd-inet/usr.sbin/pntadm
+usr/src/cmd/cmd-inet/usr.sbin/route
+usr/src/cmd/cmd-inet/usr.sbin/routeadm/routeadm
+usr/src/cmd/cmd-inet/usr.sbin/snoop/snoop
+usr/src/cmd/cmd-inet/usr.sbin/soconfig
+usr/src/cmd/cmd-inet/usr.sbin/sppptun/sppptun
+usr/src/cmd/cmd-inet/usr.sbin/syncinit
+usr/src/cmd/cmd-inet/usr.sbin/syncloop
+usr/src/cmd/cmd-inet/usr.sbin/syncstat
+usr/src/cmd/cmd-inet/usr.sbin/traceroute/traceroute
+usr/src/cmd/cmd-inet/usr.sbin/wanbootutil
+usr/src/cmd/cmd-inet/usr.sbin/wificonfig/wificonfig
+usr/src/cmd/col/col
+usr/src/cmd/compress/compress
+usr/src/cmd/consadm/i386/consadm
+usr/src/cmd/coreadm/coreadm
+usr/src/cmd/cpc/cpustat/cpustat
+usr/src/cmd/cpc/cputrack/amd64/cputrack
+usr/src/cmd/cpc/cputrack/i386/cputrack
+usr/src/cmd/cpio/cpio
+usr/src/cmd/cron/at
+usr/src/cmd/cron/at.xpg4
+usr/src/cmd/cron/atq
+usr/src/cmd/cron/atrm
+usr/src/cmd/cron/att1.c
+usr/src/cmd/cron/att1.h
+usr/src/cmd/cron/att2.c
+usr/src/cmd/cron/batch
+usr/src/cmd/cron/batch.xpg4
+usr/src/cmd/cron/cron
+usr/src/cmd/cron/crontab
+usr/src/cmd/cron/crontab.xpg4
+usr/src/cmd/cron/crontab.xpg6
+usr/src/cmd/crypt/crypt
+usr/src/cmd/csh/i386/csh
+usr/src/cmd/csh/sh.tconst.h
+usr/src/cmd/csplit/csplit
+usr/src/cmd/ctrun/ctrun
+usr/src/cmd/ctstat/ctstat
+usr/src/cmd/ctwatch/ctwatch
+usr/src/cmd/datadm/datadm
+usr/src/cmd/date/date
+usr/src/cmd/date/date.xpg4
+usr/src/cmd/dc/dc
+usr/src/cmd/dc/dc.xpg6
+usr/src/cmd/dd/dd
+usr/src/cmd/deroff/deroff
+usr/src/cmd/devctl/devctl
+usr/src/cmd/devfsadm/i386/devfsadm
+usr/src/cmd/devfsadm/i386/devlink.tab
+usr/src/cmd/devfsadm/plcysubr.c
+usr/src/cmd/devinfo/devinfo
+usr/src/cmd/devmgmt/cmds/devattr
+usr/src/cmd/devmgmt/cmds/devfree
+usr/src/cmd/devmgmt/cmds/devreserv
+usr/src/cmd/devmgmt/cmds/getdev
+usr/src/cmd/devmgmt/cmds/getdgrp
+usr/src/cmd/devmgmt/cmds/getvol
+usr/src/cmd/devmgmt/cmds/listdgrp
+usr/src/cmd/devmgmt/cmds/putdev
+usr/src/cmd/devmgmt/cmds/putdgrp
+usr/src/cmd/devmgmt/mkdtab/mkdtab
+usr/src/cmd/devprop/devprop
+usr/src/cmd/dfs.cmds/dfshares/dfshares
+usr/src/cmd/dfs.cmds/general/unshare
+usr/src/cmd/dfs.cmds/shareall/shareall
+usr/src/cmd/dfs.cmds/sharectl/i386/sharectl
+usr/src/cmd/dfs.cmds/sharectl/i386/shareutil.c
+usr/src/cmd/dfs.cmds/sharemgr/i386/sharemgr
+usr/src/cmd/dfs.cmds/unshareall/unshareall
+usr/src/cmd/diff/diff
+usr/src/cmd/diff/diff.dc
+usr/src/cmd/diff/diffh
+usr/src/cmd/diff3/diff3
+usr/src/cmd/diff3/diff3prog
+usr/src/cmd/diffmk/diffmk
+usr/src/cmd/dircmp/dircmp
+usr/src/cmd/dirname/dirname
+usr/src/cmd/dis/dis
+usr/src/cmd/diskscan/diskscan
+usr/src/cmd/dispadmin/FSSdispadmin
+usr/src/cmd/dispadmin/FXdispadmin
+usr/src/cmd/dispadmin/IAdispadmin
+usr/src/cmd/dispadmin/RTdispadmin
+usr/src/cmd/dispadmin/SDCdispadmin
+usr/src/cmd/dispadmin/TSdispadmin
+usr/src/cmd/dispadmin/dispadmin
+usr/src/cmd/dladm/dladm
+usr/src/cmd/dlmgmtd/dlmgmtd
+usr/src/cmd/dlstat/dlstat
+usr/src/cmd/dmesg/dmesg
+usr/src/cmd/dtrace/amd64/dtrace
+usr/src/cmd/dtrace/demo/applicat.d
+usr/src/cmd/dtrace/demo/badopen.d
+usr/src/cmd/dtrace/demo/begin.d
+usr/src/cmd/dtrace/demo/callout.d
+usr/src/cmd/dtrace/demo/clause.d
+usr/src/cmd/dtrace/demo/clear.d
+usr/src/cmd/dtrace/demo/countdown.d
+usr/src/cmd/dtrace/demo/counter.d
+usr/src/cmd/dtrace/demo/dateprof.d
+usr/src/cmd/dtrace/demo/delay.d
+usr/src/cmd/dtrace/demo/denorm.d
+usr/src/cmd/dtrace/demo/end.d
+usr/src/cmd/dtrace/demo/error.d
+usr/src/cmd/dtrace/demo/errorpath.d
+usr/src/cmd/dtrace/demo/find.d
+usr/src/cmd/dtrace/demo/firebird.d
+usr/src/cmd/dtrace/demo/hello.d
+usr/src/cmd/dtrace/demo/howlong.d
+usr/src/cmd/dtrace/demo/index.html
+usr/src/cmd/dtrace/demo/interp.d
+usr/src/cmd/dtrace/demo/interval.d
+usr/src/cmd/dtrace/demo/intr.d
+usr/src/cmd/dtrace/demo/iocpu.d
+usr/src/cmd/dtrace/demo/iosnoop.d
+usr/src/cmd/dtrace/demo/iothrough.d
+usr/src/cmd/dtrace/demo/iotime.d
+usr/src/cmd/dtrace/demo/ipio.d
+usr/src/cmd/dtrace/demo/ipproto.d
+usr/src/cmd/dtrace/demo/iprb.d
+usr/src/cmd/dtrace/demo/kstat.d
+usr/src/cmd/dtrace/demo/ksyms.d
+usr/src/cmd/dtrace/demo/libc.d
+usr/src/cmd/dtrace/demo/lquantize.d
+usr/src/cmd/dtrace/demo/lwptime.d
+usr/src/cmd/dtrace/demo/mkdemo
+usr/src/cmd/dtrace/demo/normalize.d
+usr/src/cmd/dtrace/demo/nscd.d
+usr/src/cmd/dtrace/demo/pri.d
+usr/src/cmd/dtrace/demo/printa.d
+usr/src/cmd/dtrace/demo/pritime.d
+usr/src/cmd/dtrace/demo/prof.d
+usr/src/cmd/dtrace/demo/profpri.d
+usr/src/cmd/dtrace/demo/progtime.d
+usr/src/cmd/dtrace/demo/putnext.d
+usr/src/cmd/dtrace/demo/qlen.d
+usr/src/cmd/dtrace/demo/qtime.d
+usr/src/cmd/dtrace/demo/renormalize.d
+usr/src/cmd/dtrace/demo/restest.d
+usr/src/cmd/dtrace/demo/ring.d
+usr/src/cmd/dtrace/demo/rtime.d
+usr/src/cmd/dtrace/demo/rwinfo.d
+usr/src/cmd/dtrace/demo/rwtime.d
+usr/src/cmd/dtrace/demo/sig.d
+usr/src/cmd/dtrace/demo/soffice.d
+usr/src/cmd/dtrace/demo/spec.d
+usr/src/cmd/dtrace/demo/specopen.d
+usr/src/cmd/dtrace/demo/ssd.d
+usr/src/cmd/dtrace/demo/syscall.d
+usr/src/cmd/dtrace/demo/tcp1stbyte.d
+usr/src/cmd/dtrace/demo/tcpbytes.d
+usr/src/cmd/dtrace/demo/tcpbytesstat.d
+usr/src/cmd/dtrace/demo/tcpconnlat.d
+usr/src/cmd/dtrace/demo/tcpio.d
+usr/src/cmd/dtrace/demo/tcpioflags.d
+usr/src/cmd/dtrace/demo/tcprst.d
+usr/src/cmd/dtrace/demo/tcpsnoop.d
+usr/src/cmd/dtrace/demo/tcpstate.d
+usr/src/cmd/dtrace/demo/tcptop.d
+usr/src/cmd/dtrace/demo/tick.d
+usr/src/cmd/dtrace/demo/ticktime.d
+usr/src/cmd/dtrace/demo/time.d
+usr/src/cmd/dtrace/demo/tracewrite.d
+usr/src/cmd/dtrace/demo/trunc.d
+usr/src/cmd/dtrace/demo/trussrw.d
+usr/src/cmd/dtrace/demo/udpbytes.d
+usr/src/cmd/dtrace/demo/udpbytesstat.d
+usr/src/cmd/dtrace/demo/udpio.d
+usr/src/cmd/dtrace/demo/udpsnoop.d
+usr/src/cmd/dtrace/demo/udptop.d
+usr/src/cmd/dtrace/demo/userfunc.d
+usr/src/cmd/dtrace/demo/whatfor.d
+usr/src/cmd/dtrace/demo/whatlock.d
+usr/src/cmd/dtrace/demo/where.d
+usr/src/cmd/dtrace/demo/whererun.d
+usr/src/cmd/dtrace/demo/whoexec.d
+usr/src/cmd/dtrace/demo/whofor.d
+usr/src/cmd/dtrace/demo/whoio.d
+usr/src/cmd/dtrace/demo/whopreempt.d
+usr/src/cmd/dtrace/demo/whoqueue.d
+usr/src/cmd/dtrace/demo/whosteal.d
+usr/src/cmd/dtrace/demo/whowrite.d
+usr/src/cmd/dtrace/demo/writes.d
+usr/src/cmd/dtrace/demo/writesbycmd.d
+usr/src/cmd/dtrace/demo/writesbycmdfd.d
+usr/src/cmd/dtrace/demo/writetime.d
+usr/src/cmd/dtrace/demo/writetimeq.d
+usr/src/cmd/dtrace/demo/xioctl.d
+usr/src/cmd/dtrace/demo/xterm.d
+usr/src/cmd/dtrace/demo/xwork.d
+usr/src/cmd/dtrace/i386/dtrace
+usr/src/cmd/dtrace/test/cmd/baddof/baddof
+usr/src/cmd/dtrace/test/cmd/badioctl/badioctl
+usr/src/cmd/dtrace/test/cmd/chkargs/amd64/chkargs
+usr/src/cmd/dtrace/test/cmd/chkargs/i386/chkargs
+usr/src/cmd/dtrace/test/cmd/jdtrace/classes/
+usr/src/cmd/dtrace/test/cmd/jdtrace/jdtrace
+usr/src/cmd/dtrace/test/cmd/jdtrace/lib/
+usr/src/cmd/dtrace/test/tst/common/io/tst.fds.exe
+usr/src/cmd/dtrace/test/tst/common/java_api/classes/
+usr/src/cmd/dtrace/test/tst/common/java_api/test.jar
+usr/src/cmd/dtrace/test/tst/common/java_api/tst.FunctionLookup.exe
+usr/src/cmd/dtrace/test/tst/common/java_api/tst.ProbeData.exe
+usr/src/cmd/dtrace/test/tst/common/nfs/tst.call.exe
+usr/src/cmd/dtrace/test/tst/common/nfs/tst.call3.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.args1.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.float.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.fork.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.gcc.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.ret1.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.ret2.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.vfork.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.weak1.exe
+usr/src/cmd/dtrace/test/tst/common/pid/tst.weak2.exe
+usr/src/cmd/dtrace/test/tst/common/proc/tst.sigwait.exe
+usr/src/cmd/dtrace/test/tst/common/profile-n/tst.ufuncsort.exe
+usr/src/cmd/dtrace/test/tst/common/raise/tst.raise1.exe
+usr/src/cmd/dtrace/test/tst/common/raise/tst.raise2.exe
+usr/src/cmd/dtrace/test/tst/common/raise/tst.raise3.exe
+usr/src/cmd/dtrace/test/tst/common/sdt/tst.sdtargs.exe
+usr/src/cmd/dtrace/test/tst/common/stop/tst.stop1.exe
+usr/src/cmd/dtrace/test/tst/common/stop/tst.stop2.exe
+usr/src/cmd/dtrace/test/tst/common/syscall/tst.args.exe
+usr/src/cmd/dtrace/test/tst/common/sysevent/tst.post.exe
+usr/src/cmd/dtrace/test/tst/common/sysevent/tst.post_chan.exe
+usr/src/cmd/dtrace/test/tst/common/usdt/forker.h
+usr/src/cmd/dtrace/test/tst/common/usdt/tst.argmap.exe
+usr/src/cmd/dtrace/test/tst/common/usdt/tst.args.exe
+usr/src/cmd/dtrace/test/tst/common/usdt/tst.forker.exe
+usr/src/cmd/dtrace/test/tst/common/ustack/tst.bigstack.exe
+usr/src/cmd/dtrace/test/tst/common/ustack/tst.spin.exe
+usr/src/cmd/dtrace/test/tst/i386/pid/tst.badinstr.exe
+usr/src/cmd/dtrace/test/tst/i386/pid/tst.branch.exe
+usr/src/cmd/dtrace/test/tst/i386/pid/tst.embedded.exe
+usr/src/cmd/dtrace/test/tst/i386/pid/tst.ret.exe
+usr/src/cmd/dtrace/test/tst/i386/pid/tst.retlist.exe
+usr/src/cmd/dtrace/test/tst/i386/ustack/tst.annotated.exe
+usr/src/cmd/dtrace/test/tst/i386/ustack/tst.circstack.exe
+usr/src/cmd/dtrace/test/tst/i386/ustack/tst.helper.exe
+usr/src/cmd/du/du
+usr/src/cmd/du/du.po.xpg4
+usr/src/cmd/du/du.xpg4
+usr/src/cmd/dumpadm/dumpadm
+usr/src/cmd/dumpcs/dumpcs
+usr/src/cmd/echo/echo
+usr/src/cmd/ed/compile.c.i
+usr/src/cmd/ed/ed
+usr/src/cmd/ed/ed.xpg4
+usr/src/cmd/ed/ed.xpg6
+usr/src/cmd/eeprom/i386/eeprom
+usr/src/cmd/egrep/egrep
+usr/src/cmd/egrep/egrep.c
+usr/src/cmd/eject/eject
+usr/src/cmd/emul64ioctl/emul64ioctl
+usr/src/cmd/enhance/enhance
+usr/src/cmd/env/env
+usr/src/cmd/env/env.xpg4
+usr/src/cmd/eqn/eqn.d/e.c
+usr/src/cmd/eqn/eqn.d/e.def
+usr/src/cmd/eqn/eqn.d/eqn
+usr/src/cmd/eqn/neqn.d/e.c
+usr/src/cmd/eqn/neqn.d/e.def
+usr/src/cmd/eqn/neqn.d/neqn
+usr/src/cmd/expand/expand
+usr/src/cmd/expand/expand_cmd.c
+usr/src/cmd/expand/unexpand
+usr/src/cmd/expr/expr
+usr/src/cmd/expr/expr.xpg4
+usr/src/cmd/expr/expr.xpg6
+usr/src/cmd/exstr/exstr
+usr/src/cmd/factor/factor
+usr/src/cmd/false/false
+usr/src/cmd/fcinfo/fcinfo
+usr/src/cmd/fcoesvc/svc-fcoei
+usr/src/cmd/fcoesvc/svc-fcoet
+usr/src/cmd/fdetach/fdetach
+usr/src/cmd/fdformat/fdformat
+usr/src/cmd/fdisk/fdisk
+usr/src/cmd/fgrep/fgrep
+usr/src/cmd/file/file
+usr/src/cmd/file/file.xpg4
+usr/src/cmd/filebench/amd64/go_filebench
+usr/src/cmd/filebench/amd64/parser_gram.c
+usr/src/cmd/filebench/amd64/parser_gram.h
+usr/src/cmd/filebench/amd64/parser_lex.c
+usr/src/cmd/filebench/fbscript/filebench
+usr/src/cmd/filebench/i386/go_filebench
+usr/src/cmd/filebench/i386/parser_gram.c
+usr/src/cmd/filebench/i386/parser_gram.h
+usr/src/cmd/filebench/i386/parser_lex.c
+usr/src/cmd/filebench/scripts/filebench_compare
+usr/src/cmd/filebench/scripts/fs_flush
+usr/src/cmd/filesync/filesync
+usr/src/cmd/find/find
+usr/src/cmd/find/find.xpg4
+usr/src/cmd/flowadm/flowadm
+usr/src/cmd/flowstat/flowstat
+usr/src/cmd/fm/dicts/AMD.mo
+usr/src/cmd/fm/dicts/DISK.mo
+usr/src/cmd/fm/dicts/FMD.mo
+usr/src/cmd/fm/dicts/FMNOTIFY.mo
+usr/src/cmd/fm/dicts/GMCA.mo
+usr/src/cmd/fm/dicts/INTEL.mo
+usr/src/cmd/fm/dicts/NXGE.mo
+usr/src/cmd/fm/dicts/PCI.mo
+usr/src/cmd/fm/dicts/PCIEX.mo
+usr/src/cmd/fm/dicts/SCA1000.mo
+usr/src/cmd/fm/dicts/SCA500.mo
+usr/src/cmd/fm/dicts/SENSOR.mo
+usr/src/cmd/fm/dicts/SMF.mo
+usr/src/cmd/fm/dicts/STORAGE.mo
+usr/src/cmd/fm/dicts/SUNOS.mo
+usr/src/cmd/fm/dicts/TEST.mo
+usr/src/cmd/fm/dicts/ZFS.mo
+usr/src/cmd/fm/eversholt/eftinfo/i386/eftinfo
+usr/src/cmd/fm/eversholt/eftinfo/i386/y.output
+usr/src/cmd/fm/eversholt/eftinfo/i386/y.tab.c
+usr/src/cmd/fm/eversholt/eftinfo/i386/y.tab.h
+usr/src/cmd/fm/eversholt/esc/i386/esc
+usr/src/cmd/fm/eversholt/esc/i386/y.output
+usr/src/cmd/fm/eversholt/esc/i386/y.tab.c
+usr/src/cmd/fm/eversholt/esc/i386/y.tab.h
+usr/src/cmd/fm/eversholt/files/i386/disk.eft
+usr/src/cmd/fm/eversholt/files/i386/i86pc/amd64.eft
+usr/src/cmd/fm/eversholt/files/i386/i86pc/gcpu.eft
+usr/src/cmd/fm/eversholt/files/i386/i86pc/gcpu_amd.eft
+usr/src/cmd/fm/eversholt/files/i386/i86pc/intel.eft
+usr/src/cmd/fm/eversholt/files/i386/neptune_xaui.eft
+usr/src/cmd/fm/eversholt/files/i386/neptune_xfp.eft
+usr/src/cmd/fm/eversholt/files/i386/pci.eft
+usr/src/cmd/fm/eversholt/files/i386/pciex.eft
+usr/src/cmd/fm/eversholt/files/i386/pciexrc.eft
+usr/src/cmd/fm/eversholt/files/i386/sca1000.eft
+usr/src/cmd/fm/eversholt/files/i386/sca500.eft
+usr/src/cmd/fm/eversholt/files/i386/sensor.eft
+usr/src/cmd/fm/eversholt/files/i386/storage.eft
+usr/src/cmd/fm/fmadm/i386/fmadm
+usr/src/cmd/fm/fmd/common/fmd_error.c
+usr/src/cmd/fm/fmd/common/fmd_rpc_adm.h
+usr/src/cmd/fm/fmd/common/fmd_rpc_api.h
+usr/src/cmd/fm/fmd/i386/fmd
+usr/src/cmd/fm/fmd/i386/fmd_svc_adm.c
+usr/src/cmd/fm/fmd/i386/fmd_svc_api.c
+usr/src/cmd/fm/fmd/i386/fmd_xdr_adm.c
+usr/src/cmd/fm/fmd/i386/fmd_xdr_api.c
+usr/src/cmd/fm/fmdump/i386/fmdump
+usr/src/cmd/fm/fminject/i386/fminject
+usr/src/cmd/fm/fminject/i386/inj_grammar.c
+usr/src/cmd/fm/fminject/i386/inj_grammar.h
+usr/src/cmd/fm/fminject/i386/inj_lex.c
+usr/src/cmd/fm/fmstat/i386/fmstat
+usr/src/cmd/fm/fmtopo/i386/fmtopo
+usr/src/cmd/fm/ipmitopo/i386/ipmitopo
+usr/src/cmd/fm/modules/common/eversholt/y.tab.c
+usr/src/cmd/fm/modules/common/eversholt/y.tab.h
+usr/src/cmd/fm/notify/smtp-notify/i386/process_msg_template.sh
+usr/src/cmd/fm/notify/smtp-notify/i386/smtp-notify
+usr/src/cmd/fm/notify/snmp-notify/i386/snmp-notify
+usr/src/cmd/fm/scripts/buildcode
+usr/src/cmd/fm/scripts/bustcode
+usr/src/cmd/fm/scripts/dictck
+usr/src/cmd/fm/scripts/fmsim
+usr/src/cmd/fmt/fmt
+usr/src/cmd/fmthard/fmthard
+usr/src/cmd/fmtmsg/fmtmsg
+usr/src/cmd/fold/fold
+usr/src/cmd/format/format
+usr/src/cmd/fs.d/autofs/automount
+usr/src/cmd/fs.d/autofs/automountd
+usr/src/cmd/fs.d/autofs/dfshares
+usr/src/cmd/fs.d/autofs/mount
+usr/src/cmd/fs.d/autofs/share
+usr/src/cmd/fs.d/autofs/unshare
+usr/src/cmd/fs.d/autofs/webnfs.h
+usr/src/cmd/fs.d/autofs/webnfs.x
+usr/src/cmd/fs.d/autofs/webnfs_client.c
+usr/src/cmd/fs.d/autofs/webnfs_xdr.c
+usr/src/cmd/fs.d/cachefs/cachefslog/cachefslog
+usr/src/cmd/fs.d/cachefs/cachefspack/cachefspack
+usr/src/cmd/fs.d/cachefs/cachefsstat/cachefsstat
+usr/src/cmd/fs.d/cachefs/cachefswssize/cachefswssize
+usr/src/cmd/fs.d/cachefs/cfsadmin/cfsadmin
+usr/src/cmd/fs.d/cachefs/cfsd/cachefsd
+usr/src/cmd/fs.d/cachefs/cfsd/cachefsd_tbl.i
+usr/src/cmd/fs.d/cachefs/cfsfstype/cfsfstype
+usr/src/cmd/fs.d/cachefs/cfstagchk/cfstagchk
+usr/src/cmd/fs.d/cachefs/common/cachefsd.h
+usr/src/cmd/fs.d/cachefs/common/cachefsd_clnt.c
+usr/src/cmd/fs.d/cachefs/common/cachefsd_xdr.c
+usr/src/cmd/fs.d/cachefs/dfshares/dfshares
+usr/src/cmd/fs.d/cachefs/fsck/fsck
+usr/src/cmd/fs.d/cachefs/mount/mount
+usr/src/cmd/fs.d/cachefs/share/share
+usr/src/cmd/fs.d/cachefs/umount/umount
+usr/src/cmd/fs.d/cachefs/unshare/unshare
+usr/src/cmd/fs.d/clri
+usr/src/cmd/fs.d/ctfs/mount
+usr/src/cmd/fs.d/dev/mount
+usr/src/cmd/fs.d/df
+usr/src/cmd/fs.d/df.po.xpg4
+usr/src/cmd/fs.d/df.xpg4
+usr/src/cmd/fs.d/fd/mount
+usr/src/cmd/fs.d/ff
+usr/src/cmd/fs.d/fs.dfl
+usr/src/cmd/fs.d/fsck
+usr/src/cmd/fs.d/hsfs/labelit/labelit
+usr/src/cmd/fs.d/hsfs/mount/mount
+usr/src/cmd/fs.d/lofs/mount/mount
+usr/src/cmd/fs.d/mntfs/mount
+usr/src/cmd/fs.d/mnttab
+usr/src/cmd/fs.d/mount
+usr/src/cmd/fs.d/nfs/clear_locks/clear_locks
+usr/src/cmd/fs.d/nfs/dfmounts/dfmounts
+usr/src/cmd/fs.d/nfs/dfshares/dfshares
+usr/src/cmd/fs.d/nfs/exportfs/exportfs
+usr/src/cmd/fs.d/nfs/mount/mount
+usr/src/cmd/fs.d/nfs/mount/webnfs.h
+usr/src/cmd/fs.d/nfs/mount/webnfs.x
+usr/src/cmd/fs.d/nfs/mount/webnfs_client.c
+usr/src/cmd/fs.d/nfs/mount/webnfs_xdr.c
+usr/src/cmd/fs.d/nfs/mountd/mountd
+usr/src/cmd/fs.d/nfs/nfs4cbd/nfs4cbd
+usr/src/cmd/fs.d/nfs/nfsd/nfsd
+usr/src/cmd/fs.d/nfs/nfsfind/nfsfind
+usr/src/cmd/fs.d/nfs/nfslog/nfslogd
+usr/src/cmd/fs.d/nfs/nfsmapid/nfsmapid
+usr/src/cmd/fs.d/nfs/nfsmapid/nfsmapid_test
+usr/src/cmd/fs.d/nfs/nfsref/nfsref
+usr/src/cmd/fs.d/nfs/nfsstat/nfsstat
+usr/src/cmd/fs.d/nfs/rquotad/rquota_xdr.c
+usr/src/cmd/fs.d/nfs/rquotad/rquotad
+usr/src/cmd/fs.d/nfs/share/sharetab
+usr/src/cmd/fs.d/nfs/showmount/showmount
+usr/src/cmd/fs.d/nfs/statd/statd
+usr/src/cmd/fs.d/nfs/umount/umount
+usr/src/cmd/fs.d/objfs/mount
+usr/src/cmd/fs.d/pcfs/fsck/fsck
+usr/src/cmd/fs.d/pcfs/mkfs/mkfs
+usr/src/cmd/fs.d/pcfs/mount/mount
+usr/src/cmd/fs.d/proc/mount
+usr/src/cmd/fs.d/reparsed/reparsed
+usr/src/cmd/fs.d/sharefs/mount
+usr/src/cmd/fs.d/smbclnt/chacl/chacl
+usr/src/cmd/fs.d/smbclnt/lsacl/lsacl
+usr/src/cmd/fs.d/smbclnt/mount/mount
+usr/src/cmd/fs.d/smbclnt/share/dfshares
+usr/src/cmd/fs.d/smbclnt/share/share
+usr/src/cmd/fs.d/smbclnt/share/unshare
+usr/src/cmd/fs.d/smbclnt/smbiod-svc/smbiod-svc
+usr/src/cmd/fs.d/smbclnt/smbiod/smbiod
+usr/src/cmd/fs.d/smbclnt/smbutil/smbutil
+usr/src/cmd/fs.d/smbclnt/umount/umount
+usr/src/cmd/fs.d/tmpfs/mount
+usr/src/cmd/fs.d/udfs/fsck/fsck
+usr/src/cmd/fs.d/udfs/fsdb/fsdb
+usr/src/cmd/fs.d/udfs/fsdb/lex.yy.c
+usr/src/cmd/fs.d/udfs/fsdb/ud_lib.c
+usr/src/cmd/fs.d/udfs/fsdb/ud_lib.h
+usr/src/cmd/fs.d/udfs/fsdb/y.tab.c
+usr/src/cmd/fs.d/udfs/fsdb/y.tab.h
+usr/src/cmd/fs.d/udfs/labelit/labelit
+usr/src/cmd/fs.d/udfs/labelit/ud_lib.c
+usr/src/cmd/fs.d/udfs/labelit/ud_lib.h
+usr/src/cmd/fs.d/udfs/mkfs/mkfs
+usr/src/cmd/fs.d/udfs/mount/mount
+usr/src/cmd/fs.d/ufs/clri/clri
+usr/src/cmd/fs.d/ufs/df/df
+usr/src/cmd/fs.d/ufs/edquota/edquota
+usr/src/cmd/fs.d/ufs/ff/ff
+usr/src/cmd/fs.d/ufs/fsck/fsck
+usr/src/cmd/fs.d/ufs/fsckall/fsckall
+usr/src/cmd/fs.d/ufs/fsdb/fsdb
+usr/src/cmd/fs.d/ufs/fsirand/fsirand
+usr/src/cmd/fs.d/ufs/fssnap/fssnap
+usr/src/cmd/fs.d/ufs/labelit/labelit
+usr/src/cmd/fs.d/ufs/lockfs/lockfs
+usr/src/cmd/fs.d/ufs/mkfs/mkfs
+usr/src/cmd/fs.d/ufs/mount/mount
+usr/src/cmd/fs.d/ufs/ncheck/ncheck
+usr/src/cmd/fs.d/ufs/newfs/newfs
+usr/src/cmd/fs.d/ufs/quot/quot
+usr/src/cmd/fs.d/ufs/quota/quota
+usr/src/cmd/fs.d/ufs/quota/rquota_xdr.c
+usr/src/cmd/fs.d/ufs/quotacheck/quotacheck
+usr/src/cmd/fs.d/ufs/quotaon/quotaon
+usr/src/cmd/fs.d/ufs/repquota/repquota
+usr/src/cmd/fs.d/ufs/tunefs/tunefs
+usr/src/cmd/fs.d/ufs/volcopy/volcopy
+usr/src/cmd/fs.d/umount
+usr/src/cmd/fs.d/volcopy
+usr/src/cmd/fs.d/zfs/bootinstall/bootinstall
+usr/src/cmd/fstyp/fstyp
+usr/src/cmd/fuser/fuser
+usr/src/cmd/fwflash/i386/fwflash
+usr/src/cmd/gcore/amd64/gcore
+usr/src/cmd/gcore/i386/gcore
+usr/src/cmd/gencat/gencat
+usr/src/cmd/geniconvtbl/i386/geniconvtbl
+usr/src/cmd/geniconvtbl/i386/lex.yy.c
+usr/src/cmd/geniconvtbl/i386/y.output
+usr/src/cmd/geniconvtbl/i386/y.tab.c
+usr/src/cmd/geniconvtbl/i386/y.tab.h
+usr/src/cmd/geniconvtbl/itm_comp.c
+usr/src/cmd/geniconvtbl/native/geniconvtbl
+usr/src/cmd/geniconvtbl/native/lex.yy.c
+usr/src/cmd/geniconvtbl/native/y.output
+usr/src/cmd/geniconvtbl/native/y.tab.c
+usr/src/cmd/geniconvtbl/native/y.tab.h
+usr/src/cmd/geniconvtbl/samples/ISO646%ISO8859-1.bt
+usr/src/cmd/geniconvtbl/samples/ISO8859-1%ISO646.bt
+usr/src/cmd/genmsg/genmsg
+usr/src/cmd/genmsg/genmsg.c
+usr/src/cmd/genmsg/lex.yy.c
+usr/src/cmd/genmsg/y.tab.h
+usr/src/cmd/getconf/getconf
+usr/src/cmd/getconf/getconf.xpg4
+usr/src/cmd/getconf/getconf.xpg6
+usr/src/cmd/getdevpolicy/getdevpolicy
+usr/src/cmd/getent/getent
+usr/src/cmd/getfacl/getfacl
+usr/src/cmd/getmajor/getmajor
+usr/src/cmd/getopt/getopt
+usr/src/cmd/getopt/getoptcvt
+usr/src/cmd/gettext/gettext
+usr/src/cmd/gettxt/gettxt
+usr/src/cmd/grep/grep
+usr/src/cmd/grep_xpg4/grep.xpg4
+usr/src/cmd/groups/groups
+usr/src/cmd/grpck/grpck
+usr/src/cmd/gss/etc/dummy_mech_token.conf
+usr/src/cmd/gss/gsscred/gsscred
+usr/src/cmd/gss/gsscred_clean/gsscred_clean
+usr/src/cmd/gss/gssd/gssd
+usr/src/cmd/gss/gssd/gssd.h
+usr/src/cmd/gss/gssd/gssd.x
+usr/src/cmd/gss/gssd/gssd_clnt.c
+usr/src/cmd/gss/gssd/gssd_svc.c
+usr/src/cmd/gss/gssd/gssd_xdr.c
+usr/src/cmd/gss/gssd/gssdtest
+usr/src/cmd/hal/addons/acpi/hald-addon-acpi
+usr/src/cmd/hal/addons/cpufreq/hald-addon-cpufreq
+usr/src/cmd/hal/addons/network-devices/hald-addon-network-discovery
+usr/src/cmd/hal/addons/storage/hald-addon-storage
+usr/src/cmd/hal/hal.conf
+usr/src/cmd/hal/hald-runner/hald-runner
+usr/src/cmd/hal/hald/hald
+usr/src/cmd/hal/hald/hald_marshal.c
+usr/src/cmd/hal/hald/hald_marshal.h
+usr/src/cmd/hal/probing/acpi/hald-probe-acpi
+usr/src/cmd/hal/probing/network-printer/hald-probe-network-printer
+usr/src/cmd/hal/probing/printer/hald-probe-printer
+usr/src/cmd/hal/probing/storage/hald-probe-storage
+usr/src/cmd/hal/probing/volume/hald-probe-volume
+usr/src/cmd/hal/probing/xkb/hald-probe-xkb
+usr/src/cmd/hal/tools/hal-device
+usr/src/cmd/hal/tools/hal-fdi-validate
+usr/src/cmd/hal/tools/hal-find-by-capability
+usr/src/cmd/hal/tools/hal-find-by-property
+usr/src/cmd/hal/tools/hal-functions
+usr/src/cmd/hal/tools/hal-get-property
+usr/src/cmd/hal/tools/hal-is-caller-privileged
+usr/src/cmd/hal/tools/hal-set-property
+usr/src/cmd/hal/tools/hal-storage-cleanup-all-mountpoints
+usr/src/cmd/hal/tools/hal-storage-cleanup-mountpoint
+usr/src/cmd/hal/tools/hal-storage-closetray
+usr/src/cmd/hal/tools/hal-storage-eject
+usr/src/cmd/hal/tools/hal-storage-mount
+usr/src/cmd/hal/tools/hal-storage-unmount
+usr/src/cmd/hal/tools/hal-storage-zpool-export
+usr/src/cmd/hal/tools/hal-storage-zpool-import
+usr/src/cmd/hal/tools/hal-system-lcd-get-brightness
+usr/src/cmd/hal/tools/hal-system-lcd-set-brightness
+usr/src/cmd/hal/tools/hal-system-power-hibernate
+usr/src/cmd/hal/tools/hal-system-power-reboot
+usr/src/cmd/hal/tools/hal-system-power-shutdown
+usr/src/cmd/hal/tools/hal-system-power-suspend
+usr/src/cmd/hal/tools/lshal
+usr/src/cmd/hal/tools/sunos/hal-system-lcd-get-brightness-sunos
+usr/src/cmd/hal/tools/sunos/hal-system-lcd-set-brightness-sunos
+usr/src/cmd/hal/tools/sunos/hal-system-power-hibernate-sunos
+usr/src/cmd/hal/tools/sunos/hal-system-power-reboot-sunos
+usr/src/cmd/hal/tools/sunos/hal-system-power-shutdown-sunos
+usr/src/cmd/hal/tools/sunos/hal-system-power-suspend-sunos
+usr/src/cmd/halt/halt
+usr/src/cmd/head/head
+usr/src/cmd/hostid/hostid
+usr/src/cmd/hostname/hostname
+usr/src/cmd/hotplug/hotplug
+usr/src/cmd/hotplugd/hotplugd
+usr/src/cmd/hwdata/THIRDPARTYLICENSE.pciids
+usr/src/cmd/ibd_upgrade/ibd_delete_link
+usr/src/cmd/ibd_upgrade/ibd_upgrade
+usr/src/cmd/id/id
+usr/src/cmd/id/id.xpg4
+usr/src/cmd/idmap/idmap/idmap
+usr/src/cmd/idmap/idmapd/idmapd
+usr/src/cmd/infocmp/infocmp
+usr/src/cmd/init/init
+usr/src/cmd/initpkg/dfstab
+usr/src/cmd/initpkg/mountall
+usr/src/cmd/initpkg/rc0
+usr/src/cmd/initpkg/rc1
+usr/src/cmd/initpkg/rc2
+usr/src/cmd/initpkg/rc3
+usr/src/cmd/initpkg/rcS
+usr/src/cmd/initpkg/shutdown
+usr/src/cmd/initpkg/swapadd
+usr/src/cmd/initpkg/umountall
+usr/src/cmd/initpkg/vfstab
+usr/src/cmd/install.d/install.d
+usr/src/cmd/intrd/intrd
+usr/src/cmd/intrstat/amd64/intrstat
+usr/src/cmd/intrstat/i386/intrstat
+usr/src/cmd/ipcrm/ipcrm
+usr/src/cmd/ipcs/ipcs
+usr/src/cmd/ipf/examples/mkfilters
+usr/src/cmd/ipf/svc/svc.ipfd
+usr/src/cmd/ipf/tools/amd64/ipf
+usr/src/cmd/ipf/tools/amd64/ipf.tab.c
+usr/src/cmd/ipf/tools/amd64/ipf.tab.h
+usr/src/cmd/ipf/tools/amd64/ipfs
+usr/src/cmd/ipf/tools/amd64/ipfstat
+usr/src/cmd/ipf/tools/amd64/ipftest
+usr/src/cmd/ipf/tools/amd64/ipmon
+usr/src/cmd/ipf/tools/amd64/ipmon.tab.c
+usr/src/cmd/ipf/tools/amd64/ipmon.tab.h
+usr/src/cmd/ipf/tools/amd64/ipnat
+usr/src/cmd/ipf/tools/amd64/ipnat.tab.c
+usr/src/cmd/ipf/tools/amd64/ipnat.tab.h
+usr/src/cmd/ipf/tools/amd64/ippool
+usr/src/cmd/ipf/tools/amd64/ippool.tab.c
+usr/src/cmd/ipf/tools/amd64/ippool.tab.h
+usr/src/cmd/ipf/tools/i386/ipf
+usr/src/cmd/ipf/tools/i386/ipf.tab.c
+usr/src/cmd/ipf/tools/i386/ipf.tab.h
+usr/src/cmd/ipf/tools/i386/ipfs
+usr/src/cmd/ipf/tools/i386/ipfstat
+usr/src/cmd/ipf/tools/i386/ipftest
+usr/src/cmd/ipf/tools/i386/ipmon
+usr/src/cmd/ipf/tools/i386/ipmon.tab.c
+usr/src/cmd/ipf/tools/i386/ipmon.tab.h
+usr/src/cmd/ipf/tools/i386/ipnat
+usr/src/cmd/ipf/tools/i386/ipnat.tab.c
+usr/src/cmd/ipf/tools/i386/ipnat.tab.h
+usr/src/cmd/ipf/tools/i386/ippool
+usr/src/cmd/ipf/tools/i386/ippool.tab.c
+usr/src/cmd/ipf/tools/i386/ippool.tab.h
+usr/src/cmd/ipf/tools/ipf_l.c
+usr/src/cmd/ipf/tools/ipf_l.h
+usr/src/cmd/ipf/tools/ipf_y.c
+usr/src/cmd/ipf/tools/ipf_y.h
+usr/src/cmd/ipf/tools/ipmon_l.c
+usr/src/cmd/ipf/tools/ipmon_l.h
+usr/src/cmd/ipf/tools/ipmon_y.c
+usr/src/cmd/ipf/tools/ipmon_y.h
+usr/src/cmd/ipf/tools/ipnat_l.c
+usr/src/cmd/ipf/tools/ipnat_l.h
+usr/src/cmd/ipf/tools/ipnat_y.c
+usr/src/cmd/ipf/tools/ipnat_y.h
+usr/src/cmd/ipf/tools/ippool_l.c
+usr/src/cmd/ipf/tools/ippool_l.h
+usr/src/cmd/ipf/tools/ippool_y.c
+usr/src/cmd/ipf/tools/ippool_y.h
+usr/src/cmd/isaexec/isaexec
+usr/src/cmd/isainfo/isainfo
+usr/src/cmd/isalist/isalist
+usr/src/cmd/isalist/optisa
+usr/src/cmd/iscsiadm/iscsiadm
+usr/src/cmd/iscsid/iscsid
+usr/src/cmd/iscsitsvc/iscsi-target
+usr/src/cmd/isns/isnsadm/isnsadm
+usr/src/cmd/isns/isnsd/isns
+usr/src/cmd/isns/isnsd/isns_provider.h
+usr/src/cmd/itadm/itadm
+usr/src/cmd/itutools/itu
+usr/src/cmd/itutools/mkbootmedia
+usr/src/cmd/itutools/pkg2du
+usr/src/cmd/itutools/updatemedia
+usr/src/cmd/kbd/kbd
+usr/src/cmd/keyserv/chkey
+usr/src/cmd/keyserv/domainname
+usr/src/cmd/keyserv/keylogin
+usr/src/cmd/keyserv/keylogout
+usr/src/cmd/keyserv/keyserv
+usr/src/cmd/keyserv/newkey
+usr/src/cmd/killall/killall
+usr/src/cmd/krb5/kadmin/cli/k5srvutil
+usr/src/cmd/krb5/kadmin/cli/kadmin
+usr/src/cmd/krb5/kadmin/cli/kadmin.local
+usr/src/cmd/krb5/kadmin/dbutil/iprop.h
+usr/src/cmd/krb5/kadmin/dbutil/kdb5_util
+usr/src/cmd/krb5/kadmin/kclient/kclient
+usr/src/cmd/krb5/kadmin/kclient/kconf
+usr/src/cmd/krb5/kadmin/kclient/kdyndns
+usr/src/cmd/krb5/kadmin/kclient/ksetpw
+usr/src/cmd/krb5/kadmin/kclient/ksmb
+usr/src/cmd/krb5/kadmin/kdcmgr/kdcmgr
+usr/src/cmd/krb5/kadmin/kdcmgr/klookup
+usr/src/cmd/krb5/kadmin/kpasswd/kpasswd
+usr/src/cmd/krb5/kadmin/ktutil/ktutil
+usr/src/cmd/krb5/kadmin/server/iprop.h
+usr/src/cmd/krb5/kadmin/server/iprop_xdr.c
+usr/src/cmd/krb5/kadmin/server/kadmind
+usr/src/cmd/krb5/kdestroy/kdestroy
+usr/src/cmd/krb5/kinit/kinit
+usr/src/cmd/krb5/klist/klist
+usr/src/cmd/krb5/kproplog/iprop.h
+usr/src/cmd/krb5/kproplog/iprop_xdr.c
+usr/src/cmd/krb5/kproplog/kproplog
+usr/src/cmd/krb5/krb5-config/krb5-config
+usr/src/cmd/krb5/krb5kdc/krb5kdc
+usr/src/cmd/krb5/kwarn/ktkt_warnd
+usr/src/cmd/krb5/kwarn/kwarnd.h
+usr/src/cmd/krb5/kwarn/kwarnd_svc.c
+usr/src/cmd/krb5/kwarn/kwarnd_xdr.c
+usr/src/cmd/krb5/ldap_util/kdb5_ldap_util
+usr/src/cmd/krb5/slave/iprop.h
+usr/src/cmd/krb5/slave/iprop_xdr.c
+usr/src/cmd/krb5/slave/kprop
+usr/src/cmd/krb5/slave/kprop_script
+usr/src/cmd/krb5/slave/kpropd
+usr/src/cmd/ksh/amd64/ksh
+usr/src/cmd/ksh/amd64/ksh93
+usr/src/cmd/ksh/builtins/alias
+usr/src/cmd/ksh/i386/ksh
+usr/src/cmd/ksh/i386/ksh93
+usr/src/cmd/kstat/kstat
+usr/src/cmd/kvmstat/kvmstat
+usr/src/cmd/last/last
+usr/src/cmd/last/wtmpx
+usr/src/cmd/lastcomm/lastcomm
+usr/src/cmd/ldap/i386/idsconfig
+usr/src/cmd/ldap/i386/ldapaddent
+usr/src/cmd/ldap/i386/ldapclient
+usr/src/cmd/ldap/i386/ldapdelete
+usr/src/cmd/ldap/i386/ldaplist
+usr/src/cmd/ldap/i386/ldapmodify
+usr/src/cmd/ldap/i386/ldapmodrdn
+usr/src/cmd/ldap/i386/ldapsearch
+usr/src/cmd/ldapcachemgr/ldap_cachemgr
+usr/src/cmd/lgrpinfo/lgrpinfo
+usr/src/cmd/line/line
+usr/src/cmd/link/link
+usr/src/cmd/link/link.xpg4
+usr/src/cmd/listen/listen
+usr/src/cmd/listen/nlps_server
+usr/src/cmd/lms/lms
+usr/src/cmd/loadkeys/dumpkeys
+usr/src/cmd/loadkeys/loadkeys
+usr/src/cmd/loadkeys/loadkeys.c
+usr/src/cmd/locale/amd64/locale
+usr/src/cmd/locale/i386/locale
+usr/src/cmd/localedef/8859-1.cm
+usr/src/cmd/localedef/8859-11.cm
+usr/src/cmd/localedef/8859-13.cm
+usr/src/cmd/localedef/8859-15.cm
+usr/src/cmd/localedef/8859-2.cm
+usr/src/cmd/localedef/8859-5.cm
+usr/src/cmd/localedef/8859-6.cm
+usr/src/cmd/localedef/8859-7.cm
+usr/src/cmd/localedef/8859-9.cm
+usr/src/cmd/localedef/KOI8-R.cm
+usr/src/cmd/localedef/UTF-8.cm
+usr/src/cmd/localedef/locale/
+usr/src/cmd/localedef/localedef
+usr/src/cmd/localedef/parser.tab.c
+usr/src/cmd/localedef/parser.tab.h
+usr/src/cmd/locator/locator
+usr/src/cmd/lockstat/amd64/lockstat
+usr/src/cmd/lockstat/i386/lockstat
+usr/src/cmd/lofiadm/lofiadm
+usr/src/cmd/logadm/logadm
+usr/src/cmd/logger/logger
+usr/src/cmd/login/login
+usr/src/cmd/login/logindevperm
+usr/src/cmd/logins/logins
+usr/src/cmd/look/look
+usr/src/cmd/ls/amd64/ls
+usr/src/cmd/ls/amd64/ls.xpg4
+usr/src/cmd/ls/amd64/ls.xpg6
+usr/src/cmd/ls/i386/ls
+usr/src/cmd/ls/i386/ls.xpg4
+usr/src/cmd/ls/i386/ls.xpg6
+usr/src/cmd/ls/ls.dc
+usr/src/cmd/luxadm/luxadm
+usr/src/cmd/mach/mach
+usr/src/cmd/machid/machid
+usr/src/cmd/mail/mail
+usr/src/cmd/mailx/mailx
+usr/src/cmd/mailx/mailx.help
+usr/src/cmd/mailx/mailx.help.~
+usr/src/cmd/makekey/makekey
+usr/src/cmd/man/src/apropos
+usr/src/cmd/man/src/catman
+usr/src/cmd/man/src/getNAME
+usr/src/cmd/man/src/makewhatis
+usr/src/cmd/man/src/man
+usr/src/cmd/man/src/util/instant
+usr/src/cmd/man/src/util/instant.src/THIRDPARTYLICENSE
+usr/src/cmd/man/src/util/instant.src/instant
+usr/src/cmd/man/src/util/nsgmls
+usr/src/cmd/man/src/util/nsgmls.src/lib/Makefile.dep
+usr/src/cmd/man/src/util/nsgmls.src/lib/app_inst.cxx
+usr/src/cmd/man/src/util/nsgmls.src/lib/arc_inst.cxx
+usr/src/cmd/man/src/util/nsgmls.src/lib/entmgr_inst.cxx
+usr/src/cmd/man/src/util/nsgmls.src/lib/parser_inst.cxx
+usr/src/cmd/man/src/util/nsgmls.src/lib/xentmgr_inst.cxx
+usr/src/cmd/man/src/util/nsgmls.src/nsgmls/Makefile.dep
+usr/src/cmd/man/src/util/nsgmls.src/nsgmls/nsgmls
+usr/src/cmd/man/src/util/nsgmls.src/nsgmls/nsgmls_inst.cxx
+usr/src/cmd/man/src/util/sgml2roff
+usr/src/cmd/man/src/util/solbookv2/THIRDPARTYLICENSE
+usr/src/cmd/man/src/whatis
+usr/src/cmd/mdb/i86pc/modules/apix/amd64/kmod/
+usr/src/cmd/mdb/i86pc/modules/apix/ia32/kmod/
+usr/src/cmd/mdb/i86pc/modules/pcplusmp/amd64/kmod/
+usr/src/cmd/mdb/i86pc/modules/pcplusmp/ia32/kmod/
+usr/src/cmd/mdb/i86pc/modules/unix/amd64/kmod/
+usr/src/cmd/mdb/i86pc/modules/unix/ia32/kmod/
+usr/src/cmd/mdb/i86pc/modules/uppc/amd64/kmod/
+usr/src/cmd/mdb/i86pc/modules/uppc/ia32/kmod/
+usr/src/cmd/mdb/i86xpv/modules/unix/amd64/kmod/
+usr/src/cmd/mdb/i86xpv/modules/unix/ia32/kmod/
+usr/src/cmd/mdb/i86xpv/modules/xpv_psm/amd64/kmod/
+usr/src/cmd/mdb/i86xpv/modules/xpv_psm/ia32/kmod/
+usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/amd64/kmod/
+usr/src/cmd/mdb/i86xpv/modules/xpv_uppc/ia32/kmod/
+usr/src/cmd/mdb/intel/amd64/arp/kmod/
+usr/src/cmd/mdb/intel/amd64/cpc/kmod/
+usr/src/cmd/mdb/intel/amd64/crypto/kmod/
+usr/src/cmd/mdb/intel/amd64/dof/dof_names.c
+usr/src/cmd/mdb/intel/amd64/dtrace/dof_names.c
+usr/src/cmd/mdb/intel/amd64/emlxs/kmod/
+usr/src/cmd/mdb/intel/amd64/fcip/kmod/
+usr/src/cmd/mdb/intel/amd64/fcp/kmod/
+usr/src/cmd/mdb/intel/amd64/fctl/kmod/
+usr/src/cmd/mdb/intel/amd64/genunix/kmod/
+usr/src/cmd/mdb/intel/amd64/hook/kmod/
+usr/src/cmd/mdb/intel/amd64/idm/kmod/
+usr/src/cmd/mdb/intel/amd64/ii/kmod/
+usr/src/cmd/mdb/intel/amd64/ip/kmod/
+usr/src/cmd/mdb/intel/amd64/ipc/kmod/
+usr/src/cmd/mdb/intel/amd64/ipp/kmod/
+usr/src/cmd/mdb/intel/amd64/kmdb/kmdb_context_off.h
+usr/src/cmd/mdb/intel/amd64/kmdb/kmdb_modlinktest.c
+usr/src/cmd/mdb/intel/amd64/kmdb/kmdb_terminfo.c
+usr/src/cmd/mdb/intel/amd64/kmdb/kmdbmod
+usr/src/cmd/mdb/intel/amd64/kmdb/kmdbmod.core
+usr/src/cmd/mdb/intel/amd64/kmdb/mapfile
+usr/src/cmd/mdb/intel/amd64/kmdb/mapfile.i
+usr/src/cmd/mdb/intel/amd64/kmdb/mdb_grammar.c
+usr/src/cmd/mdb/intel/amd64/kmdb/mdb_grammar.h
+usr/src/cmd/mdb/intel/amd64/kmdb/mdb_lex.c
+usr/src/cmd/mdb/intel/amd64/kmdb/y.output
+usr/src/cmd/mdb/intel/amd64/krtld/kmod/
+usr/src/cmd/mdb/intel/amd64/lofs/kmod/
+usr/src/cmd/mdb/intel/amd64/logindmux/kmod/
+usr/src/cmd/mdb/intel/amd64/mac/kmod/
+usr/src/cmd/mdb/intel/amd64/md/kmod/
+usr/src/cmd/mdb/intel/amd64/mdb/mdb
+usr/src/cmd/mdb/intel/amd64/mdb/mdb_grammar.c
+usr/src/cmd/mdb/intel/amd64/mdb/mdb_grammar.h
+usr/src/cmd/mdb/intel/amd64/mdb/mdb_lex.c
+usr/src/cmd/mdb/intel/amd64/mdb/y.output
+usr/src/cmd/mdb/intel/amd64/mdb_ds/kmod/
+usr/src/cmd/mdb/intel/amd64/mdb_ks/kmod/
+usr/src/cmd/mdb/intel/amd64/mpt_sas/kmod/
+usr/src/cmd/mdb/intel/amd64/mr_sas/kmod/
+usr/src/cmd/mdb/intel/amd64/nca/kmod/
+usr/src/cmd/mdb/intel/amd64/neti/kmod/
+usr/src/cmd/mdb/intel/amd64/nsctl/kmod/
+usr/src/cmd/mdb/intel/amd64/nsmb/kmod/
+usr/src/cmd/mdb/intel/amd64/pmcs/kmod/
+usr/src/cmd/mdb/intel/amd64/ptm/kmod/
+usr/src/cmd/mdb/intel/amd64/qlc/kmod/
+usr/src/cmd/mdb/intel/amd64/random/kmod/
+usr/src/cmd/mdb/intel/amd64/rdc/kmod/
+usr/src/cmd/mdb/intel/amd64/s1394/kmod/
+usr/src/cmd/mdb/intel/amd64/scsi_vhci/kmod/
+usr/src/cmd/mdb/intel/amd64/sctp/kmod/
+usr/src/cmd/mdb/intel/amd64/sd/kmod/
+usr/src/cmd/mdb/intel/amd64/sdbc/kmod/
+usr/src/cmd/mdb/intel/amd64/smbfs/kmod/
+usr/src/cmd/mdb/intel/amd64/smbsrv/kmod/
+usr/src/cmd/mdb/intel/amd64/sockfs/kmod/
+usr/src/cmd/mdb/intel/amd64/specfs/kmod/
+usr/src/cmd/mdb/intel/amd64/sppp/kmod/
+usr/src/cmd/mdb/intel/amd64/srpt/kmod/
+usr/src/cmd/mdb/intel/amd64/stmf/kmod/
+usr/src/cmd/mdb/intel/amd64/stmf_sbd/kmod/
+usr/src/cmd/mdb/intel/amd64/sv/kmod/
+usr/src/cmd/mdb/intel/amd64/ufs/kmod/
+usr/src/cmd/mdb/intel/amd64/uhci/kmod/
+usr/src/cmd/mdb/intel/amd64/usba/kmod/
+usr/src/cmd/mdb/intel/amd64/zfs/kmod/
+usr/src/cmd/mdb/intel/ia32/arp/kmod/
+usr/src/cmd/mdb/intel/ia32/cpc/kmod/
+usr/src/cmd/mdb/intel/ia32/crypto/kmod/
+usr/src/cmd/mdb/intel/ia32/dof/dof_names.c
+usr/src/cmd/mdb/intel/ia32/dtrace/dof_names.c
+usr/src/cmd/mdb/intel/ia32/emlxs/kmod/
+usr/src/cmd/mdb/intel/ia32/fcip/kmod/
+usr/src/cmd/mdb/intel/ia32/fcp/kmod/
+usr/src/cmd/mdb/intel/ia32/fctl/kmod/
+usr/src/cmd/mdb/intel/ia32/genunix/kmod/
+usr/src/cmd/mdb/intel/ia32/hook/kmod/
+usr/src/cmd/mdb/intel/ia32/idm/kmod/
+usr/src/cmd/mdb/intel/ia32/ii/kmod/
+usr/src/cmd/mdb/intel/ia32/ip/kmod/
+usr/src/cmd/mdb/intel/ia32/ipc/kmod/
+usr/src/cmd/mdb/intel/ia32/ipp/kmod/
+usr/src/cmd/mdb/intel/ia32/kmdb/kmdb_context_off.h
+usr/src/cmd/mdb/intel/ia32/kmdb/kmdb_modlinktest.c
+usr/src/cmd/mdb/intel/ia32/kmdb/kmdb_terminfo.c
+usr/src/cmd/mdb/intel/ia32/kmdb/kmdbmod
+usr/src/cmd/mdb/intel/ia32/kmdb/kmdbmod.core
+usr/src/cmd/mdb/intel/ia32/kmdb/mapfile
+usr/src/cmd/mdb/intel/ia32/kmdb/mapfile.i
+usr/src/cmd/mdb/intel/ia32/kmdb/mdb_grammar.c
+usr/src/cmd/mdb/intel/ia32/kmdb/mdb_grammar.h
+usr/src/cmd/mdb/intel/ia32/kmdb/mdb_lex.c
+usr/src/cmd/mdb/intel/ia32/kmdb/y.output
+usr/src/cmd/mdb/intel/ia32/krtld/kmod/
+usr/src/cmd/mdb/intel/ia32/lofs/kmod/
+usr/src/cmd/mdb/intel/ia32/logindmux/kmod/
+usr/src/cmd/mdb/intel/ia32/mac/kmod/
+usr/src/cmd/mdb/intel/ia32/md/kmod/
+usr/src/cmd/mdb/intel/ia32/mdb/mdb
+usr/src/cmd/mdb/intel/ia32/mdb/mdb_grammar.c
+usr/src/cmd/mdb/intel/ia32/mdb/mdb_grammar.h
+usr/src/cmd/mdb/intel/ia32/mdb/mdb_lex.c
+usr/src/cmd/mdb/intel/ia32/mdb/y.output
+usr/src/cmd/mdb/intel/ia32/mdb_ds/kmod/
+usr/src/cmd/mdb/intel/ia32/mdb_ks/kmod/
+usr/src/cmd/mdb/intel/ia32/mpt_sas/kmod/
+usr/src/cmd/mdb/intel/ia32/mr_sas/kmod/
+usr/src/cmd/mdb/intel/ia32/nca/kmod/
+usr/src/cmd/mdb/intel/ia32/neti/kmod/
+usr/src/cmd/mdb/intel/ia32/nsctl/kmod/
+usr/src/cmd/mdb/intel/ia32/nsmb/kmod/
+usr/src/cmd/mdb/intel/ia32/pmcs/kmod/
+usr/src/cmd/mdb/intel/ia32/ptm/kmod/
+usr/src/cmd/mdb/intel/ia32/qlc/kmod/
+usr/src/cmd/mdb/intel/ia32/random/kmod/
+usr/src/cmd/mdb/intel/ia32/rdc/kmod/
+usr/src/cmd/mdb/intel/ia32/s1394/kmod/
+usr/src/cmd/mdb/intel/ia32/scsi_vhci/kmod/
+usr/src/cmd/mdb/intel/ia32/sctp/kmod/
+usr/src/cmd/mdb/intel/ia32/sd/kmod/
+usr/src/cmd/mdb/intel/ia32/sdbc/kmod/
+usr/src/cmd/mdb/intel/ia32/smbfs/kmod/
+usr/src/cmd/mdb/intel/ia32/smbsrv/kmod/
+usr/src/cmd/mdb/intel/ia32/sockfs/kmod/
+usr/src/cmd/mdb/intel/ia32/specfs/kmod/
+usr/src/cmd/mdb/intel/ia32/sppp/kmod/
+usr/src/cmd/mdb/intel/ia32/srpt/kmod/
+usr/src/cmd/mdb/intel/ia32/stmf/kmod/
+usr/src/cmd/mdb/intel/ia32/stmf_sbd/kmod/
+usr/src/cmd/mdb/intel/ia32/sv/kmod/
+usr/src/cmd/mdb/intel/ia32/ufs/kmod/
+usr/src/cmd/mdb/intel/ia32/uhci/kmod/
+usr/src/cmd/mdb/intel/ia32/usba/kmod/
+usr/src/cmd/mdb/intel/ia32/zfs/kmod/
+usr/src/cmd/mdb/intel/modules/amd_opteron/amd64/kmod/
+usr/src/cmd/mdb/intel/modules/amd_opteron/ia32/kmod/
+usr/src/cmd/mdb/intel/modules/generic_cpu/amd64/kmod/
+usr/src/cmd/mdb/intel/modules/generic_cpu/ia32/kmod/
+usr/src/cmd/mdb/intel/modules/sata/amd64/kmod/
+usr/src/cmd/mdb/intel/modules/sata/ia32/kmod/
+usr/src/cmd/mdb/tools/scripts/hdr2map
+usr/src/cmd/mdb/tools/scripts/map2linktest
+usr/src/cmd/mdb/tools/scripts/mdb
+usr/src/cmd/mdb/tools/scripts/mkmodules
+usr/src/cmd/mdb/tools/scripts/tigen
+usr/src/cmd/mdb/tools/setdynflag/i386/setdynflag
+usr/src/cmd/mesg/mesg
+usr/src/cmd/mkdir/mkdir
+usr/src/cmd/mkfifo/mkfifo
+usr/src/cmd/mkfile/mkfile
+usr/src/cmd/mkmsgs/mkmsgs
+usr/src/cmd/mknod/mknod
+usr/src/cmd/mkpwdict/mkpwdict
+usr/src/cmd/mktemp/mktemp
+usr/src/cmd/modload/amd64/add_drv
+usr/src/cmd/modload/amd64/modinfo
+usr/src/cmd/modload/amd64/modload
+usr/src/cmd/modload/amd64/modunload
+usr/src/cmd/modload/amd64/rem_drv
+usr/src/cmd/modload/amd64/update_drv
+usr/src/cmd/modload/i386/add_drv
+usr/src/cmd/modload/i386/modinfo
+usr/src/cmd/modload/i386/modload
+usr/src/cmd/modload/i386/modunload
+usr/src/cmd/modload/i386/rem_drv
+usr/src/cmd/modload/i386/update_drv
+usr/src/cmd/more/more
+usr/src/cmd/mpathadm/mpathadm
+usr/src/cmd/msgfmt/gmsgfmt
+usr/src/cmd/msgfmt/gmsgfmt_rev
+usr/src/cmd/msgfmt/gnu_po.c
+usr/src/cmd/msgfmt/msgfmt
+usr/src/cmd/msgfmt/xgettext
+usr/src/cmd/msgfmt/y.tab.h
+usr/src/cmd/msgid/msgid
+usr/src/cmd/mt/mt
+usr/src/cmd/mv/cp
+usr/src/cmd/mv/ln
+usr/src/cmd/mv/mv
+usr/src/cmd/mv/mv.xpg4
+usr/src/cmd/mvdir/mvdir
+usr/src/cmd/ndmpadm/ndmpadm
+usr/src/cmd/ndmpd/ndmp/ndmp.h
+usr/src/cmd/ndmpd/ndmp/ndmp_xdr.c
+usr/src/cmd/ndmpd/ndmp/ndmp_xdr.h
+usr/src/cmd/ndmpd/ndmpd
+usr/src/cmd/ndmpstat/ndmpstat
+usr/src/cmd/netadm/_pmtab
+usr/src/cmd/netadm/_sactab
+usr/src/cmd/netadm/_sysconfig
+usr/src/cmd/netadm/etc/ttydefs.cleanup
+usr/src/cmd/netadm/iu.ap
+usr/src/cmd/netadm/log
+usr/src/cmd/netadm/ttydefs
+usr/src/cmd/newform/newform
+usr/src/cmd/newgrp/newgrp
+usr/src/cmd/news/news
+usr/src/cmd/newtask/amd64/newtask
+usr/src/cmd/newtask/i386/newtask
+usr/src/cmd/nice/nice
+usr/src/cmd/nice/nice.xpg4
+usr/src/cmd/nl/nl
+usr/src/cmd/nl/nl.xpg4
+usr/src/cmd/nlsadmin/nlsadmin
+usr/src/cmd/nohup/amd64/nohup
+usr/src/cmd/nohup/amd64/nohup.xpg4
+usr/src/cmd/nohup/i386/nohup
+usr/src/cmd/nohup/i386/nohup.xpg4
+usr/src/cmd/nsadmin/.bashrc
+usr/src/cmd/nsadmin/.login
+usr/src/cmd/nsadmin/.profile
+usr/src/cmd/nsadmin/profile
+usr/src/cmd/nscd/nscd
+usr/src/cmd/ntfsprogs/THIRDPARTYLICENSE
+usr/src/cmd/ntfsprogs/mkntfs
+usr/src/cmd/ntfsprogs/ntfscat
+usr/src/cmd/ntfsprogs/ntfsclone
+usr/src/cmd/ntfsprogs/ntfscluster
+usr/src/cmd/ntfsprogs/ntfscmp
+usr/src/cmd/ntfsprogs/ntfscp
+usr/src/cmd/ntfsprogs/ntfsfix
+usr/src/cmd/ntfsprogs/ntfsinfo
+usr/src/cmd/ntfsprogs/ntfslabel
+usr/src/cmd/ntfsprogs/ntfsls
+usr/src/cmd/ntfsprogs/ntfsresize
+usr/src/cmd/ntfsprogs/ntfsundelete
+usr/src/cmd/oamuser/group/groupadd
+usr/src/cmd/oamuser/group/groupdel
+usr/src/cmd/oamuser/group/groupmod
+usr/src/cmd/oamuser/lib/ugdates
+usr/src/cmd/oamuser/user/useradd
+usr/src/cmd/oamuser/user/userdel
+usr/src/cmd/oamuser/user/usermod
+usr/src/cmd/oawk/awk.g.c
+usr/src/cmd/oawk/awk.h
+usr/src/cmd/oawk/awk.lx.c
+usr/src/cmd/oawk/native/
+usr/src/cmd/oawk/oawk
+usr/src/cmd/oawk/proctab.c
+usr/src/cmd/oawk/temp
+usr/src/cmd/oawk/tmptoken.c
+usr/src/cmd/od/od
+usr/src/cmd/pack/pack
+usr/src/cmd/pagesize/pagesize
+usr/src/cmd/parted/THIRDPARTYLICENSE
+usr/src/cmd/parted/parted
+usr/src/cmd/passmgmt/datemsk
+usr/src/cmd/passmgmt/passmgmt
+usr/src/cmd/passwd/passwd
+usr/src/cmd/pathchk/pathchk
+usr/src/cmd/pbind/amd64/pbind
+usr/src/cmd/pbind/i386/pbind
+usr/src/cmd/pcidr/pcidr
+usr/src/cmd/pcitool/i386/pcitool
+usr/src/cmd/perl/5.12/
+usr/src/cmd/pfexec/pfexec
+usr/src/cmd/pfexecd/pfexecd
+usr/src/cmd/pg/pg
+usr/src/cmd/pginfo/pginfo
+usr/src/cmd/pgrep/pgrep
+usr/src/cmd/pgrep/pkill
+usr/src/cmd/pgstat/pgstat
+usr/src/cmd/picl/picld/picld
+usr/src/cmd/picl/plugins/lib/picld_pluginutil/i386/lint.out
+usr/src/cmd/picl/plugins/lib/picld_pluginutil/i386/llib-lpicld_pluginutil.ln
+usr/src/cmd/picl/prtpicl/prtpicl
+usr/src/cmd/platexec/platexec
+usr/src/cmd/plimit/amd64/plimit
+usr/src/cmd/plimit/i386/plimit
+usr/src/cmd/plockstat/amd64/plockstat
+usr/src/cmd/plockstat/i386/plockstat
+usr/src/cmd/policykit/polkit-is-privileged
+usr/src/cmd/pools/pooladm/pooladm
+usr/src/cmd/pools/poolbind/poolbind
+usr/src/cmd/pools/poolcfg/poolcfg
+usr/src/cmd/pools/poolcfg/poolcfg_grammar.c
+usr/src/cmd/pools/poolcfg/poolcfg_grammar.h
+usr/src/cmd/pools/poolcfg/poolcfg_lex.c
+usr/src/cmd/pools/poold/JPool.jar
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/AbstractObjective.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/AbstractStatistic.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/AggregateStatistic.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/ComponentMove.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/ConfigurationException.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/DRM.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/DecisionHistory$1.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/DecisionHistory$ComponentMoveDecision.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/DecisionHistory$Decision.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/DecisionHistory.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/DoubleStatistic.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Expression.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/IllegalOFValueException.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/KExpression.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/KVExpression.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/KVOpExpression.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/LGroupData.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/LocalityObjective.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/LogDRM.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/LongStatistic.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Monitor.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Move.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Objective.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/PSETData.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Poold$1.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Poold$logHelper.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Poold$utility.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Poold.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/PooldException.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/QuantityMove.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/ResourceMonitor.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/ResultTuple.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Solver.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/StaleMonitorException.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/Statistic.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/StatisticEvent.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/StatisticList.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/StatisticListener.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/StatisticOperations.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/SystemMonitor.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/SystemSolver$ScoreMove.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/SystemSolver.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/UnsignedInt64Statistic.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/UtilizationObjective.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/WeightedLoadObjective$Calculation.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/WeightedLoadObjective.class
+usr/src/cmd/pools/poold/com/sun/solaris/domain/pools/WorkloadDependentObjective.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/exception/SuccinctStackTraceFormatter.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/kstat/Kstat.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/kstat/KstatChainUpdateException.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/kstat/KstatCtl.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/kstat/KstatException.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/kstat/KstatReadException.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/kstat/KstatTypeNotSupportedException.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/locality/LocalityDomain.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/locality/LocalityGroup.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/logging/Facility.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/logging/Severity.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/logging/SyslogHandler.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/logging/SysloglikeFormatter$1.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/logging/SysloglikeFormatter.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Component.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Configuration.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Element.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/HRTime.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Pool.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/PoolInternal.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/PoolsException.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Property.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/PropertyWalk.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Resource.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/UnsignedInt64.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/pools/Value.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/timer/RecurringEventTimer.class
+usr/src/cmd/pools/poold/com/sun/solaris/service/timer/SimpleRecurringEventTimer.class
+usr/src/cmd/pools/poold/libjkstat/jkstat.h
+usr/src/cmd/pools/poold/libjlgrp/jlgrp.h
+usr/src/cmd/pools/poold/libjpool/jpool.h
+usr/src/cmd/pools/poold/libjsyslog/jsyslog.h
+usr/src/cmd/pools/poold/poold
+usr/src/cmd/pools/poolstat/poolstat
+usr/src/cmd/power/pmconfig
+usr/src/cmd/power/power.conf
+usr/src/cmd/power/powerd
+usr/src/cmd/power/sys-suspend
+usr/src/cmd/power/sysidpm
+usr/src/cmd/powertop/amd64/powertop
+usr/src/cmd/powertop/i386/powertop
+usr/src/cmd/ppgsz/amd64/ppgsz
+usr/src/cmd/ppgsz/i386/ppgsz
+usr/src/cmd/pr/pr
+usr/src/cmd/pr/pr.dc
+usr/src/cmd/pr/pr.xpg4
+usr/src/cmd/praudit/praudit
+usr/src/cmd/prctl/amd64/prctl
+usr/src/cmd/prctl/i386/prctl
+usr/src/cmd/printf/printf
+usr/src/cmd/priocntl/FSSpriocntl
+usr/src/cmd/priocntl/FXpriocntl
+usr/src/cmd/priocntl/IApriocntl
+usr/src/cmd/priocntl/RTpriocntl
+usr/src/cmd/priocntl/SDCpriocntl
+usr/src/cmd/priocntl/TSpriocntl
+usr/src/cmd/priocntl/priocntl
+usr/src/cmd/profiles/profiles
+usr/src/cmd/projadd/projadd
+usr/src/cmd/projadd/projdel
+usr/src/cmd/projadd/projmod
+usr/src/cmd/projects/projects
+usr/src/cmd/prstat/amd64/prstat
+usr/src/cmd/prstat/i386/prstat
+usr/src/cmd/prtconf/amd64/prtconf
+usr/src/cmd/prtconf/i386/prtconf
+usr/src/cmd/prtdiag/i386/prtdiag
+usr/src/cmd/prtvtoc/prtvtoc
+usr/src/cmd/ps/amd64/ps
+usr/src/cmd/ps/i386/ps
+usr/src/cmd/ps/ps.dc
+usr/src/cmd/psradm/psradm
+usr/src/cmd/psrinfo/psrinfo
+usr/src/cmd/psrset/amd64/psrset
+usr/src/cmd/psrset/i386/psrset
+usr/src/cmd/ptools/pargs/amd64/
+usr/src/cmd/ptools/pargs/i386/
+usr/src/cmd/ptools/pcred/amd64/
+usr/src/cmd/ptools/pcred/i386/
+usr/src/cmd/ptools/pfiles/amd64/
+usr/src/cmd/ptools/pfiles/i386/
+usr/src/cmd/ptools/pflags/amd64/
+usr/src/cmd/ptools/pflags/i386/
+usr/src/cmd/ptools/pldd/amd64/
+usr/src/cmd/ptools/pldd/i386/
+usr/src/cmd/ptools/plgrp/amd64/
+usr/src/cmd/ptools/plgrp/i386/
+usr/src/cmd/ptools/pmadvise/amd64/
+usr/src/cmd/ptools/pmadvise/i386/
+usr/src/cmd/ptools/pmap/amd64/
+usr/src/cmd/ptools/pmap/i386/
+usr/src/cmd/ptools/ppriv/amd64/
+usr/src/cmd/ptools/ppriv/i386/
+usr/src/cmd/ptools/preap/amd64/
+usr/src/cmd/ptools/preap/i386/
+usr/src/cmd/ptools/prun/amd64/
+usr/src/cmd/ptools/prun/i386/
+usr/src/cmd/ptools/psig/amd64/
+usr/src/cmd/ptools/psig/i386/
+usr/src/cmd/ptools/pstack/amd64/
+usr/src/cmd/ptools/pstack/i386/
+usr/src/cmd/ptools/pstop/amd64/
+usr/src/cmd/ptools/pstop/i386/
+usr/src/cmd/ptools/ptime/amd64/
+usr/src/cmd/ptools/ptime/i386/
+usr/src/cmd/ptools/ptree/amd64/
+usr/src/cmd/ptools/ptree/i386/
+usr/src/cmd/ptools/pwait/amd64/
+usr/src/cmd/ptools/pwait/i386/
+usr/src/cmd/ptools/pwdx/amd64/
+usr/src/cmd/ptools/pwdx/i386/
+usr/src/cmd/pwck/pwck
+usr/src/cmd/pwconv/pwconv
+usr/src/cmd/pwd/pwd
+usr/src/cmd/raidctl/raidctl
+usr/src/cmd/ramdiskadm/ramdiskadm
+usr/src/cmd/rcap/rcapadm/rcapadm
+usr/src/cmd/rcap/rcapd/amd64/rcapd
+usr/src/cmd/rcap/rcapd/i386/rcapd
+usr/src/cmd/rcap/rcapstat/rcapstat
+usr/src/cmd/rcm_daemon/i386/rcm_daemon
+usr/src/cmd/rctladm/rctladm
+usr/src/cmd/refer/addbib
+usr/src/cmd/refer/hunt
+usr/src/cmd/refer/indxbib
+usr/src/cmd/refer/inv
+usr/src/cmd/refer/lookbib
+usr/src/cmd/refer/mkey
+usr/src/cmd/refer/refer
+usr/src/cmd/refer/roffbib
+usr/src/cmd/refer/sortbib
+usr/src/cmd/regcmp/regcmp
+usr/src/cmd/renice/renice
+usr/src/cmd/rexd/on
+usr/src/cmd/rexd/rpc.rexd
+usr/src/cmd/rm/rm
+usr/src/cmd/rm/rm.xpg4
+usr/src/cmd/rmdir/rmdir
+usr/src/cmd/rmformat/rmformat
+usr/src/cmd/rmmount/rmmount
+usr/src/cmd/rmt/rmt
+usr/src/cmd/rmvolmgr/rmvolmgr
+usr/src/cmd/roles/roles
+usr/src/cmd/rpcbind/rpc-bind
+usr/src/cmd/rpcbind/rpcbind
+usr/src/cmd/rpcgen/rpcgen
+usr/src/cmd/rpcinfo/rpcinfo
+usr/src/cmd/rpcsvc/rpc.bootparamd/rpc.bootparamd
+usr/src/cmd/rpcsvc/rpc.rstatd
+usr/src/cmd/rpcsvc/rpc.rusersd
+usr/src/cmd/rpcsvc/rpc.rwalld
+usr/src/cmd/rpcsvc/rpc.sprayd
+usr/src/cmd/rpcsvc/rstat.h
+usr/src/cmd/rpcsvc/rstat.x
+usr/src/cmd/rpcsvc/rstat_svc.c
+usr/src/cmd/rpcsvc/rstat_v2.h
+usr/src/cmd/rpcsvc/rstat_v2_svc.c
+usr/src/cmd/rpcsvc/rstat_v2_xdr.c
+usr/src/cmd/rpcsvc/rup
+usr/src/cmd/rpcsvc/rusers
+usr/src/cmd/rpcsvc/rwall
+usr/src/cmd/rpcsvc/rwall.h
+usr/src/cmd/rpcsvc/rwall.x
+usr/src/cmd/rpcsvc/rwall_clnt.c
+usr/src/cmd/rpcsvc/rwall_svc.c
+usr/src/cmd/rpcsvc/spray
+usr/src/cmd/rpcsvc/spray.h
+usr/src/cmd/rpcsvc/spray.x
+usr/src/cmd/rpcsvc/spray_clnt.c
+usr/src/cmd/rpcsvc/spray_svc.c
+usr/src/cmd/rtc/rtc
+usr/src/cmd/runat/runat
+usr/src/cmd/sa/sa1
+usr/src/cmd/sa/sa2
+usr/src/cmd/sa/sadc
+usr/src/cmd/sa/sar
+usr/src/cmd/sa/timex
+usr/src/cmd/saf/pmadm
+usr/src/cmd/saf/sac
+usr/src/cmd/saf/sacadm
+usr/src/cmd/sasinfo/sasinfo
+usr/src/cmd/savecore/amd64/savecore
+usr/src/cmd/savecore/i386/savecore
+usr/src/cmd/sbdadm/sbdadm
+usr/src/cmd/script/script
+usr/src/cmd/scsi/sestopo/i386/sestopo
+usr/src/cmd/scsi/smp/i386/smp
+usr/src/cmd/sdiff/sdiff
+usr/src/cmd/sdpadm/sdpadm
+usr/src/cmd/sed/sed
+usr/src/cmd/sendmail/THIRDPARTYLICENSE
+usr/src/cmd/sendmail/aux/editmap
+usr/src/cmd/sendmail/aux/etrn
+usr/src/cmd/sendmail/aux/mail.local
+usr/src/cmd/sendmail/aux/mailcompat
+usr/src/cmd/sendmail/aux/mailq
+usr/src/cmd/sendmail/aux/mailstats
+usr/src/cmd/sendmail/aux/makemap
+usr/src/cmd/sendmail/aux/mconnect
+usr/src/cmd/sendmail/aux/praliases
+usr/src/cmd/sendmail/aux/smrsh
+usr/src/cmd/sendmail/aux/vacation
+usr/src/cmd/sendmail/cf/cf/sendmail.cf
+usr/src/cmd/sendmail/cf/cf/submit.cf
+usr/src/cmd/sendmail/cf/sendmail.cf
+usr/src/cmd/sendmail/cf/submit.cf
+usr/src/cmd/sendmail/libmilter/i386/lint.out
+usr/src/cmd/sendmail/libmilter/i386/llib-lmilter.ln
+usr/src/cmd/sendmail/src/sendmail
+usr/src/cmd/setfacl/setfacl
+usr/src/cmd/setmnt/setmnt
+usr/src/cmd/setpgrp/setpgrp
+usr/src/cmd/setuname/amd64/setuname
+usr/src/cmd/setuname/i386/setuname
+usr/src/cmd/sgs/0@0/.make.state.i386
+usr/src/cmd/sgs/ar/.make.state.i386
+usr/src/cmd/sgs/ar/amd64/.make.state.i386
+usr/src/cmd/sgs/ar/amd64/ar
+usr/src/cmd/sgs/ar/amd64/msg.c
+usr/src/cmd/sgs/ar/amd64/msg.h
+usr/src/cmd/sgs/ar/i386/.make.state.i386
+usr/src/cmd/sgs/ar/i386/ar
+usr/src/cmd/sgs/ar/i386/ar.xpg4
+usr/src/cmd/sgs/ar/i386/msg.c
+usr/src/cmd/sgs/ar/i386/msg.h
+usr/src/cmd/sgs/crle/.make.state.i386
+usr/src/cmd/sgs/crle/amd64/.make.state.i386
+usr/src/cmd/sgs/crle/amd64/crle
+usr/src/cmd/sgs/crle/amd64/msg.c
+usr/src/cmd/sgs/crle/amd64/msg.h
+usr/src/cmd/sgs/crle/i386/.make.state.i386
+usr/src/cmd/sgs/crle/i386/crle
+usr/src/cmd/sgs/crle/i386/msg.c
+usr/src/cmd/sgs/crle/i386/msg.h
+usr/src/cmd/sgs/dump/.make.state.i386
+usr/src/cmd/sgs/dump/amd64/.make.state.i386
+usr/src/cmd/sgs/dump/amd64/dump
+usr/src/cmd/sgs/dump/i386/.make.state.i386
+usr/src/cmd/sgs/dump/i386/dump
+usr/src/cmd/sgs/elfdump/.make.state.i386
+usr/src/cmd/sgs/elfdump/amd64/.make.state.i386
+usr/src/cmd/sgs/elfdump/amd64/elfdump
+usr/src/cmd/sgs/elfdump/amd64/gen_struct_layout
+usr/src/cmd/sgs/elfdump/amd64/msg.c
+usr/src/cmd/sgs/elfdump/amd64/msg.h
+usr/src/cmd/sgs/elfdump/i386/.make.state.i386
+usr/src/cmd/sgs/elfdump/i386/elfdump
+usr/src/cmd/sgs/elfdump/i386/gen_struct_layout
+usr/src/cmd/sgs/elfdump/i386/msg.c
+usr/src/cmd/sgs/elfdump/i386/msg.h
+usr/src/cmd/sgs/elfedit/.make.state.i386
+usr/src/cmd/sgs/elfedit/amd64/.make.state.i386
+usr/src/cmd/sgs/elfedit/amd64/elfedit
+usr/src/cmd/sgs/elfedit/amd64/msg.c
+usr/src/cmd/sgs/elfedit/amd64/msg.h
+usr/src/cmd/sgs/elfedit/i386/.make.state.i386
+usr/src/cmd/sgs/elfedit/i386/elfedit
+usr/src/cmd/sgs/elfedit/i386/msg.c
+usr/src/cmd/sgs/elfedit/i386/msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/.make.state.i386
+usr/src/cmd/sgs/elfedit/modules/amd64/cap_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/cap_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/dyn_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/dyn_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/ehdr_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/ehdr_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/phdr_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/phdr_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/shdr_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/shdr_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/str_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/str_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/sym_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/sym_msg.h
+usr/src/cmd/sgs/elfedit/modules/amd64/syminfo_msg.c
+usr/src/cmd/sgs/elfedit/modules/amd64/syminfo_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/.make.state.i386
+usr/src/cmd/sgs/elfedit/modules/i386/cap_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/cap_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/dyn_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/dyn_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/ehdr_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/ehdr_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/phdr_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/phdr_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/shdr_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/shdr_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/str_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/str_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/sym_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/sym_msg.h
+usr/src/cmd/sgs/elfedit/modules/i386/syminfo_msg.c
+usr/src/cmd/sgs/elfedit/modules/i386/syminfo_msg.h
+usr/src/cmd/sgs/elfwrap/.make.state.i386
+usr/src/cmd/sgs/elfwrap/amd64/.make.state.i386
+usr/src/cmd/sgs/elfwrap/amd64/elfwrap
+usr/src/cmd/sgs/elfwrap/amd64/msg.c
+usr/src/cmd/sgs/elfwrap/amd64/msg.h
+usr/src/cmd/sgs/elfwrap/i386/.make.state.i386
+usr/src/cmd/sgs/elfwrap/i386/elfwrap
+usr/src/cmd/sgs/elfwrap/i386/msg.c
+usr/src/cmd/sgs/elfwrap/i386/msg.h
+usr/src/cmd/sgs/error/i386/error
+usr/src/cmd/sgs/gprof/i386/.make.state.i386
+usr/src/cmd/sgs/gprof/i386/gprof
+usr/src/cmd/sgs/lari/.make.state.i386
+usr/src/cmd/sgs/lari/lari
+usr/src/cmd/sgs/ld/.make.state.i386
+usr/src/cmd/sgs/ld/amd64/.make.state.i386
+usr/src/cmd/sgs/ld/amd64/ld
+usr/src/cmd/sgs/ld/amd64/msg.c
+usr/src/cmd/sgs/ld/amd64/msg.h
+usr/src/cmd/sgs/ld/i386/.make.state.i386
+usr/src/cmd/sgs/ld/i386/ld
+usr/src/cmd/sgs/ld/i386/msg.c
+usr/src/cmd/sgs/ld/i386/msg.h
+usr/src/cmd/sgs/ldd/.make.state.i386
+usr/src/cmd/sgs/ldd/amd64/.make.state.i386
+usr/src/cmd/sgs/ldd/amd64/ldd
+usr/src/cmd/sgs/ldd/amd64/msg.c
+usr/src/cmd/sgs/ldd/amd64/msg.h
+usr/src/cmd/sgs/ldd/i386/.make.state.i386
+usr/src/cmd/sgs/ldd/i386/ldd
+usr/src/cmd/sgs/ldd/i386/msg.c
+usr/src/cmd/sgs/ldd/i386/msg.h
+usr/src/cmd/sgs/lddstub/.make.state.i386
+usr/src/cmd/sgs/lddstub/amd64/.make.state.i386
+usr/src/cmd/sgs/lddstub/amd64/lddstub
+usr/src/cmd/sgs/lddstub/i386/.make.state.i386
+usr/src/cmd/sgs/lddstub/i386/lddstub
+usr/src/cmd/sgs/ldprof/.make.state.i386
+usr/src/cmd/sgs/ldprof/amd64/.make.state.i386
+usr/src/cmd/sgs/ldprof/amd64/msg.c
+usr/src/cmd/sgs/ldprof/amd64/msg.h
+usr/src/cmd/sgs/ldprof/i386/.make.state.i386
+usr/src/cmd/sgs/ldprof/i386/msg.c
+usr/src/cmd/sgs/ldprof/i386/msg.h
+usr/src/cmd/sgs/lex/amd64/llib-ll.ln
+usr/src/cmd/sgs/lex/common/parser.c
+usr/src/cmd/sgs/lex/i386/lex
+usr/src/cmd/sgs/lex/i386/llib-ll.ln
+usr/src/cmd/sgs/libconv/.make.state.i386
+usr/src/cmd/sgs/libconv/amd64/.make.state.i386
+usr/src/cmd/sgs/libconv/amd64/arch_msg.c
+usr/src/cmd/sgs/libconv/amd64/arch_msg.h
+usr/src/cmd/sgs/libconv/amd64/audit_msg.c
+usr/src/cmd/sgs/libconv/amd64/audit_msg.h
+usr/src/cmd/sgs/libconv/amd64/bld_vernote
+usr/src/cmd/sgs/libconv/amd64/c_literal_msg.c
+usr/src/cmd/sgs/libconv/amd64/c_literal_msg.h
+usr/src/cmd/sgs/libconv/amd64/cap_msg.c
+usr/src/cmd/sgs/libconv/amd64/cap_msg.h
+usr/src/cmd/sgs/libconv/amd64/config_msg.c
+usr/src/cmd/sgs/libconv/amd64/config_msg.h
+usr/src/cmd/sgs/libconv/amd64/corenote_msg.c
+usr/src/cmd/sgs/libconv/amd64/corenote_msg.h
+usr/src/cmd/sgs/libconv/amd64/data_msg.c
+usr/src/cmd/sgs/libconv/amd64/data_msg.h
+usr/src/cmd/sgs/libconv/amd64/deftag_msg.c
+usr/src/cmd/sgs/libconv/amd64/deftag_msg.h
+usr/src/cmd/sgs/libconv/amd64/demangle_msg.c
+usr/src/cmd/sgs/libconv/amd64/demangle_msg.h
+usr/src/cmd/sgs/libconv/amd64/dl_msg.c
+usr/src/cmd/sgs/libconv/amd64/dl_msg.h
+usr/src/cmd/sgs/libconv/amd64/dwarf_ehe_msg.c
+usr/src/cmd/sgs/libconv/amd64/dwarf_ehe_msg.h
+usr/src/cmd/sgs/libconv/amd64/dwarf_msg.c
+usr/src/cmd/sgs/libconv/amd64/dwarf_msg.h
+usr/src/cmd/sgs/libconv/amd64/dynamic_msg.c
+usr/src/cmd/sgs/libconv/amd64/dynamic_msg.h
+usr/src/cmd/sgs/libconv/amd64/elf_msg.c
+usr/src/cmd/sgs/libconv/amd64/elf_msg.h
+usr/src/cmd/sgs/libconv/amd64/entry_msg.c
+usr/src/cmd/sgs/libconv/amd64/entry_msg.h
+usr/src/cmd/sgs/libconv/amd64/globals_msg.c
+usr/src/cmd/sgs/libconv/amd64/globals_msg.h
+usr/src/cmd/sgs/libconv/amd64/group_msg.c
+usr/src/cmd/sgs/libconv/amd64/group_msg.h
+usr/src/cmd/sgs/libconv/amd64/lddstub_msg.c
+usr/src/cmd/sgs/libconv/amd64/lddstub_msg.h
+usr/src/cmd/sgs/libconv/amd64/map_msg.c
+usr/src/cmd/sgs/libconv/amd64/map_msg.h
+usr/src/cmd/sgs/libconv/amd64/phdr_msg.c
+usr/src/cmd/sgs/libconv/amd64/phdr_msg.h
+usr/src/cmd/sgs/libconv/amd64/relocate_amd64_msg.c
+usr/src/cmd/sgs/libconv/amd64/relocate_amd64_msg.h
+usr/src/cmd/sgs/libconv/amd64/relocate_i386_msg.c
+usr/src/cmd/sgs/libconv/amd64/relocate_i386_msg.h
+usr/src/cmd/sgs/libconv/amd64/relocate_sparc_msg.c
+usr/src/cmd/sgs/libconv/amd64/relocate_sparc_msg.h
+usr/src/cmd/sgs/libconv/amd64/report_bufsize.h
+usr/src/cmd/sgs/libconv/amd64/sections_msg.c
+usr/src/cmd/sgs/libconv/amd64/sections_msg.h
+usr/src/cmd/sgs/libconv/amd64/segments_msg.c
+usr/src/cmd/sgs/libconv/amd64/segments_msg.h
+usr/src/cmd/sgs/libconv/amd64/symbols_msg.c
+usr/src/cmd/sgs/libconv/amd64/symbols_msg.h
+usr/src/cmd/sgs/libconv/amd64/symbols_sparc_msg.c
+usr/src/cmd/sgs/libconv/amd64/symbols_sparc_msg.h
+usr/src/cmd/sgs/libconv/amd64/syminfo_msg.c
+usr/src/cmd/sgs/libconv/amd64/syminfo_msg.h
+usr/src/cmd/sgs/libconv/amd64/time_msg.c
+usr/src/cmd/sgs/libconv/amd64/time_msg.h
+usr/src/cmd/sgs/libconv/amd64/vernote.s
+usr/src/cmd/sgs/libconv/amd64/version_msg.c
+usr/src/cmd/sgs/libconv/amd64/version_msg.h
+usr/src/cmd/sgs/libconv/i386/.make.state.i386
+usr/src/cmd/sgs/libconv/i386/arch_msg.c
+usr/src/cmd/sgs/libconv/i386/arch_msg.h
+usr/src/cmd/sgs/libconv/i386/audit_msg.c
+usr/src/cmd/sgs/libconv/i386/audit_msg.h
+usr/src/cmd/sgs/libconv/i386/bld_vernote
+usr/src/cmd/sgs/libconv/i386/c_literal_msg.c
+usr/src/cmd/sgs/libconv/i386/c_literal_msg.h
+usr/src/cmd/sgs/libconv/i386/cap_msg.c
+usr/src/cmd/sgs/libconv/i386/cap_msg.h
+usr/src/cmd/sgs/libconv/i386/config_msg.c
+usr/src/cmd/sgs/libconv/i386/config_msg.h
+usr/src/cmd/sgs/libconv/i386/corenote_msg.c
+usr/src/cmd/sgs/libconv/i386/corenote_msg.h
+usr/src/cmd/sgs/libconv/i386/data_msg.c
+usr/src/cmd/sgs/libconv/i386/data_msg.h
+usr/src/cmd/sgs/libconv/i386/deftag_msg.c
+usr/src/cmd/sgs/libconv/i386/deftag_msg.h
+usr/src/cmd/sgs/libconv/i386/demangle_msg.c
+usr/src/cmd/sgs/libconv/i386/demangle_msg.h
+usr/src/cmd/sgs/libconv/i386/dl_msg.c
+usr/src/cmd/sgs/libconv/i386/dl_msg.h
+usr/src/cmd/sgs/libconv/i386/dwarf_ehe_msg.c
+usr/src/cmd/sgs/libconv/i386/dwarf_ehe_msg.h
+usr/src/cmd/sgs/libconv/i386/dwarf_msg.c
+usr/src/cmd/sgs/libconv/i386/dwarf_msg.h
+usr/src/cmd/sgs/libconv/i386/dynamic_msg.c
+usr/src/cmd/sgs/libconv/i386/dynamic_msg.h
+usr/src/cmd/sgs/libconv/i386/elf_msg.c
+usr/src/cmd/sgs/libconv/i386/elf_msg.h
+usr/src/cmd/sgs/libconv/i386/entry_msg.c
+usr/src/cmd/sgs/libconv/i386/entry_msg.h
+usr/src/cmd/sgs/libconv/i386/globals_msg.c
+usr/src/cmd/sgs/libconv/i386/globals_msg.h
+usr/src/cmd/sgs/libconv/i386/group_msg.c
+usr/src/cmd/sgs/libconv/i386/group_msg.h
+usr/src/cmd/sgs/libconv/i386/lddstub_msg.c
+usr/src/cmd/sgs/libconv/i386/lddstub_msg.h
+usr/src/cmd/sgs/libconv/i386/map_msg.c
+usr/src/cmd/sgs/libconv/i386/map_msg.h
+usr/src/cmd/sgs/libconv/i386/phdr_msg.c
+usr/src/cmd/sgs/libconv/i386/phdr_msg.h
+usr/src/cmd/sgs/libconv/i386/relocate_amd64_msg.c
+usr/src/cmd/sgs/libconv/i386/relocate_amd64_msg.h
+usr/src/cmd/sgs/libconv/i386/relocate_i386_msg.c
+usr/src/cmd/sgs/libconv/i386/relocate_i386_msg.h
+usr/src/cmd/sgs/libconv/i386/relocate_sparc_msg.c
+usr/src/cmd/sgs/libconv/i386/relocate_sparc_msg.h
+usr/src/cmd/sgs/libconv/i386/report_bufsize.h
+usr/src/cmd/sgs/libconv/i386/sections_msg.c
+usr/src/cmd/sgs/libconv/i386/sections_msg.h
+usr/src/cmd/sgs/libconv/i386/segments_msg.c
+usr/src/cmd/sgs/libconv/i386/segments_msg.h
+usr/src/cmd/sgs/libconv/i386/symbols_msg.c
+usr/src/cmd/sgs/libconv/i386/symbols_msg.h
+usr/src/cmd/sgs/libconv/i386/symbols_sparc_msg.c
+usr/src/cmd/sgs/libconv/i386/symbols_sparc_msg.h
+usr/src/cmd/sgs/libconv/i386/syminfo_msg.c
+usr/src/cmd/sgs/libconv/i386/syminfo_msg.h
+usr/src/cmd/sgs/libconv/i386/time_msg.c
+usr/src/cmd/sgs/libconv/i386/time_msg.h
+usr/src/cmd/sgs/libconv/i386/vernote.s
+usr/src/cmd/sgs/libconv/i386/version_msg.c
+usr/src/cmd/sgs/libconv/i386/version_msg.h
+usr/src/cmd/sgs/libcrle/.make.state.i386
+usr/src/cmd/sgs/libcrle/amd64/.make.state.i386
+usr/src/cmd/sgs/libcrle/amd64/msg.c
+usr/src/cmd/sgs/libcrle/amd64/msg.h
+usr/src/cmd/sgs/libcrle/i386/.make.state.i386
+usr/src/cmd/sgs/libcrle/i386/msg.c
+usr/src/cmd/sgs/libcrle/i386/msg.h
+usr/src/cmd/sgs/libdl/.make.state.i386
+usr/src/cmd/sgs/libdl/amd64/lint.out
+usr/src/cmd/sgs/libdl/amd64/llib-ldl.ln
+usr/src/cmd/sgs/libdl/i386/lint.out
+usr/src/cmd/sgs/libdl/i386/llib-ldl.ln
+usr/src/cmd/sgs/libelf/.make.state.i386
+usr/src/cmd/sgs/libelf/amd64/.make.state.i386
+usr/src/cmd/sgs/libelf/amd64/lint.out.1
+usr/src/cmd/sgs/libelf/amd64/llib-lelf.ln
+usr/src/cmd/sgs/libelf/amd64/msg.c
+usr/src/cmd/sgs/libelf/amd64/msg.h
+usr/src/cmd/sgs/libelf/amd64/xlate.c
+usr/src/cmd/sgs/libelf/amd64/xlate64.c
+usr/src/cmd/sgs/libelf/i386/.make.state.i386
+usr/src/cmd/sgs/libelf/i386/lint.out.1
+usr/src/cmd/sgs/libelf/i386/llib-lelf.ln
+usr/src/cmd/sgs/libelf/i386/msg.c
+usr/src/cmd/sgs/libelf/i386/msg.h
+usr/src/cmd/sgs/libelf/i386/xlate.c
+usr/src/cmd/sgs/libelf/i386/xlate64.c
+usr/src/cmd/sgs/libld/.make.state.i386
+usr/src/cmd/sgs/libld/amd64/.make.state.i386
+usr/src/cmd/sgs/libld/amd64/libld.so.4
+usr/src/cmd/sgs/libld/amd64/msg.c
+usr/src/cmd/sgs/libld/amd64/msg.h
+usr/src/cmd/sgs/libld/i386/.make.state.i386
+usr/src/cmd/sgs/libld/i386/libld.so.4
+usr/src/cmd/sgs/libld/i386/msg.c
+usr/src/cmd/sgs/libld/i386/msg.h
+usr/src/cmd/sgs/liblddbg/.make.state.i386
+usr/src/cmd/sgs/liblddbg/amd64/.make.state.i386
+usr/src/cmd/sgs/liblddbg/amd64/liblddbg.so.4
+usr/src/cmd/sgs/liblddbg/amd64/msg.c
+usr/src/cmd/sgs/liblddbg/amd64/msg.h
+usr/src/cmd/sgs/liblddbg/i386/.make.state.i386
+usr/src/cmd/sgs/liblddbg/i386/liblddbg.so.4
+usr/src/cmd/sgs/liblddbg/i386/msg.c
+usr/src/cmd/sgs/liblddbg/i386/msg.h
+usr/src/cmd/sgs/libldmake/.make.state.i386
+usr/src/cmd/sgs/libldmake/amd64/.make.state.i386
+usr/src/cmd/sgs/libldmake/i386/.make.state.i386
+usr/src/cmd/sgs/libldstab/.make.state.i386
+usr/src/cmd/sgs/libldstab/amd64/.make.state.i386
+usr/src/cmd/sgs/libldstab/i386/.make.state.i386
+usr/src/cmd/sgs/librtld/.make.state.i386
+usr/src/cmd/sgs/librtld/amd64/.make.state.i386
+usr/src/cmd/sgs/librtld/amd64/msg.c
+usr/src/cmd/sgs/librtld/amd64/msg.h
+usr/src/cmd/sgs/librtld/i386/.make.state.i386
+usr/src/cmd/sgs/librtld/i386/msg.c
+usr/src/cmd/sgs/librtld/i386/msg.h
+usr/src/cmd/sgs/librtld_db/.make.state.i386
+usr/src/cmd/sgs/librtld_db/amd64/.make.state.i386
+usr/src/cmd/sgs/librtld_db/amd64/lint.out.1
+usr/src/cmd/sgs/librtld_db/amd64/llib-lrtld_db.ln
+usr/src/cmd/sgs/librtld_db/amd64/msg.c
+usr/src/cmd/sgs/librtld_db/amd64/msg.h
+usr/src/cmd/sgs/librtld_db/demo/Makefile.com.demo
+usr/src/cmd/sgs/librtld_db/demo/Makefile.targ.demo
+usr/src/cmd/sgs/librtld_db/demo/amd64/Makefile.demo
+usr/src/cmd/sgs/librtld_db/demo/i386/Makefile.demo
+usr/src/cmd/sgs/librtld_db/demo/sparc/Makefile.demo
+usr/src/cmd/sgs/librtld_db/demo/sparcv9/Makefile.demo
+usr/src/cmd/sgs/librtld_db/i386/.make.state.i386
+usr/src/cmd/sgs/librtld_db/i386/lint.out.1
+usr/src/cmd/sgs/librtld_db/i386/llib-lrtld_db.ln
+usr/src/cmd/sgs/librtld_db/i386/msg.c
+usr/src/cmd/sgs/librtld_db/i386/msg.h
+usr/src/cmd/sgs/link_audit/amd64/.make.state.i386
+usr/src/cmd/sgs/link_audit/amd64/perfcnt
+usr/src/cmd/sgs/link_audit/amd64/symbindrep
+usr/src/cmd/sgs/link_audit/i386/.make.state.i386
+usr/src/cmd/sgs/link_audit/i386/dumpbind
+usr/src/cmd/sgs/link_audit/i386/perfcnt
+usr/src/cmd/sgs/link_audit/i386/sotruss
+usr/src/cmd/sgs/link_audit/i386/symbindrep
+usr/src/cmd/sgs/link_audit/i386/whocalls
+usr/src/cmd/sgs/lorder/.make.state.i386
+usr/src/cmd/sgs/lorder/lorder
+usr/src/cmd/sgs/m4/common/m4y.c
+usr/src/cmd/sgs/m4/common/m4y_xpg4.c
+usr/src/cmd/sgs/m4/i386/m4
+usr/src/cmd/sgs/m4/i386/m4.xpg4
+usr/src/cmd/sgs/mcs/.make.state.i386
+usr/src/cmd/sgs/mcs/amd64/.make.state.i386
+usr/src/cmd/sgs/mcs/amd64/mcs
+usr/src/cmd/sgs/mcs/i386/.make.state.i386
+usr/src/cmd/sgs/mcs/i386/mcs
+usr/src/cmd/sgs/messages/.make.state.i386
+usr/src/cmd/sgs/messages/i386/.make.state.i386
+usr/src/cmd/sgs/messages/i386/ar
+usr/src/cmd/sgs/messages/i386/crle
+usr/src/cmd/sgs/messages/i386/elfdump
+usr/src/cmd/sgs/messages/i386/elfedit
+usr/src/cmd/sgs/messages/i386/elfedit_cap
+usr/src/cmd/sgs/messages/i386/elfedit_dyn
+usr/src/cmd/sgs/messages/i386/elfedit_ehdr
+usr/src/cmd/sgs/messages/i386/elfedit_phdr
+usr/src/cmd/sgs/messages/i386/elfedit_shdr
+usr/src/cmd/sgs/messages/i386/elfedit_str
+usr/src/cmd/sgs/messages/i386/elfedit_sym
+usr/src/cmd/sgs/messages/i386/elfedit_syminfo
+usr/src/cmd/sgs/messages/i386/elfwrap
+usr/src/cmd/sgs/messages/i386/lari
+usr/src/cmd/sgs/messages/i386/ld
+usr/src/cmd/sgs/messages/i386/ldd
+usr/src/cmd/sgs/messages/i386/ldprof
+usr/src/cmd/sgs/messages/i386/libcrle
+usr/src/cmd/sgs/messages/i386/libelf
+usr/src/cmd/sgs/messages/i386/libld
+usr/src/cmd/sgs/messages/i386/liblddbg
+usr/src/cmd/sgs/messages/i386/librtld
+usr/src/cmd/sgs/messages/i386/moe
+usr/src/cmd/sgs/messages/i386/pvs
+usr/src/cmd/sgs/messages/i386/rtld
+usr/src/cmd/sgs/moe/.make.state.i386
+usr/src/cmd/sgs/moe/amd64/.make.state.i386
+usr/src/cmd/sgs/moe/amd64/moe
+usr/src/cmd/sgs/moe/amd64/msg.c
+usr/src/cmd/sgs/moe/amd64/msg.h
+usr/src/cmd/sgs/moe/i386/.make.state.i386
+usr/src/cmd/sgs/moe/i386/moe
+usr/src/cmd/sgs/moe/i386/msg.c
+usr/src/cmd/sgs/moe/i386/msg.h
+usr/src/cmd/sgs/nm/amd64/.make.state.i386
+usr/src/cmd/sgs/nm/amd64/nm
+usr/src/cmd/sgs/nm/i386/.make.state.i386
+usr/src/cmd/sgs/nm/i386/nm
+usr/src/cmd/sgs/nm/i386/nm.xpg4
+usr/src/cmd/sgs/prof/i386/.make.state.i386
+usr/src/cmd/sgs/prof/i386/prof
+usr/src/cmd/sgs/proto/
+usr/src/cmd/sgs/pvs/.make.state.i386
+usr/src/cmd/sgs/pvs/amd64/.make.state.i386
+usr/src/cmd/sgs/pvs/amd64/msg.c
+usr/src/cmd/sgs/pvs/amd64/msg.h
+usr/src/cmd/sgs/pvs/amd64/pvs
+usr/src/cmd/sgs/pvs/i386/.make.state.i386
+usr/src/cmd/sgs/pvs/i386/msg.c
+usr/src/cmd/sgs/pvs/i386/msg.h
+usr/src/cmd/sgs/pvs/i386/pvs
+usr/src/cmd/sgs/ranlib/ranlib
+usr/src/cmd/sgs/rtld/.make.state.i386
+usr/src/cmd/sgs/rtld/amd64/.make.state.i386
+usr/src/cmd/sgs/rtld/amd64/msg.c
+usr/src/cmd/sgs/rtld/amd64/msg.h
+usr/src/cmd/sgs/rtld/i386/.make.state.i386
+usr/src/cmd/sgs/rtld/i386/msg.c
+usr/src/cmd/sgs/rtld/i386/msg.h
+usr/src/cmd/sgs/rtld/mdbmod/.make.state.i386
+usr/src/cmd/sgs/rtld/mdbmod/amd64/.make.state.i386
+usr/src/cmd/sgs/rtld/mdbmod/amd64/msg.c
+usr/src/cmd/sgs/rtld/mdbmod/amd64/msg.h
+usr/src/cmd/sgs/rtld/mdbmod/i386/.make.state.i386
+usr/src/cmd/sgs/rtld/mdbmod/i386/msg.c
+usr/src/cmd/sgs/rtld/mdbmod/i386/msg.h
+usr/src/cmd/sgs/size/amd64/.make.state.i386
+usr/src/cmd/sgs/size/amd64/size
+usr/src/cmd/sgs/size/i386/.make.state.i386
+usr/src/cmd/sgs/size/i386/size
+usr/src/cmd/sgs/symorder/symorder
+usr/src/cmd/sgs/tools/i386/.make.state.i386
+usr/src/cmd/sgs/tools/i386/piglatin
+usr/src/cmd/sgs/tools/i386/sgsmsg
+usr/src/cmd/sgs/tsort/i386/tsort
+usr/src/cmd/sgs/unifdef/i386/unifdef
+usr/src/cmd/sgs/yacc/amd64/llib-ly.ln
+usr/src/cmd/sgs/yacc/i386/llib-ly.ln
+usr/src/cmd/sgs/yacc/i386/yacc
+usr/src/cmd/sh/sh
+usr/src/cmd/shcomp/shcomp
+usr/src/cmd/smbios/smbios
+usr/src/cmd/smserverd/rpc.smserverd
+usr/src/cmd/smserverd/smed.h
+usr/src/cmd/smserverd/smed_svc.c
+usr/src/cmd/smserverd/smed_xdr.c
+usr/src/cmd/soelim/soelim
+usr/src/cmd/sort/amd64/sort
+usr/src/cmd/sort/amd64/sort.xpg4
+usr/src/cmd/sort/i386/sort
+usr/src/cmd/sort/i386/sort.xpg4
+usr/src/cmd/spell/compress
+usr/src/cmd/spell/hashcheck
+usr/src/cmd/spell/hashmake
+usr/src/cmd/spell/hashmk1
+usr/src/cmd/spell/hlista
+usr/src/cmd/spell/hlistb
+usr/src/cmd/spell/hstop
+usr/src/cmd/spell/htemp1
+usr/src/cmd/spell/spell
+usr/src/cmd/spell/spellhist
+usr/src/cmd/spell/spellin
+usr/src/cmd/spell/spellin1
+usr/src/cmd/spell/spellprog
+usr/src/cmd/split/split
+usr/src/cmd/sqlite/sqlite
+usr/src/cmd/srchtxt/srchtxt
+usr/src/cmd/srptadm/srptadm
+usr/src/cmd/srptsvc/svc-srpt
+usr/src/cmd/ssh/THIRDPARTYLICENSE
+usr/src/cmd/ssh/libopenbsd-compat/i386/lint.out
+usr/src/cmd/ssh/libopenbsd-compat/i386/llib-lopenbsd-compat.ln
+usr/src/cmd/ssh/libssh/i386/lint.out
+usr/src/cmd/ssh/libssh/i386/llib-lssh.ln
+usr/src/cmd/ssh/scp/scp
+usr/src/cmd/ssh/sftp-server/sftp-server
+usr/src/cmd/ssh/sftp/sftp
+usr/src/cmd/ssh/ssh-add/ssh-add
+usr/src/cmd/ssh/ssh-agent/ssh-agent
+usr/src/cmd/ssh/ssh-http-proxy-connect/ssh-http-proxy-connect
+usr/src/cmd/ssh/ssh-keygen/ssh-keygen
+usr/src/cmd/ssh/ssh-keyscan/ssh-keyscan
+usr/src/cmd/ssh/ssh-keysign/ssh-keysign
+usr/src/cmd/ssh/ssh-socks5-proxy-connect/ssh-socks5-proxy-connect
+usr/src/cmd/ssh/ssh/ssh
+usr/src/cmd/ssh/sshd/sshd
+usr/src/cmd/stat/arcstat/arcstat
+usr/src/cmd/stat/fsstat/fsstat
+usr/src/cmd/stat/iostat/iostat
+usr/src/cmd/stat/mpstat/mpstat
+usr/src/cmd/stat/vfsstat/vfsstat
+usr/src/cmd/stat/vmstat/vmstat
+usr/src/cmd/stat/ziostat/ziostat
+usr/src/cmd/stmfadm/stmfadm
+usr/src/cmd/stmfproxy/aluaadm/aluaadm
+usr/src/cmd/stmfproxy/stmfproxy/svc-stmfproxy
+usr/src/cmd/stmfsvc/svc-stmf
+usr/src/cmd/stmsboot/stmsboot
+usr/src/cmd/stmsboot/stmsboot_util
+usr/src/cmd/streams/log/strace
+usr/src/cmd/streams/log/strclean
+usr/src/cmd/streams/log/strerr
+usr/src/cmd/streams/strcmd/strchg
+usr/src/cmd/streams/strcmd/strconf
+usr/src/cmd/strings/amd64/strings
+usr/src/cmd/strings/i386/strings
+usr/src/cmd/su/embedded_su
+usr/src/cmd/su/su
+usr/src/cmd/su/su.static
+usr/src/cmd/sulogin/sulogin
+usr/src/cmd/sunpc/other/dos2unix
+usr/src/cmd/sunpc/other/unix2dos
+usr/src/cmd/svc/configd/svc.configd
+usr/src/cmd/svc/configd/svc.configd-native
+usr/src/cmd/svc/lsvcrun/lsvcrun
+usr/src/cmd/svc/mfstscan/mfstscan
+usr/src/cmd/svc/milestone/console-login.xml
+usr/src/cmd/svc/profile/check_limited
+usr/src/cmd/svc/profile/check_limited.all
+usr/src/cmd/svc/profile/check_limited.enabled
+usr/src/cmd/svc/profile/check_limited.notcovered
+usr/src/cmd/svc/profile/check_open
+usr/src/cmd/svc/profile/check_open.all
+usr/src/cmd/svc/profile/check_open.enabled
+usr/src/cmd/svc/profile/check_open.notcovered
+usr/src/cmd/svc/seed/common.db
+usr/src/cmd/svc/seed/global.db
+usr/src/cmd/svc/seed/miniroot.db
+usr/src/cmd/svc/seed/nonglobal.db
+usr/src/cmd/svc/servinfo/servinfo
+usr/src/cmd/svc/startd/svc.startd
+usr/src/cmd/svc/svcadm/svcadm
+usr/src/cmd/svc/svccfg/svccfg
+usr/src/cmd/svc/svccfg/svccfg-native
+usr/src/cmd/svc/svccfg/svccfg_grammar.c
+usr/src/cmd/svc/svccfg/svccfg_grammar.h
+usr/src/cmd/svc/svccfg/svccfg_lex.c
+usr/src/cmd/svc/svcprop/svcprop
+usr/src/cmd/svc/svcs/svcs
+usr/src/cmd/svr4pkg/installf/dofinal.i
+usr/src/cmd/svr4pkg/installf/installf
+usr/src/cmd/svr4pkg/installf/installf.i
+usr/src/cmd/svr4pkg/installf/main.i
+usr/src/cmd/svr4pkg/installf/removef.i
+usr/src/cmd/svr4pkg/libinst/copyf.i
+usr/src/cmd/svr4pkg/libinst/cvtpath.i
+usr/src/cmd/svr4pkg/libinst/depchk.i
+usr/src/cmd/svr4pkg/libinst/dockdeps.i
+usr/src/cmd/svr4pkg/libinst/doulimit.i
+usr/src/cmd/svr4pkg/libinst/dryrun.i
+usr/src/cmd/svr4pkg/libinst/echo.i
+usr/src/cmd/svr4pkg/libinst/eptstat.i
+usr/src/cmd/svr4pkg/libinst/finalck.i
+usr/src/cmd/svr4pkg/libinst/findscripts.i
+usr/src/cmd/svr4pkg/libinst/fixpath.i
+usr/src/cmd/svr4pkg/libinst/flex_dev.i
+usr/src/cmd/svr4pkg/libinst/is_local_host.i
+usr/src/cmd/svr4pkg/libinst/isreloc.i
+usr/src/cmd/svr4pkg/libinst/listmgr.i
+usr/src/cmd/svr4pkg/libinst/lockinst.i
+usr/src/cmd/svr4pkg/libinst/log.i
+usr/src/cmd/svr4pkg/libinst/mntinfo.i
+usr/src/cmd/svr4pkg/libinst/nblk.i
+usr/src/cmd/svr4pkg/libinst/ocfile.i
+usr/src/cmd/svr4pkg/libinst/open_package_datastream.i
+usr/src/cmd/svr4pkg/libinst/pathdup.i
+usr/src/cmd/svr4pkg/libinst/pkgdbmerg.i
+usr/src/cmd/svr4pkg/libinst/pkgobjmap.i
+usr/src/cmd/svr4pkg/libinst/pkgops.i
+usr/src/cmd/svr4pkg/libinst/procmap.i
+usr/src/cmd/svr4pkg/libinst/ptext.i
+usr/src/cmd/svr4pkg/libinst/putparam.i
+usr/src/cmd/svr4pkg/libinst/qreason.i
+usr/src/cmd/svr4pkg/libinst/qstrdup.i
+usr/src/cmd/svr4pkg/libinst/scriptvfy.i
+usr/src/cmd/svr4pkg/libinst/setadmin.i
+usr/src/cmd/svr4pkg/libinst/setlist.i
+usr/src/cmd/svr4pkg/libinst/setup_temporary_directory.i
+usr/src/cmd/svr4pkg/libinst/sml.i
+usr/src/cmd/svr4pkg/libinst/srcpath.i
+usr/src/cmd/svr4pkg/libinst/stub.i
+usr/src/cmd/svr4pkg/libinst/unpack_package_from_stream.i
+usr/src/cmd/svr4pkg/pkgadd/check.i
+usr/src/cmd/svr4pkg/pkgadd/main.i
+usr/src/cmd/svr4pkg/pkgadd/pkgadd
+usr/src/cmd/svr4pkg/pkgadd/quit.i
+usr/src/cmd/svr4pkg/pkgadm/addcert.i
+usr/src/cmd/svr4pkg/pkgadm/certs.i
+usr/src/cmd/svr4pkg/pkgadm/listcert.i
+usr/src/cmd/svr4pkg/pkgadm/lock.i
+usr/src/cmd/svr4pkg/pkgadm/main.i
+usr/src/cmd/svr4pkg/pkgadm/pkgadm
+usr/src/cmd/svr4pkg/pkgadm/removecert.i
+usr/src/cmd/svr4pkg/pkgchk/checkmap.i
+usr/src/cmd/svr4pkg/pkgchk/ckentry.i
+usr/src/cmd/svr4pkg/pkgchk/main.i
+usr/src/cmd/svr4pkg/pkgchk/pkgchk
+usr/src/cmd/svr4pkg/pkgcond/main.i
+usr/src/cmd/svr4pkg/pkgcond/pkgcond
+usr/src/cmd/svr4pkg/pkginfo/pkginfo
+usr/src/cmd/svr4pkg/pkginfo/pkginfo.i
+usr/src/cmd/svr4pkg/pkginstall/backup.i
+usr/src/cmd/svr4pkg/pkginstall/check.i
+usr/src/cmd/svr4pkg/pkginstall/cppath.i
+usr/src/cmd/svr4pkg/pkginstall/dockspace.i
+usr/src/cmd/svr4pkg/pkginstall/getinst.i
+usr/src/cmd/svr4pkg/pkginstall/instvol.i
+usr/src/cmd/svr4pkg/pkginstall/main.i
+usr/src/cmd/svr4pkg/pkginstall/merginfo.i
+usr/src/cmd/svr4pkg/pkginstall/pkgenv.i
+usr/src/cmd/svr4pkg/pkginstall/pkginstall
+usr/src/cmd/svr4pkg/pkginstall/pkgvolume.i
+usr/src/cmd/svr4pkg/pkginstall/quit.i
+usr/src/cmd/svr4pkg/pkginstall/reqexec.i
+usr/src/cmd/svr4pkg/pkginstall/sortmap.i
+usr/src/cmd/svr4pkg/pkgmk/main.i
+usr/src/cmd/svr4pkg/pkgmk/mkpkgmap.i
+usr/src/cmd/svr4pkg/pkgmk/pkgmk
+usr/src/cmd/svr4pkg/pkgmk/quit.i
+usr/src/cmd/svr4pkg/pkgmk/splpkgmap.i
+usr/src/cmd/svr4pkg/pkgname/pkgname
+usr/src/cmd/svr4pkg/pkgname/pkgname.i
+usr/src/cmd/svr4pkg/pkgparam/pkgparam
+usr/src/cmd/svr4pkg/pkgparam/pkgparam.i
+usr/src/cmd/svr4pkg/pkgproto/main.i
+usr/src/cmd/svr4pkg/pkgproto/pkgproto
+usr/src/cmd/svr4pkg/pkgremove/check.i
+usr/src/cmd/svr4pkg/pkgremove/delmap.i
+usr/src/cmd/svr4pkg/pkgremove/main.i
+usr/src/cmd/svr4pkg/pkgremove/pkgremove
+usr/src/cmd/svr4pkg/pkgremove/quit.i
+usr/src/cmd/svr4pkg/pkgremove/special.i
+usr/src/cmd/svr4pkg/pkgrm/check.i
+usr/src/cmd/svr4pkg/pkgrm/main.i
+usr/src/cmd/svr4pkg/pkgrm/pkgrm
+usr/src/cmd/svr4pkg/pkgrm/quit.i
+usr/src/cmd/svr4pkg/pkgscripts/cmdexec
+usr/src/cmd/svr4pkg/pkgscripts/cmdexec.i
+usr/src/cmd/svr4pkg/pkgscripts/i.CompCpio
+usr/src/cmd/svr4pkg/pkgscripts/i.awk
+usr/src/cmd/svr4pkg/pkgscripts/i.build
+usr/src/cmd/svr4pkg/pkgscripts/i.preserve
+usr/src/cmd/svr4pkg/pkgscripts/i.sed
+usr/src/cmd/svr4pkg/pkgscripts/r.awk
+usr/src/cmd/svr4pkg/pkgscripts/r.build
+usr/src/cmd/svr4pkg/pkgscripts/r.sed
+usr/src/cmd/svr4pkg/pkgserv/pkgserv
+usr/src/cmd/svr4pkg/pkgserv/pkgserv.i
+usr/src/cmd/svr4pkg/pkgtrans/main.i
+usr/src/cmd/svr4pkg/pkgtrans/pkgtrans
+usr/src/cmd/swap/amd64/swap
+usr/src/cmd/swap/i386/swap
+usr/src/cmd/sync/sync
+usr/src/cmd/sysdef/amd64/sysdef
+usr/src/cmd/sysdef/i386/sysdef
+usr/src/cmd/syseventadm/syseventadm
+usr/src/cmd/syseventd/daemons/syseventconfd/syseventconfd
+usr/src/cmd/syseventd/daemons/syseventd/syseventd
+usr/src/cmd/syslogd/i386/authlog
+usr/src/cmd/syslogd/i386/syslog
+usr/src/cmd/syslogd/i386/syslogd
+usr/src/cmd/tabs/tabs
+usr/src/cmd/tail/tail
+usr/src/cmd/tar/tar
+usr/src/cmd/tar/tar.dc
+usr/src/cmd/tbl/tbl
+usr/src/cmd/tcopy/tcopy
+usr/src/cmd/tcpd/THIRDPARTYLICENSE
+usr/src/cmd/tcpd/safe_finger
+usr/src/cmd/tcpd/sunman/
+usr/src/cmd/tcpd/tcpd
+usr/src/cmd/tcpd/tcpdchk
+usr/src/cmd/tcpd/tcpdmatch
+usr/src/cmd/tcpd/try-from
+usr/src/cmd/terminfo/errs
+usr/src/cmd/terminfo/terminfo.src
+usr/src/cmd/th_tools/th_define
+usr/src/cmd/th_tools/th_manage
+usr/src/cmd/th_tools/th_script
+usr/src/cmd/tic/tic
+usr/src/cmd/time/time
+usr/src/cmd/tip/aculog
+usr/src/cmd/tip/tip
+usr/src/cmd/tnf/prex/amd64/prex
+usr/src/cmd/tnf/prex/amd64/prexgram.c
+usr/src/cmd/tnf/prex/amd64/prexlex.c
+usr/src/cmd/tnf/prex/amd64/y.tab.h
+usr/src/cmd/tnf/prex/i386/prex
+usr/src/cmd/tnf/prex/i386/prexgram.c
+usr/src/cmd/tnf/prex/i386/prexlex.c
+usr/src/cmd/tnf/prex/i386/y.tab.h
+usr/src/cmd/tnf/tnfdump/tnfdump
+usr/src/cmd/tnf/tnfxtract/amd64/tnfxtract
+usr/src/cmd/tnf/tnfxtract/i386/tnfxtract
+usr/src/cmd/touch/touch
+usr/src/cmd/tput/tput
+usr/src/cmd/tr/tr
+usr/src/cmd/troff/nroff.d/nroff
+usr/src/cmd/troff/nroff.d/terms.d/tab.2631
+usr/src/cmd/troff/nroff.d/terms.d/tab.2631-c
+usr/src/cmd/troff/nroff.d/terms.d/tab.2631-e
+usr/src/cmd/troff/nroff.d/terms.d/tab.300
+usr/src/cmd/troff/nroff.d/terms.d/tab.300-12
+usr/src/cmd/troff/nroff.d/terms.d/tab.300s
+usr/src/cmd/troff/nroff.d/terms.d/tab.300s-12
+usr/src/cmd/troff/nroff.d/terms.d/tab.37
+usr/src/cmd/troff/nroff.d/terms.d/tab.382
+usr/src/cmd/troff/nroff.d/terms.d/tab.4000a
+usr/src/cmd/troff/nroff.d/terms.d/tab.450
+usr/src/cmd/troff/nroff.d/terms.d/tab.450-12
+usr/src/cmd/troff/nroff.d/terms.d/tab.832
+usr/src/cmd/troff/nroff.d/terms.d/tab.8510
+usr/src/cmd/troff/nroff.d/terms.d/tab.X
+usr/src/cmd/troff/nroff.d/terms.d/tab.lp
+usr/src/cmd/troff/nroff.d/terms.d/tab.tn300
+usr/src/cmd/troff/troff.d/makedev
+usr/src/cmd/troff/troff.d/ta
+usr/src/cmd/troff/troff.d/troff
+usr/src/cmd/true/true
+usr/src/cmd/truss/amd64/truss
+usr/src/cmd/truss/i386/truss
+usr/src/cmd/tsol/atohexlabel/atohexlabel
+usr/src/cmd/tsol/getlabel/getlabel
+usr/src/cmd/tsol/getzonepath/getzonepath
+usr/src/cmd/tsol/hextoalabel/hextoalabel
+usr/src/cmd/tsol/lslabels/lslabels
+usr/src/cmd/tsol/misc/relabel
+usr/src/cmd/tsol/misc/txzonemgr
+usr/src/cmd/tsol/plabel/plabel
+usr/src/cmd/tsol/setlabel/setlabel
+usr/src/cmd/tsol/tnchkdb/tnchkdb
+usr/src/cmd/tsol/tnctl/tnctl
+usr/src/cmd/tsol/tnd/tnd
+usr/src/cmd/tsol/tninfo/tninfo
+usr/src/cmd/tsol/updatehome/updatehome
+usr/src/cmd/tsol/zones/zoneshare
+usr/src/cmd/tsol/zones/zoneunshare
+usr/src/cmd/tty/tty
+usr/src/cmd/ttymon/stty
+usr/src/cmd/ttymon/stty.xpg4
+usr/src/cmd/ttymon/sttydefs
+usr/src/cmd/ttymon/ttyadm
+usr/src/cmd/ttymon/ttymon
+usr/src/cmd/tzreload/tzreload
+usr/src/cmd/uadmin/uadmin
+usr/src/cmd/ucodeadm/ucode_errno.c
+usr/src/cmd/ucodeadm/ucodeadm
+usr/src/cmd/ul/ul
+usr/src/cmd/uname/uname
+usr/src/cmd/units/units
+usr/src/cmd/unlink/unlink
+usr/src/cmd/unpack/unpack
+usr/src/cmd/userattr/userattr
+usr/src/cmd/users/listusers
+usr/src/cmd/utmp_update/utmp_update
+usr/src/cmd/utmpd/utmpd
+usr/src/cmd/valtools/ckdate
+usr/src/cmd/valtools/ckgid
+usr/src/cmd/valtools/ckint
+usr/src/cmd/valtools/ckitem
+usr/src/cmd/valtools/ckkeywd
+usr/src/cmd/valtools/ckpath
+usr/src/cmd/valtools/ckrange
+usr/src/cmd/valtools/ckstr
+usr/src/cmd/valtools/cktime
+usr/src/cmd/valtools/ckuid
+usr/src/cmd/valtools/ckyorn
+usr/src/cmd/valtools/puttext
+usr/src/cmd/vgrind/vfontedpr
+usr/src/cmd/vgrind/vgrind
+usr/src/cmd/vgrind/vgrindefs
+usr/src/cmd/vi/misc/ctags
+usr/src/cmd/vi/misc/ctags.xpg4
+usr/src/cmd/vi/misc/cxref
+usr/src/cmd/vi/misc/fold
+usr/src/cmd/vi/port/ex
+usr/src/cmd/vi/port/ex.xpg4
+usr/src/cmd/vi/port/ex.xpg6
+usr/src/cmd/vi/port/expreserve
+usr/src/cmd/vi/port/exrecover
+usr/src/cmd/volcheck/volcheck
+usr/src/cmd/volrmmount/volrmmount
+usr/src/cmd/vrrpadm/vrrpadm
+usr/src/cmd/vscan/vscanadm/vscanadm
+usr/src/cmd/vscan/vscand/vscand
+usr/src/cmd/vt/vtdaemon
+usr/src/cmd/vt/vtinfo
+usr/src/cmd/vt/vtxlock
+usr/src/cmd/w/amd64/w
+usr/src/cmd/w/i386/w
+usr/src/cmd/w/w.dc
+usr/src/cmd/wall/wall
+usr/src/cmd/which/which
+usr/src/cmd/who/utmpx
+usr/src/cmd/who/who
+usr/src/cmd/who/who.dc
+usr/src/cmd/who/who.xpg4
+usr/src/cmd/whodo/amd64/whodo
+usr/src/cmd/whodo/i386/whodo
+usr/src/cmd/whodo/whodo.dc
+usr/src/cmd/wracct/wracct
+usr/src/cmd/write/write
+usr/src/cmd/write/write.dc
+usr/src/cmd/wusbadm/wusbadm
+usr/src/cmd/xargs/xargs
+usr/src/cmd/xstr/xstr
+usr/src/cmd/xvm/ipagent/ipagent
+usr/src/cmd/yes/yes
+usr/src/cmd/ypcmd/makedbm
+usr/src/cmd/ypcmd/mkalias
+usr/src/cmd/ypcmd/mknetid/mknetid
+usr/src/cmd/ypcmd/multi
+usr/src/cmd/ypcmd/multi.awk
+usr/src/cmd/ypcmd/revnetgroup/revnetgroup
+usr/src/cmd/ypcmd/stdethers
+usr/src/cmd/ypcmd/stdhosts
+usr/src/cmd/ypcmd/udpublickey
+usr/src/cmd/ypcmd/yp
+usr/src/cmd/ypcmd/yp2lscripts/inityp2l
+usr/src/cmd/ypcmd/yp2lscripts/ypmap2src
+usr/src/cmd/ypcmd/ypalias
+usr/src/cmd/ypcmd/ypbind
+usr/src/cmd/ypcmd/ypcat
+usr/src/cmd/ypcmd/ypinit
+usr/src/cmd/ypcmd/ypmatch
+usr/src/cmd/ypcmd/yppasswd/rpc.yppasswdd
+usr/src/cmd/ypcmd/yppoll
+usr/src/cmd/ypcmd/yppush
+usr/src/cmd/ypcmd/ypserv
+usr/src/cmd/ypcmd/ypset
+usr/src/cmd/ypcmd/ypstart
+usr/src/cmd/ypcmd/ypstop
+usr/src/cmd/ypcmd/ypupdated/rpc.ypupdated
+usr/src/cmd/ypcmd/ypupdated/ypupdated_prot.h
+usr/src/cmd/ypcmd/ypwhich
+usr/src/cmd/ypcmd/ypxfr
+usr/src/cmd/ypcmd/ypxfr_1perday
+usr/src/cmd/ypcmd/ypxfr_1perhour
+usr/src/cmd/ypcmd/ypxfr_2perday
+usr/src/cmd/ypcmd/ypxfrd
+usr/src/cmd/ypcmd/ypxfrd.h
+usr/src/cmd/ypcmd/ypxfrd_xdr.c
+usr/src/cmd/yppasswd/yppasswd
+usr/src/cmd/zdb/amd64/zdb
+usr/src/cmd/zdb/i386/zdb
+usr/src/cmd/zdump/zdump
+usr/src/cmd/zfs/zfs
+usr/src/cmd/zic/native/
+usr/src/cmd/zic/tzselect
+usr/src/cmd/zic/zic
+usr/src/cmd/zinject/amd64/zinject
+usr/src/cmd/zinject/i386/zinject
+usr/src/cmd/zlogin/zlogin
+usr/src/cmd/zlook/amd64/zlook
+usr/src/cmd/zlook/i386/zlook
+usr/src/cmd/zoneadm/zoneadm
+usr/src/cmd/zoneadm/zonemon
+usr/src/cmd/zoneadmd/zoneadmd
+usr/src/cmd/zonecfg/zonecfg
+usr/src/cmd/zonecfg/zonecfg_grammar.tab.c
+usr/src/cmd/zonecfg/zonecfg_grammar.tab.h
+usr/src/cmd/zonecfg/zonecfg_lex.c
+usr/src/cmd/zonename/zonename
+usr/src/cmd/zonestat/zonestat/zonestat
+usr/src/cmd/zonestat/zonestatd/zonestatd
+usr/src/cmd/zpool/zpool
+usr/src/cmd/zstreamdump/zstreamdump
+usr/src/cmd/ztest/amd64/ztest
+usr/src/cmd/ztest/i386/ztest
+usr/src/common/mapfiles/gen/amd64_cc_map.noexeglobs
+usr/src/common/mapfiles/gen/amd64_gcc_map.noexeglobs
+usr/src/common/mapfiles/gen/i386_cc_map.noexeglobs
+usr/src/common/mapfiles/gen/i386_gcc_map.noexeglobs
+usr/src/grub/grub-0.97/grub/grub
+usr/src/grub/grub-0.97/stage1/stage1
+usr/src/grub/grub-0.97/stage1/stage1.exec
+usr/src/grub/grub-0.97/stage2/diskless
+usr/src/grub/grub-0.97/stage2/diskless.exec
+usr/src/grub/grub-0.97/stage2/diskless_size.h
+usr/src/grub/grub-0.97/stage2/e2fs_stage1_5
+usr/src/grub/grub-0.97/stage2/e2fs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/fat_stage1_5
+usr/src/grub/grub-0.97/stage2/fat_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/ffs_stage1_5
+usr/src/grub/grub-0.97/stage2/ffs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/iso9660_stage1_5
+usr/src/grub/grub-0.97/stage2/iso9660_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/jfs_stage1_5
+usr/src/grub/grub-0.97/stage2/jfs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/minix_stage1_5
+usr/src/grub/grub-0.97/stage2/minix_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/nbgrub
+usr/src/grub/grub-0.97/stage2/nbloader
+usr/src/grub/grub-0.97/stage2/nbloader.exec
+usr/src/grub/grub-0.97/stage2/pre_stage2
+usr/src/grub/grub-0.97/stage2/pre_stage2.exec
+usr/src/grub/grub-0.97/stage2/pxegrub
+usr/src/grub/grub-0.97/stage2/pxeloader
+usr/src/grub/grub-0.97/stage2/pxeloader.exec
+usr/src/grub/grub-0.97/stage2/reiserfs_stage1_5
+usr/src/grub/grub-0.97/stage2/reiserfs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/stage2
+usr/src/grub/grub-0.97/stage2/stage2_eltorito
+usr/src/grub/grub-0.97/stage2/stage2_size.h
+usr/src/grub/grub-0.97/stage2/start
+usr/src/grub/grub-0.97/stage2/start.exec
+usr/src/grub/grub-0.97/stage2/start_eltorito
+usr/src/grub/grub-0.97/stage2/start_eltorito.exec
+usr/src/grub/grub-0.97/stage2/ufs2_stage1_5
+usr/src/grub/grub-0.97/stage2/ufs2_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/ufs_stage1_5
+usr/src/grub/grub-0.97/stage2/ufs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/vstafs_stage1_5
+usr/src/grub/grub-0.97/stage2/vstafs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/xfs_stage1_5
+usr/src/grub/grub-0.97/stage2/xfs_stage1_5.exec
+usr/src/grub/grub-0.97/stage2/zfs_stage1_5
+usr/src/grub/grub-0.97/stage2/zfs_stage1_5.exec
+usr/src/head/mdiox.h
+usr/src/head/meta_basic.h
+usr/src/head/metacl.h
+usr/src/head/metad.h
+usr/src/head/metamed.h
+usr/src/head/metamhd.h
+usr/src/head/mhdx.h
+usr/src/head/rpcsvc/bootparam_prot.h
+usr/src/head/rpcsvc/mount.h
+usr/src/head/rpcsvc/nfs4_prot.h
+usr/src/head/rpcsvc/nfs_acl.h
+usr/src/head/rpcsvc/nfs_prot.c
+usr/src/head/rpcsvc/nfs_prot.h
+usr/src/head/rpcsvc/nis.h
+usr/src/head/rpcsvc/nlm_prot.h
+usr/src/head/rpcsvc/rex.h
+usr/src/head/rpcsvc/rquota.h
+usr/src/head/rpcsvc/rstat.h
+usr/src/head/rpcsvc/rusers.h
+usr/src/head/rpcsvc/rwall.h
+usr/src/head/rpcsvc/spray.h
+usr/src/head/rpcsvc/ufs_prot.h
+usr/src/install-nd-i386.out
+usr/src/lib/abi/apptrace/common/abienv.i
+usr/src/lib/abi/apptrace/common/apptrace.i
+usr/src/lib/brand/joyent/zone/jattach
+usr/src/lib/brand/joyent/zone/jdetach
+usr/src/lib/brand/joyent/zone/jinstall
+usr/src/lib/brand/joyent/zone/juninstall
+usr/src/lib/brand/joyent/zone/pinstall
+usr/src/lib/brand/joyent/zone/poststate
+usr/src/lib/brand/joyent/zone/prestate
+usr/src/lib/brand/joyent/zone/query
+usr/src/lib/brand/joyent/zone/statechange
+usr/src/lib/brand/kvm/zone/kattach
+usr/src/lib/brand/kvm/zone/kdetach
+usr/src/lib/brand/kvm/zone/kinstall
+usr/src/lib/brand/kvm/zone/kuninstall
+usr/src/lib/brand/kvm/zone/pinstall
+usr/src/lib/brand/kvm/zone/poststate
+usr/src/lib/brand/kvm/zone/prestate
+usr/src/lib/brand/kvm/zone/statechange
+usr/src/lib/brand/lx/cmd/ifconfig
+usr/src/lib/brand/lx/cmd/lx_isaexec_wrapper
+usr/src/lib/brand/lx/cmd/lx_lockd
+usr/src/lib/brand/lx/cmd/lx_native
+usr/src/lib/brand/lx/cmd/lx_statd
+usr/src/lib/brand/lx/cmd/lx_thunk
+usr/src/lib/brand/lx/lx_brand/amd64/assym.h
+usr/src/lib/brand/lx/lx_brand/amd64/lx_provider_impl.h
+usr/src/lib/brand/lx/lx_brand/i386/assym.h
+usr/src/lib/brand/lx/lx_brand/i386/lx_provider_impl.h
+usr/src/lib/brand/lx/lx_init/lxinit
+usr/src/lib/brand/lx/lx_support/lx_support
+usr/src/lib/brand/lx/lx_vdso/tools/vdso_tool
+usr/src/lib/brand/lx/netfiles/etc_default_nfs
+usr/src/lib/brand/lx/zone/lx_boot
+usr/src/lib/brand/lx/zone/lx_boot_zone_busybox
+usr/src/lib/brand/lx/zone/lx_boot_zone_debian
+usr/src/lib/brand/lx/zone/lx_boot_zone_redhat
+usr/src/lib/brand/lx/zone/lx_boot_zone_ubuntu
+usr/src/lib/brand/lx/zone/lx_distro_install
+usr/src/lib/brand/lx/zone/lx_install
+usr/src/lib/brand/lx/zone/lx_networking
+usr/src/lib/brand/shared/brand/amd64/assym.h
+usr/src/lib/brand/shared/brand/i386/assym.h
+usr/src/lib/brand/shared/zone/query
+usr/src/lib/brand/sn1/zone/sn1_boot
+usr/src/lib/brand/solaris10/cmd/s10_isaexec_wrapper
+usr/src/lib/brand/solaris10/cmd/s10_native
+usr/src/lib/brand/solaris10/cmd/s10_net_physical
+usr/src/lib/brand/solaris10/cmd/s10_python_wrapper
+usr/src/lib/brand/solaris10/s10_replacefile/s10_replacefile
+usr/src/lib/brand/solaris10/s10_support/s10_support
+usr/src/lib/brand/solaris10/zone/attach
+usr/src/lib/brand/solaris10/zone/clone
+usr/src/lib/brand/solaris10/zone/detach
+usr/src/lib/brand/solaris10/zone/image_install
+usr/src/lib/brand/solaris10/zone/p2v
+usr/src/lib/brand/solaris10/zone/postattach
+usr/src/lib/brand/solaris10/zone/poststate
+usr/src/lib/brand/solaris10/zone/prestate
+usr/src/lib/brand/solaris10/zone/preuninstall
+usr/src/lib/brand/solaris10/zone/s10_boot
+usr/src/lib/brand/solaris10/zone/uninstall
+usr/src/lib/c_synonyms/amd64/mapfile-vers
+usr/src/lib/c_synonyms/amd64/synonym_list
+usr/src/lib/c_synonyms/i386/mapfile-vers
+usr/src/lib/c_synonyms/i386/synonym_list
+usr/src/lib/cfgadm_plugins/sbd/common/ap_err.c
+usr/src/lib/cfgadm_plugins/sbd/sbdgenerr
+usr/src/lib/fm/libdiagcode/amd64/lint.out
+usr/src/lib/fm/libdiagcode/amd64/llib-ldiagcode.ln
+usr/src/lib/fm/libdiagcode/i386/lint.out
+usr/src/lib/fm/libdiagcode/i386/llib-ldiagcode.ln
+usr/src/lib/fm/libdiskstatus/amd64/lint.out
+usr/src/lib/fm/libdiskstatus/amd64/llib-ldiskstatus.ln
+usr/src/lib/fm/libdiskstatus/i386/lint.out
+usr/src/lib/fm/libdiskstatus/i386/llib-ldiskstatus.ln
+usr/src/lib/fm/libfmd_adm/amd64/fmd_rpc.c
+usr/src/lib/fm/libfmd_adm/amd64/fmd_rpc_adm.h
+usr/src/lib/fm/libfmd_adm/amd64/fmd_rpc_adm.x
+usr/src/lib/fm/libfmd_adm/amd64/fmd_xdr.c
+usr/src/lib/fm/libfmd_adm/amd64/lint.out
+usr/src/lib/fm/libfmd_adm/amd64/llib-lfmd_adm.ln
+usr/src/lib/fm/libfmd_adm/i386/fmd_rpc.c
+usr/src/lib/fm/libfmd_adm/i386/fmd_rpc_adm.h
+usr/src/lib/fm/libfmd_adm/i386/fmd_rpc_adm.x
+usr/src/lib/fm/libfmd_adm/i386/fmd_xdr.c
+usr/src/lib/fm/libfmd_adm/i386/lint.out
+usr/src/lib/fm/libfmd_adm/i386/llib-lfmd_adm.ln
+usr/src/lib/fm/libfmd_agent/amd64/lint.out
+usr/src/lib/fm/libfmd_agent/amd64/llib-lfmd_agent.ln
+usr/src/lib/fm/libfmd_agent/i386/lint.out
+usr/src/lib/fm/libfmd_agent/i386/llib-lfmd_agent.ln
+usr/src/lib/fm/libfmd_log/amd64/lint.out
+usr/src/lib/fm/libfmd_log/amd64/llib-lfmd_log.ln
+usr/src/lib/fm/libfmd_log/i386/lint.out
+usr/src/lib/fm/libfmd_log/i386/llib-lfmd_log.ln
+usr/src/lib/fm/libfmd_msg/amd64/lint.out
+usr/src/lib/fm/libfmd_msg/amd64/llib-lfmd_msg.ln
+usr/src/lib/fm/libfmd_msg/i386/lint.out
+usr/src/lib/fm/libfmd_msg/i386/llib-lfmd_msg.ln
+usr/src/lib/fm/libfmd_snmp/amd64/lint.out
+usr/src/lib/fm/libfmd_snmp/amd64/llib-lfmd_snmp.ln
+usr/src/lib/fm/libfmd_snmp/i386/lint.out
+usr/src/lib/fm/libfmd_snmp/i386/llib-lfmd_snmp.ln
+usr/src/lib/fm/libfmevent/amd64/lint.out
+usr/src/lib/fm/libfmevent/amd64/llib-lfmevent.ln
+usr/src/lib/fm/libfmevent/common/fmev_errstring.c
+usr/src/lib/fm/libfmevent/i386/lint.out
+usr/src/lib/fm/libfmevent/i386/llib-lfmevent.ln
+usr/src/lib/fm/libfmnotify/amd64/lint.out
+usr/src/lib/fm/libfmnotify/amd64/llib-lfmnotify.ln
+usr/src/lib/fm/libfmnotify/i386/lint.out
+usr/src/lib/fm/libfmnotify/i386/llib-lfmnotify.ln
+usr/src/lib/fm/libseslog/amd64/lint.out
+usr/src/lib/fm/libseslog/amd64/llib-lseslog.ln
+usr/src/lib/fm/libseslog/i386/lint.out
+usr/src/lib/fm/libseslog/i386/llib-lseslog.ln
+usr/src/lib/fm/topo/libtopo/amd64/lint.out
+usr/src/lib/fm/topo/libtopo/amd64/llib-ltopo.ln
+usr/src/lib/fm/topo/libtopo/common/topo_error.c
+usr/src/lib/fm/topo/libtopo/common/topo_tables.c
+usr/src/lib/fm/topo/libtopo/i386/lint.out
+usr/src/lib/fm/topo/libtopo/i386/llib-ltopo.ln
+usr/src/lib/fm/topo/maps/SUNW,Netra-X4200-M2/Netra-X4200-M2-disk-hc-topology.xml
+usr/src/lib/fm/topo/maps/SUNW,Sun-Fire-X4200-M2/Sun-Fire-X4200-M2-disk-hc-topology.xml
+usr/src/lib/fm/topo/maps/SUNW,Sun-Fire-X4200-Server/Sun-Fire-X4200-Server-disk-hc-topology.xml
+usr/src/lib/fm/topo/maps/SUNW,Sun-Fire-X4500/Sun-Fire-X4500-disk-hc-topology.xml
+usr/src/lib/fm/topo/maps/SUNW,Sun-Fire-X4540/Sun-Fire-X4540-disk-hc-topology.xml
+usr/src/lib/fm/topo/maps/SUNW,Sun-Fire-X4600-M2/Sun-Fire-X4600-M2-disk-hc-topology.xml
+usr/src/lib/fm/topo/maps/i386/xfp-hc-topology.xml
+usr/src/lib/fm/topo/maps/i86pc/fan-hc-topology.xml
+usr/src/lib/gss_mechs/mech_dh/backend/mech/dhmech_prot.h
+usr/src/lib/gss_mechs/mech_dh/backend/mech/xdr_token.c
+usr/src/lib/gss_mechs/mech_krb5/amd64/kwarnd.h
+usr/src/lib/gss_mechs/mech_krb5/amd64/kwarnd_clnt.c
+usr/src/lib/gss_mechs/mech_krb5/amd64/kwarnd_clnt_stubs.c
+usr/src/lib/gss_mechs/mech_krb5/amd64/kwarnd_handle.c
+usr/src/lib/gss_mechs/mech_krb5/amd64/kwarnd_xdr.c
+usr/src/lib/gss_mechs/mech_krb5/i386/kwarnd.h
+usr/src/lib/gss_mechs/mech_krb5/i386/kwarnd_clnt.c
+usr/src/lib/gss_mechs/mech_krb5/i386/kwarnd_clnt_stubs.c
+usr/src/lib/gss_mechs/mech_krb5/i386/kwarnd_handle.c
+usr/src/lib/gss_mechs/mech_krb5/i386/kwarnd_xdr.c
+usr/src/lib/hal/libhal-storage/amd64/hal-storage.pc
+usr/src/lib/hal/libhal-storage/amd64/libhal-storage.so.1.0.0
+usr/src/lib/hal/libhal-storage/amd64/lint.out
+usr/src/lib/hal/libhal-storage/amd64/llib-lhal-storage.ln
+usr/src/lib/hal/libhal-storage/i386/hal-storage.pc
+usr/src/lib/hal/libhal-storage/i386/libhal-storage.so.1.0.0
+usr/src/lib/hal/libhal-storage/i386/lint.out
+usr/src/lib/hal/libhal-storage/i386/llib-lhal-storage.ln
+usr/src/lib/hal/libhal/amd64/hal.pc
+usr/src/lib/hal/libhal/amd64/libhal.so.1.0.0
+usr/src/lib/hal/libhal/amd64/lint.out
+usr/src/lib/hal/libhal/amd64/llib-lhal.ln
+usr/src/lib/hal/libhal/i386/hal.pc
+usr/src/lib/hal/libhal/i386/libhal.so.1.0.0
+usr/src/lib/hal/libhal/i386/lint.out
+usr/src/lib/hal/libhal/i386/llib-lhal.ln
+usr/src/lib/hbaapi/amd64/lint.out
+usr/src/lib/hbaapi/amd64/llib-lHBAAPI.ln
+usr/src/lib/hbaapi/i386/lint.out
+usr/src/lib/hbaapi/i386/llib-lHBAAPI.ln
+usr/src/lib/krb5/kadm5/clnt/iprop.h
+usr/src/lib/krb5/kdb/iprop.h
+usr/src/lib/krb5/kdb/iprop_xdr.c
+usr/src/lib/libadm/amd64/lint.out
+usr/src/lib/libadm/amd64/llib-ladm.ln
+usr/src/lib/libadm/i386/lint.out
+usr/src/lib/libadm/i386/llib-ladm.ln
+usr/src/lib/libadt_jni/amd64/lint.out
+usr/src/lib/libadt_jni/amd64/llib-ladt_jni.ln
+usr/src/lib/libadt_jni/com/sun/audit/Audit.jar
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_admin_authenticate.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_admin_authenticate.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_filesystem_add.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_filesystem_add.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_filesystem_delete.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_filesystem_delete.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_filesystem_modify.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_filesystem_modify.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_ilb_delete_rule.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_ilb_delete_rule.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_ilb_disable_rule.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_ilb_disable_rule.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_ilb_enable_rule.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_ilb_enable_rule.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_logout.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_logout.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_network_add.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_network_add.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_network_delete.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_network_delete.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_network_modify.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_network_modify.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_printer_add.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_printer_add.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_printer_delete.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_printer_delete.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_printer_modify.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_printer_modify.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_role_login.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_role_login.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_scheduledjob_add.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_scheduledjob_add.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_scheduledjob_delete.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_scheduledjob_delete.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_scheduledjob_modify.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_scheduledjob_modify.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_serialport_add.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_serialport_add.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_serialport_delete.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_serialport_delete.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_serialport_modify.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_serialport_modify.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_uauth.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_uauth.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_usermgr_add.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_usermgr_add.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_usermgr_delete.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_usermgr_delete.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_usermgr_modify.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditEvent_usermgr_modify.java
+usr/src/lib/libadt_jni/com/sun/audit/AuditSession.class
+usr/src/lib/libadt_jni/com/sun/audit/AuditSession.h
+usr/src/lib/libadt_jni/common/adt_jni_event.c
+usr/src/lib/libadt_jni/common/mapfile-vers
+usr/src/lib/libadt_jni/i386/lint.out
+usr/src/lib/libadt_jni/i386/llib-ladt_jni.ln
+usr/src/lib/libadutils/amd64/lint.out
+usr/src/lib/libadutils/amd64/llib-ladutils.ln
+usr/src/lib/libadutils/i386/lint.out
+usr/src/lib/libadutils/i386/llib-ladutils.ln
+usr/src/lib/libaio/amd64/lint.out
+usr/src/lib/libaio/amd64/llib-laio.ln
+usr/src/lib/libaio/i386/lint.out
+usr/src/lib/libaio/i386/llib-laio.ln
+usr/src/lib/libast/amd64/libast.msg
+usr/src/lib/libast/amd64/lint.out
+usr/src/lib/libast/amd64/llib-last.ln
+usr/src/lib/libast/amd64/msgcc.out
+usr/src/lib/libast/amd64/msgs/
+usr/src/lib/libast/i386/libast.msg
+usr/src/lib/libast/i386/lint.out
+usr/src/lib/libast/i386/llib-last.ln
+usr/src/lib/libast/i386/msgcc.out
+usr/src/lib/libast/i386/msgs/
+usr/src/lib/libast/tmpastinclude/
+usr/src/lib/libavl/amd64/lint.out
+usr/src/lib/libavl/amd64/llib-lavl.ln
+usr/src/lib/libavl/i386/lint.out
+usr/src/lib/libavl/i386/llib-lavl.ln
+usr/src/lib/libbe/i386/lint.out
+usr/src/lib/libbe/i386/llib-lbe.ln
+usr/src/lib/libbrand/amd64/lint.out
+usr/src/lib/libbrand/amd64/llib-lbrand.ln
+usr/src/lib/libbrand/i386/lint.out
+usr/src/lib/libbrand/i386/llib-lbrand.ln
+usr/src/lib/libbsdmalloc/amd64/lint.out
+usr/src/lib/libbsdmalloc/amd64/llib-lbsdmalloc.ln
+usr/src/lib/libbsdmalloc/i386/lint.out
+usr/src/lib/libbsdmalloc/i386/llib-lbsdmalloc.ln
+usr/src/lib/libbsm/amd64/lint.out
+usr/src/lib/libbsm/amd64/llib-lbsm.ln
+usr/src/lib/libbsm/audit_uevents.h
+usr/src/lib/libbsm/common/adt_event.h
+usr/src/lib/libbsm/common/adt_xlate.c
+usr/src/lib/libbsm/i386/lint.out
+usr/src/lib/libbsm/i386/llib-lbsm.ln
+usr/src/lib/libc/THIRDPARTYLICENSE
+usr/src/lib/libc/amd64/assym.h
+usr/src/lib/libc/amd64/genassym
+usr/src/lib/libc/amd64/lint.out
+usr/src/lib/libc/amd64/llib-lc.ln
+usr/src/lib/libc/extract-copyright
+usr/src/lib/libc/i386/assym.h
+usr/src/lib/libc/i386/crt/_rtbootld.s
+usr/src/lib/libc/i386/etc/caplib
+usr/src/lib/libc/i386/genassym
+usr/src/lib/libc/i386/lint.out
+usr/src/lib/libc/i386/llib-lc.ln
+usr/src/lib/libc/i386_hwcap1/assym.h
+usr/src/lib/libc/i386_hwcap1/genassym
+usr/src/lib/libc/i386_hwcap2/assym.h
+usr/src/lib/libc/i386_hwcap2/genassym
+usr/src/lib/libc/i386_hwcap3/assym.h
+usr/src/lib/libc/i386_hwcap3/genassym
+usr/src/lib/libc/port/gen/errlst.c
+usr/src/lib/libc/port/gen/new_list.c
+usr/src/lib/libc_db/amd64/lint.out
+usr/src/lib/libc_db/amd64/llib-lc_db.ln
+usr/src/lib/libc_db/i386/lint.out
+usr/src/lib/libc_db/i386/llib-lc_db.ln
+usr/src/lib/libcfgadm/amd64/lint.out
+usr/src/lib/libcfgadm/amd64/llib-lcfgadm.ln
+usr/src/lib/libcfgadm/i386/lint.out
+usr/src/lib/libcfgadm/i386/llib-lcfgadm.ln
+usr/src/lib/libcmd/amd64/libcmd.msg
+usr/src/lib/libcmd/amd64/lint.out
+usr/src/lib/libcmd/amd64/llib-lcmd.ln
+usr/src/lib/libcmd/amd64/msgcc.out
+usr/src/lib/libcmd/amd64/msgs/
+usr/src/lib/libcmd/i386/libcmd.msg
+usr/src/lib/libcmd/i386/lint.out
+usr/src/lib/libcmd/i386/llib-lcmd.ln
+usr/src/lib/libcmd/i386/msgcc.out
+usr/src/lib/libcmd/i386/msgs/
+usr/src/lib/libcmd/tmpastinclude/
+usr/src/lib/libcmdutils/amd64/lint.out
+usr/src/lib/libcmdutils/amd64/llib-lcmdutils.ln
+usr/src/lib/libcmdutils/i386/lint.out
+usr/src/lib/libcmdutils/i386/llib-lcmdutils.ln
+usr/src/lib/libcommputil/amd64/lint.out
+usr/src/lib/libcommputil/amd64/llib-lcommputil.ln
+usr/src/lib/libcommputil/i386/lint.out
+usr/src/lib/libcommputil/i386/llib-lcommputil.ln
+usr/src/lib/libcontract/amd64/lint.out
+usr/src/lib/libcontract/amd64/llib-lcontract.ln
+usr/src/lib/libcontract/i386/lint.out
+usr/src/lib/libcontract/i386/llib-lcontract.ln
+usr/src/lib/libcpc/amd64/lint.out
+usr/src/lib/libcpc/amd64/llib-lcpc.ln
+usr/src/lib/libcpc/i386/lint.out
+usr/src/lib/libcpc/i386/llib-lcpc.ln
+usr/src/lib/libcrypt/amd64/lint.out
+usr/src/lib/libcrypt/amd64/llib-lcrypt.ln
+usr/src/lib/libcrypt/i386/lint.out
+usr/src/lib/libcrypt/i386/llib-lcrypt.ln
+usr/src/lib/libcryptoutil/amd64/lint.out
+usr/src/lib/libcryptoutil/amd64/llib-lcryptoutil.ln
+usr/src/lib/libcryptoutil/i386/lint.out
+usr/src/lib/libcryptoutil/i386/llib-lcryptoutil.ln
+usr/src/lib/libctf/amd64/lint.out
+usr/src/lib/libctf/amd64/llib-lctf.ln
+usr/src/lib/libctf/i386/lint.out
+usr/src/lib/libctf/i386/llib-lctf.ln
+usr/src/lib/libcurses/amd64/lint.out
+usr/src/lib/libcurses/amd64/llib-lcurses.ln
+usr/src/lib/libcurses/i386/lint.out
+usr/src/lib/libcurses/i386/llib-lcurses.ln
+usr/src/lib/libcurses/screen/curses.h
+usr/src/lib/libcurses/screen/keycaps
+usr/src/lib/libcurses/screen/keyname.c
+usr/src/lib/libcurses/screen/term.h
+usr/src/lib/libcurses/screen/termcap.c
+usr/src/lib/libcurses/screen/tifget.c
+usr/src/lib/libcurses/screen/tifnames.c
+usr/src/lib/libcurses/screen/tiget.c
+usr/src/lib/libcurses/screen/tinames.c
+usr/src/lib/libcurses/screen/tmp/
+usr/src/lib/libcurses/screen/tnames.c
+usr/src/lib/libdevice/amd64/lint.out
+usr/src/lib/libdevice/amd64/llib-ldevice.ln
+usr/src/lib/libdevice/i386/lint.out
+usr/src/lib/libdevice/i386/llib-ldevice.ln
+usr/src/lib/libdevid/amd64/lint.out
+usr/src/lib/libdevid/amd64/llib-ldevid.ln
+usr/src/lib/libdevid/i386/lint.out
+usr/src/lib/libdevid/i386/llib-ldevid.ln
+usr/src/lib/libdevinfo/amd64/lint.out
+usr/src/lib/libdevinfo/amd64/llib-ldevinfo.ln
+usr/src/lib/libdevinfo/i386/lint.out
+usr/src/lib/libdevinfo/i386/llib-ldevinfo.ln
+usr/src/lib/libdhcpagent/i386/lint.out
+usr/src/lib/libdhcpagent/i386/llib-ldhcpagent.ln
+usr/src/lib/libdhcpsvc/head/dhcp_svc_confkey.h
+usr/src/lib/libdhcpsvc/modules/files0/i386/ds_SUNWfiles.so.0
+usr/src/lib/libdhcpsvc/private/i386/lint.out
+usr/src/lib/libdhcpsvc/private/i386/llib-ldhcpsvc.ln
+usr/src/lib/libdhcputil/i386/lint.out
+usr/src/lib/libdhcputil/i386/llib-ldhcputil.ln
+usr/src/lib/libdisasm/amd64/lint.out
+usr/src/lib/libdisasm/amd64/llib-ldisasm.ln
+usr/src/lib/libdisasm/i386/lint.out
+usr/src/lib/libdisasm/i386/llib-ldisasm.ln
+usr/src/lib/libdiskmgt/amd64/lint.out
+usr/src/lib/libdiskmgt/amd64/llib-ldiskmgt.ln
+usr/src/lib/libdiskmgt/i386/lint.out
+usr/src/lib/libdiskmgt/i386/llib-ldiskmgt.ln
+usr/src/lib/libdladm/amd64/lint.out
+usr/src/lib/libdladm/amd64/llib-ldladm.ln
+usr/src/lib/libdladm/i386/lint.out
+usr/src/lib/libdladm/i386/llib-ldladm.ln
+usr/src/lib/libdll/amd64/libdll.msg
+usr/src/lib/libdll/amd64/lint.out
+usr/src/lib/libdll/amd64/llib-ldll.ln
+usr/src/lib/libdll/amd64/msgcc.out
+usr/src/lib/libdll/amd64/msgs/
+usr/src/lib/libdll/i386/libdll.msg
+usr/src/lib/libdll/i386/lint.out
+usr/src/lib/libdll/i386/llib-ldll.ln
+usr/src/lib/libdll/i386/msgcc.out
+usr/src/lib/libdll/i386/msgs/
+usr/src/lib/libdll/tmpastinclude/
+usr/src/lib/libdlpi/amd64/lint.out
+usr/src/lib/libdlpi/amd64/llib-ldlpi.ln
+usr/src/lib/libdlpi/i386/lint.out
+usr/src/lib/libdlpi/i386/llib-ldlpi.ln
+usr/src/lib/libdns_sd/amd64/lint.out
+usr/src/lib/libdns_sd/amd64/llib-ldns_sd.ln
+usr/src/lib/libdns_sd/i386/lint.out
+usr/src/lib/libdns_sd/i386/llib-ldns_sd.ln
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleBrowser.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleDNSRecord.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleDNSSD.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleDNSSDException.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleDomainEnum.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleQuery.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleRecordRegistrar.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleRegistration.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleResolver.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/AppleService.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/BaseListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/BrowseListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSRecord.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSSD.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSSD.java.h
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSSDException.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSSDRecordRegistrar.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSSDRegistration.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DNSSDService.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/DomainListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/QueryListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/RegisterListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/RegisterRecordListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/ResolveListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/TXTRecord.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/dnssd.jar
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/BrowserApp$1.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/BrowserApp.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/BrowserApp.jar
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/BrowserListModel$BrowserListElem.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/BrowserListModel.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/DomainListModel.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/ListenerThread.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/ServicesBrowserListModel.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SimpleChat$1.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SimpleChat.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SimpleChat.jar
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SwingBrowseListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SwingDomainListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SwingQueryListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/SwingResolveListener.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/TargetListElem.class
+usr/src/lib/libdns_sd/java/com/apple/dnssd/docs/examples/TargetListModel.class
+usr/src/lib/libdoor/amd64/lint.out
+usr/src/lib/libdoor/amd64/llib-ldoor.ln
+usr/src/lib/libdoor/i386/lint.out
+usr/src/lib/libdoor/i386/llib-ldoor.ln
+usr/src/lib/libdscfg/i386/lint.out
+usr/src/lib/libdscfg/i386/llib-ldscfg.ln
+usr/src/lib/libdtrace/amd64/dt_grammar.c
+usr/src/lib/libdtrace/amd64/dt_grammar.h
+usr/src/lib/libdtrace/amd64/dt_lex.c
+usr/src/lib/libdtrace/amd64/lint.out
+usr/src/lib/libdtrace/amd64/llib-ldtrace.ln
+usr/src/lib/libdtrace/amd64/y.output
+usr/src/lib/libdtrace/common/dt_errtags.c
+usr/src/lib/libdtrace/common/dt_names.c
+usr/src/lib/libdtrace/common/errno.d
+usr/src/lib/libdtrace/common/io.d
+usr/src/lib/libdtrace/common/io.sed
+usr/src/lib/libdtrace/common/ip.d
+usr/src/lib/libdtrace/common/ip.sed
+usr/src/lib/libdtrace/common/net.d
+usr/src/lib/libdtrace/common/net.sed
+usr/src/lib/libdtrace/common/procfs.d
+usr/src/lib/libdtrace/common/procfs.sed
+usr/src/lib/libdtrace/common/signal.d
+usr/src/lib/libdtrace/common/sysevent.d
+usr/src/lib/libdtrace/common/sysevent.sed
+usr/src/lib/libdtrace/common/tcp.d
+usr/src/lib/libdtrace/common/tcp.sed
+usr/src/lib/libdtrace/common/udp.d
+usr/src/lib/libdtrace/common/udp.sed
+usr/src/lib/libdtrace/i386/dt_grammar.c
+usr/src/lib/libdtrace/i386/dt_grammar.h
+usr/src/lib/libdtrace/i386/dt_lex.c
+usr/src/lib/libdtrace/i386/lint.out
+usr/src/lib/libdtrace/i386/llib-ldtrace.ln
+usr/src/lib/libdtrace/i386/regs.d
+usr/src/lib/libdtrace/i386/regs.sed
+usr/src/lib/libdtrace/i386/y.output
+usr/src/lib/libdtrace_jni/java/classes/
+usr/src/lib/libdtrace_jni/java/lib/
+usr/src/lib/libdtrace_jni/java/native/
+usr/src/lib/libefi/amd64/lint.out
+usr/src/lib/libefi/amd64/llib-lefi.ln
+usr/src/lib/libefi/i386/lint.out
+usr/src/lib/libefi/i386/llib-lefi.ln
+usr/src/lib/libelfsign/i386/lint.out
+usr/src/lib/libelfsign/i386/llib-lelfsign.ln
+usr/src/lib/libeti/form/amd64/lint.out
+usr/src/lib/libeti/form/amd64/llib-lform.ln
+usr/src/lib/libeti/form/i386/lint.out
+usr/src/lib/libeti/form/i386/llib-lform.ln
+usr/src/lib/libeti/menu/amd64/lint.out
+usr/src/lib/libeti/menu/amd64/llib-lmenu.ln
+usr/src/lib/libeti/menu/i386/lint.out
+usr/src/lib/libeti/menu/i386/llib-lmenu.ln
+usr/src/lib/libeti/panel/amd64/lint.out
+usr/src/lib/libeti/panel/amd64/llib-lpanel.ln
+usr/src/lib/libeti/panel/i386/lint.out
+usr/src/lib/libeti/panel/i386/llib-lpanel.ln
+usr/src/lib/libexacct/amd64/lint.out
+usr/src/lib/libexacct/amd64/llib-lexacct.ln
+usr/src/lib/libexacct/demo/exdump
+usr/src/lib/libexacct/i386/lint.out
+usr/src/lib/libexacct/i386/llib-lexacct.ln
+usr/src/lib/libfcoe/amd64/lint.out
+usr/src/lib/libfcoe/amd64/llib-lfcoe.ln
+usr/src/lib/libfcoe/i386/lint.out
+usr/src/lib/libfcoe/i386/llib-lfcoe.ln
+usr/src/lib/libfdisk/amd64/lint.out
+usr/src/lib/libfdisk/amd64/llib-lfdisk.ln
+usr/src/lib/libfdisk/i386/lint.out
+usr/src/lib/libfdisk/i386/llib-lfdisk.ln
+usr/src/lib/libfru/amd64/pics/
+usr/src/lib/libfru/i386/pics/
+usr/src/lib/libfsmgt/common/nfs_sec.c
+usr/src/lib/libfsmgt/common/replica.c
+usr/src/lib/libfsmgt/common/sharetab.c
+usr/src/lib/libfsmgt/i386/lint.out
+usr/src/lib/libfsmgt/i386/llib-lfsmgt.ln
+usr/src/lib/libfstyp/i386/lint.out
+usr/src/lib/libfstyp/i386/llib-lfstyp.ln
+usr/src/lib/libgen/amd64/lint.out
+usr/src/lib/libgen/amd64/llib-lgen.ln
+usr/src/lib/libgen/i386/lint.out
+usr/src/lib/libgen/i386/llib-lgen.ln
+usr/src/lib/libgrubmgmt/i386/lint.out
+usr/src/lib/libgrubmgmt/i386/llib-lgrubmgmt.ln
+usr/src/lib/libgss/amd64/lint.out
+usr/src/lib/libgss/amd64/llib-lgss.ln
+usr/src/lib/libgss/i386/lint.out
+usr/src/lib/libgss/i386/llib-lgss.ln
+usr/src/lib/libhotplug/amd64/lint.out
+usr/src/lib/libhotplug/amd64/llib-lhotplug.ln
+usr/src/lib/libhotplug/i386/lint.out
+usr/src/lib/libhotplug/i386/llib-lhotplug.ln
+usr/src/lib/libidmap/amd64/idmap_xdr.c
+usr/src/lib/libidmap/amd64/lint.out
+usr/src/lib/libidmap/amd64/llib-lidmap.ln
+usr/src/lib/libidmap/i386/idmap_xdr.c
+usr/src/lib/libidmap/i386/lint.out
+usr/src/lib/libidmap/i386/llib-lidmap.ln
+usr/src/lib/libilb/amd64/lint.out
+usr/src/lib/libilb/amd64/llib-lilb.ln
+usr/src/lib/libilb/i386/lint.out
+usr/src/lib/libilb/i386/llib-lilb.ln
+usr/src/lib/libima/amd64/lint.out
+usr/src/lib/libima/amd64/llib-lima.ln
+usr/src/lib/libima/i386/lint.out
+usr/src/lib/libima/i386/llib-lima.ln
+usr/src/lib/libinetsvc/i386/lint.out
+usr/src/lib/libinetsvc/i386/llib-linetsvc.ln
+usr/src/lib/libinetutil/amd64/lint.out
+usr/src/lib/libinetutil/amd64/llib-linetutil.ln
+usr/src/lib/libinetutil/i386/lint.out
+usr/src/lib/libinetutil/i386/llib-linetutil.ln
+usr/src/lib/libinstzones/common/zones.i
+usr/src/lib/libinstzones/common/zones_args.i
+usr/src/lib/libinstzones/common/zones_exec.i
+usr/src/lib/libinstzones/common/zones_locks.i
+usr/src/lib/libinstzones/common/zones_lofs.i
+usr/src/lib/libinstzones/common/zones_paths.i
+usr/src/lib/libinstzones/common/zones_states.i
+usr/src/lib/libinstzones/common/zones_str.i
+usr/src/lib/libinstzones/common/zones_utils.i
+usr/src/lib/libinstzones/i386/lint.out
+usr/src/lib/libinstzones/i386/llib-linstzones.ln
+usr/src/lib/libintl/amd64/lint.out
+usr/src/lib/libintl/amd64/llib-lintl.ln
+usr/src/lib/libintl/i386/lint.out
+usr/src/lib/libintl/i386/llib-lintl.ln
+usr/src/lib/libipadm/i386/lint.out
+usr/src/lib/libipadm/i386/llib-lipadm.ln
+usr/src/lib/libipmi/amd64/lint.out
+usr/src/lib/libipmi/amd64/llib-lipmi.ln
+usr/src/lib/libipmi/common/ipmi_tables.c
+usr/src/lib/libipmi/i386/lint.out
+usr/src/lib/libipmi/i386/llib-lipmi.ln
+usr/src/lib/libipmp/i386/lint.out
+usr/src/lib/libipmp/i386/llib-lipmp.ln
+usr/src/lib/libipp/amd64/lint.out
+usr/src/lib/libipp/amd64/llib-lipp.ln
+usr/src/lib/libipp/i386/lint.out
+usr/src/lib/libipp/i386/llib-lipp.ln
+usr/src/lib/libipsecutil/amd64/lint.out
+usr/src/lib/libipsecutil/amd64/llib-lipsecutil.ln
+usr/src/lib/libipsecutil/i386/lint.out
+usr/src/lib/libipsecutil/i386/llib-lipsecutil.ln
+usr/src/lib/libiscsit/amd64/lint.out
+usr/src/lib/libiscsit/amd64/llib-liscsit.ln
+usr/src/lib/libiscsit/i386/lint.out
+usr/src/lib/libiscsit/i386/llib-liscsit.ln
+usr/src/lib/libkmf/THIRDPARTYLICENSE
+usr/src/lib/libkmf/ber_der/amd64/lint.out
+usr/src/lib/libkmf/ber_der/amd64/llib-lkmfberder.ln
+usr/src/lib/libkmf/ber_der/i386/lint.out
+usr/src/lib/libkmf/ber_der/i386/llib-lkmfberder.ln
+usr/src/lib/libkmf/libkmf/amd64/lint.out
+usr/src/lib/libkmf/libkmf/amd64/llib-lkmf.ln
+usr/src/lib/libkmf/libkmf/i386/lint.out
+usr/src/lib/libkmf/libkmf/i386/llib-lkmf.ln
+usr/src/lib/libkstat/amd64/lint.out
+usr/src/lib/libkstat/amd64/llib-lkstat.ln
+usr/src/lib/libkstat/i386/lint.out
+usr/src/lib/libkstat/i386/llib-lkstat.ln
+usr/src/lib/libkvm/amd64/lint.out
+usr/src/lib/libkvm/amd64/llib-lkvm.ln
+usr/src/lib/libkvm/i386/lint.out
+usr/src/lib/libkvm/i386/llib-lkvm.ln
+usr/src/lib/libldap4/amd64/libldap.so.4
+usr/src/lib/libldap4/i386/libldap.so.4
+usr/src/lib/libldap5/amd64/libldap.so.5
+usr/src/lib/libldap5/amd64/lint.out
+usr/src/lib/libldap5/amd64/llib-lldap.ln
+usr/src/lib/libldap5/i386/libldap.so.5
+usr/src/lib/libldap5/i386/lint.out
+usr/src/lib/libldap5/i386/llib-lldap.ln
+usr/src/lib/liblgrp/amd64/lint.out
+usr/src/lib/liblgrp/amd64/llib-llgrp.ln
+usr/src/lib/liblgrp/i386/lint.out
+usr/src/lib/liblgrp/i386/llib-llgrp.ln
+usr/src/lib/libmail/amd64/lint.out
+usr/src/lib/libmail/amd64/llib-lmail.ln
+usr/src/lib/libmail/i386/lint.out
+usr/src/lib/libmail/i386/llib-lmail.ln
+usr/src/lib/libmalloc/amd64/lint.out
+usr/src/lib/libmalloc/amd64/llib-lmalloc.ln
+usr/src/lib/libmalloc/i386/lint.out
+usr/src/lib/libmalloc/i386/llib-lmalloc.ln
+usr/src/lib/libmapid/i386/lint.out
+usr/src/lib/libmapid/i386/llib-lmapid.ln
+usr/src/lib/libmapmalloc/amd64/lint.out
+usr/src/lib/libmapmalloc/amd64/llib-lmapmalloc.ln
+usr/src/lib/libmapmalloc/i386/lint.out
+usr/src/lib/libmapmalloc/i386/llib-lmapmalloc.ln
+usr/src/lib/libmd/amd64/lint.out
+usr/src/lib/libmd/amd64/llib-lmd.ln
+usr/src/lib/libmd/amd64/md5_amd64.s
+usr/src/lib/libmd/amd64/sha1-x86_64.s
+usr/src/lib/libmd/amd64/sha256-x86_64.s
+usr/src/lib/libmd/amd64/sha512-x86_64.s
+usr/src/lib/libmd/i386/lint.out
+usr/src/lib/libmd/i386/llib-lmd.ln
+usr/src/lib/libmd5/amd64/lint.out
+usr/src/lib/libmd5/amd64/llib-lmd5.ln
+usr/src/lib/libmd5/i386/lint.out
+usr/src/lib/libmd5/i386/llib-lmd5.ln
+usr/src/lib/libmp/amd64/libmp.so.2
+usr/src/lib/libmp/i386/libmp.so.2
+usr/src/lib/libmtmalloc/amd64/lint.out
+usr/src/lib/libmtmalloc/amd64/llib-lmtmalloc.ln
+usr/src/lib/libmtmalloc/i386/lint.out
+usr/src/lib/libmtmalloc/i386/llib-lmtmalloc.ln
+usr/src/lib/libndmp/amd64/lint.out
+usr/src/lib/libndmp/amd64/llib-lndmp.ln
+usr/src/lib/libndmp/i386/lint.out
+usr/src/lib/libndmp/i386/llib-lndmp.ln
+usr/src/lib/libnisdb/db.h
+usr/src/lib/libnisdb/db_c.h
+usr/src/lib/libnisdb/db_c_xdr.c
+usr/src/lib/libnisdb/db_dictionary.h
+usr/src/lib/libnisdb/db_dictionary_c.h
+usr/src/lib/libnisdb/db_dictionary_c_xdr.c
+usr/src/lib/libnisdb/db_dictlog.h
+usr/src/lib/libnisdb/db_dictlog_c.h
+usr/src/lib/libnisdb/db_dictlog_c_xdr.c
+usr/src/lib/libnisdb/db_entry.h
+usr/src/lib/libnisdb/db_entry_c.h
+usr/src/lib/libnisdb/db_entry_c_xdr.c
+usr/src/lib/libnisdb/db_index.h
+usr/src/lib/libnisdb/db_index_c.h
+usr/src/lib/libnisdb/db_index_c_xdr.c
+usr/src/lib/libnisdb/db_index_entry.h
+usr/src/lib/libnisdb/db_index_entry_c.h
+usr/src/lib/libnisdb/db_index_entry_c_xdr.c
+usr/src/lib/libnisdb/db_item.h
+usr/src/lib/libnisdb/db_item_c.h
+usr/src/lib/libnisdb/db_item_c_xdr.c
+usr/src/lib/libnisdb/db_log.h
+usr/src/lib/libnisdb/db_log_c.h
+usr/src/lib/libnisdb/db_log_c_xdr.c
+usr/src/lib/libnisdb/db_log_entry.h
+usr/src/lib/libnisdb/db_log_entry_c.h
+usr/src/lib/libnisdb/db_log_entry_c_xdr.c
+usr/src/lib/libnisdb/db_mindex.h
+usr/src/lib/libnisdb/db_mindex_c.h
+usr/src/lib/libnisdb/db_mindex_c_xdr.c
+usr/src/lib/libnisdb/db_query.h
+usr/src/lib/libnisdb/db_query_c.h
+usr/src/lib/libnisdb/db_query_c_xdr.c
+usr/src/lib/libnisdb/db_scheme.h
+usr/src/lib/libnisdb/db_scheme_c.h
+usr/src/lib/libnisdb/db_scheme_c_xdr.c
+usr/src/lib/libnisdb/db_table.h
+usr/src/lib/libnisdb/db_table_c.h
+usr/src/lib/libnisdb/db_table_c_xdr.c
+usr/src/lib/libnisdb/db_vers.h
+usr/src/lib/libnisdb/db_vers_c.h
+usr/src/lib/libnisdb/db_vers_c_xdr.c
+usr/src/lib/libnisdb/libnisdb.so.2
+usr/src/lib/libnls/amd64/lint.out
+usr/src/lib/libnls/amd64/llib-lnls.ln
+usr/src/lib/libnls/i386/lint.out
+usr/src/lib/libnls/i386/llib-lnls.ln
+usr/src/lib/libnsctl/i386/lint.out
+usr/src/lib/libnsctl/i386/llib-lnsctl.ln
+usr/src/lib/libnsl/amd64/lint.out
+usr/src/lib/libnsl/amd64/llib-lnsl.ln
+usr/src/lib/libnsl/i386/lint.out
+usr/src/lib/libnsl/i386/llib-lnsl.ln
+usr/src/lib/libnsl/nis/gen/nis_clnt.h
+usr/src/lib/libntfs/THIRDPARTYLICENSE
+usr/src/lib/libntfs/i386/libntfs.so.10
+usr/src/lib/libnvpair/amd64/lint.out
+usr/src/lib/libnvpair/amd64/llib-lnvpair.ln
+usr/src/lib/libnvpair/i386/lint.out
+usr/src/lib/libnvpair/i386/llib-lnvpair.ln
+usr/src/lib/libnwam/i386/lint.out
+usr/src/lib/libnwam/i386/llib-lnwam.ln
+usr/src/lib/libpam/amd64/lint.out
+usr/src/lib/libpam/amd64/llib-lpam.ln
+usr/src/lib/libpam/i386/lint.out
+usr/src/lib/libpam/i386/llib-lpam.ln
+usr/src/lib/libparted/THIRDPARTYLICENSE
+usr/src/lib/libparted/i386/libparted.so.8
+usr/src/lib/libpctx/amd64/lint.out
+usr/src/lib/libpctx/amd64/llib-lpctx.ln
+usr/src/lib/libpctx/i386/lint.out
+usr/src/lib/libpctx/i386/llib-lpctx.ln
+usr/src/lib/libpicl/amd64/lint.out
+usr/src/lib/libpicl/amd64/llib-lpicl.ln
+usr/src/lib/libpicl/i386/lint.out
+usr/src/lib/libpicl/i386/llib-lpicl.ln
+usr/src/lib/libpicltree/i386/lint.out
+usr/src/lib/libpicltree/i386/llib-lpicltree.ln
+usr/src/lib/libpkg/common/canonize.i
+usr/src/lib/libpkg/common/ckparam.i
+usr/src/lib/libpkg/common/ckvolseq.i
+usr/src/lib/libpkg/common/devtype.i
+usr/src/lib/libpkg/common/dstream.i
+usr/src/lib/libpkg/common/fmkdir.i
+usr/src/lib/libpkg/common/gpkglist.i
+usr/src/lib/libpkg/common/gpkgmap.i
+usr/src/lib/libpkg/common/handlelocalfs.i
+usr/src/lib/libpkg/common/isdir.i
+usr/src/lib/libpkg/common/keystore.i
+usr/src/lib/libpkg/common/logerr.i
+usr/src/lib/libpkg/common/mappath.i
+usr/src/lib/libpkg/common/ncgrpw.i
+usr/src/lib/libpkg/common/nhash.i
+usr/src/lib/libpkg/common/p12lib.i
+usr/src/lib/libpkg/common/pkgerr.i
+usr/src/lib/libpkg/common/pkgexecl.i
+usr/src/lib/libpkg/common/pkgexecv.i
+usr/src/lib/libpkg/common/pkgmount.i
+usr/src/lib/libpkg/common/pkgserv.i
+usr/src/lib/libpkg/common/pkgstr.i
+usr/src/lib/libpkg/common/pkgtrans.i
+usr/src/lib/libpkg/common/pkgweb.i
+usr/src/lib/libpkg/common/ppkgmap.i
+usr/src/lib/libpkg/common/progerr.i
+usr/src/lib/libpkg/common/putcfile.i
+usr/src/lib/libpkg/common/rrmdir.i
+usr/src/lib/libpkg/common/runcmd.i
+usr/src/lib/libpkg/common/security.i
+usr/src/lib/libpkg/common/srchcfile.i
+usr/src/lib/libpkg/common/tputcfent.i
+usr/src/lib/libpkg/common/verify.i
+usr/src/lib/libpkg/common/vfpops.i
+usr/src/lib/libpkg/i386/lint.out
+usr/src/lib/libpkg/i386/llib-lpkg.ln
+usr/src/lib/libpool/amd64/lint.out
+usr/src/lib/libpool/amd64/llib-lpool.ln
+usr/src/lib/libpool/i386/lint.out
+usr/src/lib/libpool/i386/llib-lpool.ln
+usr/src/lib/libpp/i386/libpp.msg
+usr/src/lib/libpp/i386/lint.out
+usr/src/lib/libpp/i386/llib-lpp.ln
+usr/src/lib/libpp/i386/msgcc.out
+usr/src/lib/libpp/i386/msgs/
+usr/src/lib/libpp/tmpastinclude/
+usr/src/lib/libproc/amd64/lint.out
+usr/src/lib/libproc/amd64/llib-lproc.ln
+usr/src/lib/libproc/i386/lint.out
+usr/src/lib/libproc/i386/llib-lproc.ln
+usr/src/lib/libproject/amd64/lint.out
+usr/src/lib/libproject/amd64/llib-lproject.ln
+usr/src/lib/libproject/i386/lint.out
+usr/src/lib/libproject/i386/llib-lproject.ln
+usr/src/lib/libpthread/amd64/lint.out
+usr/src/lib/libpthread/amd64/llib-lpthread.ln
+usr/src/lib/libpthread/i386/lint.out
+usr/src/lib/libpthread/i386/llib-lpthread.ln
+usr/src/lib/libraidcfg/amd64/lint.out
+usr/src/lib/libraidcfg/amd64/llib-lraidcfg.ln
+usr/src/lib/libraidcfg/i386/lint.out
+usr/src/lib/libraidcfg/i386/llib-lraidcfg.ln
+usr/src/lib/librcm/amd64/lint.out
+usr/src/lib/librcm/amd64/llib-lrcm.ln
+usr/src/lib/librcm/i386/lint.out
+usr/src/lib/librcm/i386/llib-lrcm.ln
+usr/src/lib/librdc/i386/lint.out
+usr/src/lib/librdc/i386/llib-lrdc.ln
+usr/src/lib/libreparse/amd64/lint.out
+usr/src/lib/libreparse/amd64/llib-lreparse.ln
+usr/src/lib/libreparse/i386/lint.out
+usr/src/lib/libreparse/i386/llib-lreparse.ln
+usr/src/lib/libresolv2/amd64/libresolv.so.2
+usr/src/lib/libresolv2/amd64/lint.out
+usr/src/lib/libresolv2/amd64/llib-lresolv.ln
+usr/src/lib/libresolv2/i386/libresolv.so.2
+usr/src/lib/libresolv2/i386/lint.out
+usr/src/lib/libresolv2/i386/llib-lresolv.ln
+usr/src/lib/libresolv2/include/make_os_version
+usr/src/lib/libresolv2/include/os_version.h
+usr/src/lib/libresolv2/include/port_ipv6.h
+usr/src/lib/libresolv2/include/probe_ipv6
+usr/src/lib/libresolv2_joy/amd64/libresolv_joy.so.2
+usr/src/lib/libresolv2_joy/amd64/lint.out
+usr/src/lib/libresolv2_joy/amd64/llib-lresolv_joy.ln
+usr/src/lib/libresolv2_joy/i386/libresolv_joy.so.2
+usr/src/lib/libresolv2_joy/i386/lint.out
+usr/src/lib/libresolv2_joy/i386/llib-lresolv_joy.ln
+usr/src/lib/libresolv2_joy/include/make_os_version
+usr/src/lib/libresolv2_joy/include/os_version.h
+usr/src/lib/libresolv2_joy/include/port_ipv6.h
+usr/src/lib/libresolv2_joy/include/probe_ipv6
+usr/src/lib/librestart/amd64/lint.out
+usr/src/lib/librestart/amd64/llib-lrestart.ln
+usr/src/lib/librestart/i386/lint.out
+usr/src/lib/librestart/i386/llib-lrestart.ln
+usr/src/lib/librpcsvc/amd64/lint.out
+usr/src/lib/librpcsvc/amd64/llib-lrpcsvc.ln
+usr/src/lib/librpcsvc/common/bootparam_prot_xdr.c
+usr/src/lib/librpcsvc/common/mount_xdr.c
+usr/src/lib/librpcsvc/common/nlm_prot.c
+usr/src/lib/librpcsvc/common/nsm_addr_xdr.c
+usr/src/lib/librpcsvc/common/rpc_sztypes.c
+usr/src/lib/librpcsvc/common/rstat_xdr.c
+usr/src/lib/librpcsvc/common/rusers_xdr.c
+usr/src/lib/librpcsvc/common/sm_inter_xdr.c
+usr/src/lib/librpcsvc/common/spray_xdr.c
+usr/src/lib/librpcsvc/i386/lint.out
+usr/src/lib/librpcsvc/i386/llib-lrpcsvc.ln
+usr/src/lib/librsm/amd64/librsm.so.2
+usr/src/lib/librsm/i386/librsm.so.2
+usr/src/lib/librstp/i386/lint.out
+usr/src/lib/librstp/i386/llib-lrstp.ln
+usr/src/lib/librt/amd64/lint.out
+usr/src/lib/librt/amd64/llib-lrt.ln
+usr/src/lib/librt/i386/lint.out
+usr/src/lib/librt/i386/llib-lrt.ln
+usr/src/lib/libsasl/THIRDPARTYLICENSE
+usr/src/lib/libsasl/amd64/lint.out
+usr/src/lib/libsasl/amd64/llib-lsasl.ln
+usr/src/lib/libsasl/i386/lint.out
+usr/src/lib/libsasl/i386/llib-lsasl.ln
+usr/src/lib/libscf/amd64/lint.out
+usr/src/lib/libscf/amd64/llib-lscf.ln
+usr/src/lib/libscf/i386/lint.out
+usr/src/lib/libscf/i386/llib-lscf.ln
+usr/src/lib/libsched/amd64/lint.out
+usr/src/lib/libsched/amd64/llib-lsched.ln
+usr/src/lib/libsched/i386/lint.out
+usr/src/lib/libsched/i386/llib-lsched.ln
+usr/src/lib/libsctp/amd64/lint.out
+usr/src/lib/libsctp/amd64/llib-lsctp.ln
+usr/src/lib/libsctp/i386/lint.out
+usr/src/lib/libsctp/i386/llib-lsctp.ln
+usr/src/lib/libsec/amd64/acl.output
+usr/src/lib/libsec/amd64/acl.tab.c
+usr/src/lib/libsec/amd64/acl.tab.h
+usr/src/lib/libsec/amd64/acl_lex.c
+usr/src/lib/libsec/amd64/lint.out
+usr/src/lib/libsec/amd64/llib-lsec.ln
+usr/src/lib/libsec/i386/acl.output
+usr/src/lib/libsec/i386/acl.tab.c
+usr/src/lib/libsec/i386/acl.tab.h
+usr/src/lib/libsec/i386/acl_lex.c
+usr/src/lib/libsec/i386/lint.out
+usr/src/lib/libsec/i386/llib-lsec.ln
+usr/src/lib/libsecdb/amd64/lint.out
+usr/src/lib/libsecdb/amd64/llib-lsecdb.ln
+usr/src/lib/libsecdb/auth_attr
+usr/src/lib/libsecdb/exec_attr
+usr/src/lib/libsecdb/i386/lint.out
+usr/src/lib/libsecdb/i386/llib-lsecdb.ln
+usr/src/lib/libsecdb/prof_attr
+usr/src/lib/libsecdb/user_attr
+usr/src/lib/libsendfile/amd64/lint.out
+usr/src/lib/libsendfile/amd64/llib-lsendfile.ln
+usr/src/lib/libsendfile/i386/lint.out
+usr/src/lib/libsendfile/i386/llib-lsendfile.ln
+usr/src/lib/libshare/amd64/lint.out
+usr/src/lib/libshare/amd64/llib-lshare.ln
+usr/src/lib/libshare/i386/lint.out
+usr/src/lib/libshare/i386/llib-lshare.ln
+usr/src/lib/libshell/amd64/libshell.msg
+usr/src/lib/libshell/amd64/lint.out
+usr/src/lib/libshell/amd64/llib-lshell.ln
+usr/src/lib/libshell/amd64/msgcc.out
+usr/src/lib/libshell/amd64/msgs/
+usr/src/lib/libshell/i386/libshell.msg
+usr/src/lib/libshell/i386/lint.out
+usr/src/lib/libshell/i386/llib-lshell.ln
+usr/src/lib/libshell/i386/msgcc.out
+usr/src/lib/libshell/i386/msgs/
+usr/src/lib/libshell/tmpastinclude/
+usr/src/lib/libshell/xsltproc.log
+usr/src/lib/libsip/amd64/lint.out
+usr/src/lib/libsip/amd64/llib-lsip.ln
+usr/src/lib/libsip/i386/lint.out
+usr/src/lib/libsip/i386/llib-lsip.ln
+usr/src/lib/libsldap/amd64/lint.out
+usr/src/lib/libsldap/amd64/llib-lsldap.ln
+usr/src/lib/libsldap/i386/lint.out
+usr/src/lib/libsldap/i386/llib-lsldap.ln
+usr/src/lib/libslp/amd64/lint.out
+usr/src/lib/libslp/amd64/llib-lslp.ln
+usr/src/lib/libslp/classes/
+usr/src/lib/libslp/i386/lint.out
+usr/src/lib/libslp/i386/llib-lslp.ln
+usr/src/lib/libsmartsshd/amd64/lint.out
+usr/src/lib/libsmartsshd/amd64/llib-lsmartsshd.ln
+usr/src/lib/libsmartsshd/i386/lint.out
+usr/src/lib/libsmartsshd/i386/llib-lsmartsshd.ln
+usr/src/lib/libsmbfs/amd64/lint.out
+usr/src/lib/libsmbfs/amd64/llib-lsmbfs.ln
+usr/src/lib/libsmbfs/i386/lint.out
+usr/src/lib/libsmbfs/i386/llib-lsmbfs.ln
+usr/src/lib/libsmbios/amd64/lint.out
+usr/src/lib/libsmbios/amd64/llib-lsmbios.ln
+usr/src/lib/libsmbios/common/smb_tables.c
+usr/src/lib/libsmbios/i386/lint.out
+usr/src/lib/libsmbios/i386/llib-lsmbios.ln
+usr/src/lib/libsmedia/library/amd64/lint.out
+usr/src/lib/libsmedia/library/amd64/llib-lsmedia.ln
+usr/src/lib/libsmedia/library/common/smed.h
+usr/src/lib/libsmedia/library/common/smed_clnt.c
+usr/src/lib/libsmedia/library/common/smed_xdr.c
+usr/src/lib/libsmedia/library/i386/lint.out
+usr/src/lib/libsmedia/library/i386/llib-lsmedia.ln
+usr/src/lib/libsocket/amd64/lint.out
+usr/src/lib/libsocket/amd64/llib-lsocket.ln
+usr/src/lib/libsocket/i386/lint.out
+usr/src/lib/libsocket/i386/llib-lsocket.ln
+usr/src/lib/libsqlite/i386/lemon
+usr/src/lib/libsqlite/i386/lemon-build
+usr/src/lib/libsqlite/i386/lempar.c
+usr/src/lib/libsqlite/i386/lint.out
+usr/src/lib/libsqlite/i386/llib-lsqlite.ln
+usr/src/lib/libsqlite/i386/opcodes.c
+usr/src/lib/libsqlite/i386/opcodes.h
+usr/src/lib/libsqlite/i386/parse.c
+usr/src/lib/libsqlite/i386/parse.h
+usr/src/lib/libsqlite/i386/parse_tmp.c
+usr/src/lib/libsqlite/i386/parse_tmp.h
+usr/src/lib/libsqlite/i386/parse_tmp.out
+usr/src/lib/libsqlite/i386/parse_tmp.y
+usr/src/lib/libsqlite/sqlite.h
+usr/src/lib/libsrpt/amd64/lint.out
+usr/src/lib/libsrpt/amd64/llib-lsrpt.ln
+usr/src/lib/libsrpt/i386/lint.out
+usr/src/lib/libsrpt/i386/llib-lsrpt.ln
+usr/src/lib/libstmf/amd64/lint.out
+usr/src/lib/libstmf/amd64/llib-lstmf.ln
+usr/src/lib/libstmf/i386/lint.out
+usr/src/lib/libstmf/i386/llib-lstmf.ln
+usr/src/lib/libstmfproxy/amd64/lint.out
+usr/src/lib/libstmfproxy/amd64/llib-lstmfproxy.ln
+usr/src/lib/libstmfproxy/i386/lint.out
+usr/src/lib/libstmfproxy/i386/llib-lstmfproxy.ln
+usr/src/lib/libsum/amd64/libsum.msg
+usr/src/lib/libsum/amd64/lint.out
+usr/src/lib/libsum/amd64/llib-lsum.ln
+usr/src/lib/libsum/amd64/msgcc.out
+usr/src/lib/libsum/amd64/msgs/
+usr/src/lib/libsum/i386/libsum.msg
+usr/src/lib/libsum/i386/lint.out
+usr/src/lib/libsum/i386/llib-lsum.ln
+usr/src/lib/libsum/i386/msgcc.out
+usr/src/lib/libsum/i386/msgs/
+usr/src/lib/libsum/tmpastinclude/
+usr/src/lib/libsun_ima/amd64/lint.out
+usr/src/lib/libsun_ima/amd64/llib-lsun_ima.ln
+usr/src/lib/libsun_ima/i386/lint.out
+usr/src/lib/libsun_ima/i386/llib-lsun_ima.ln
+usr/src/lib/libsys/i386/libsys.c
+usr/src/lib/libsysevent/amd64/lint.out
+usr/src/lib/libsysevent/amd64/llib-lsysevent.ln
+usr/src/lib/libsysevent/i386/lint.out
+usr/src/lib/libsysevent/i386/llib-lsysevent.ln
+usr/src/lib/libtecla/amd64/lint.out
+usr/src/lib/libtecla/amd64/llib-ltecla.ln
+usr/src/lib/libtecla/i386/lint.out
+usr/src/lib/libtecla/i386/llib-ltecla.ln
+usr/src/lib/libthread/amd64/lint.out
+usr/src/lib/libthread/amd64/llib-lthread.ln
+usr/src/lib/libthread/i386/lint.out
+usr/src/lib/libthread/i386/llib-lthread.ln
+usr/src/lib/libtsnet/amd64/lint.out
+usr/src/lib/libtsnet/amd64/llib-ltsnet.ln
+usr/src/lib/libtsnet/i386/lint.out
+usr/src/lib/libtsnet/i386/llib-ltsnet.ln
+usr/src/lib/libtsol/amd64/libtsol.so.2
+usr/src/lib/libtsol/amd64/lint.out
+usr/src/lib/libtsol/amd64/llib-ltsol.ln
+usr/src/lib/libtsol/i386/libtsol.so.2
+usr/src/lib/libtsol/i386/lint.out
+usr/src/lib/libtsol/i386/llib-ltsol.ln
+usr/src/lib/libumem/amd64/lint.out
+usr/src/lib/libumem/amd64/llib-lumem.ln
+usr/src/lib/libumem/i386/lint.out
+usr/src/lib/libumem/i386/llib-lumem.ln
+usr/src/lib/libunistat/common/dsw/dsw.dtrnk
+usr/src/lib/libunistat/common/dsw/dsw.edef
+usr/src/lib/libunistat/common/dsw/dsw.msg
+usr/src/lib/libunistat/common/dsw/dsw.trnk
+usr/src/lib/libunistat/common/rdc/rdc.dtrnk
+usr/src/lib/libunistat/common/rdc/rdc.edef
+usr/src/lib/libunistat/common/rdc/rdc.msg
+usr/src/lib/libunistat/common/rdc/rdc.trnk
+usr/src/lib/libunistat/common/sdbc/sdbc.dtrnk
+usr/src/lib/libunistat/common/sdbc/sdbc.edef
+usr/src/lib/libunistat/common/sdbc/sdbc.msg
+usr/src/lib/libunistat/common/sdbc/sdbc.trnk
+usr/src/lib/libunistat/common/solaris/solaris.dtrnk
+usr/src/lib/libunistat/common/solaris/solaris.edef
+usr/src/lib/libunistat/common/solaris/solaris.msg
+usr/src/lib/libunistat/common/solaris/solaris.trnk
+usr/src/lib/libunistat/common/spcs/spcs.dtrnk
+usr/src/lib/libunistat/common/spcs/spcs.edef
+usr/src/lib/libunistat/common/spcs/spcs.msg
+usr/src/lib/libunistat/common/spcs/spcs.trnk
+usr/src/lib/libunistat/common/sv/sv.dtrnk
+usr/src/lib/libunistat/common/sv/sv.edef
+usr/src/lib/libunistat/common/sv/sv.msg
+usr/src/lib/libunistat/common/sv/sv.trnk
+usr/src/lib/libunistat/i386/lint.out
+usr/src/lib/libunistat/i386/llib-lunistat.ln
+usr/src/lib/libunistat/i386/spcs_dtrinkets.h
+usr/src/lib/libunistat/i386/spcs_errors.h
+usr/src/lib/libunistat/i386/spcs_etext.h
+usr/src/lib/libunistat/i386/spcs_etrinkets.h
+usr/src/lib/libuuid/amd64/lint.out
+usr/src/lib/libuuid/amd64/llib-luuid.ln
+usr/src/lib/libuuid/i386/lint.out
+usr/src/lib/libuuid/i386/llib-luuid.ln
+usr/src/lib/libuutil/amd64/lint.out
+usr/src/lib/libuutil/amd64/llib-luutil.ln
+usr/src/lib/libuutil/i386/lint.out
+usr/src/lib/libuutil/i386/llib-luutil.ln
+usr/src/lib/libuutil/native/sys/
+usr/src/lib/libvolmgt/amd64/lint.out
+usr/src/lib/libvolmgt/amd64/llib-lvolmgt.ln
+usr/src/lib/libvolmgt/i386/lint.out
+usr/src/lib/libvolmgt/i386/llib-lvolmgt.ln
+usr/src/lib/libvrrpadm/amd64/lint.out
+usr/src/lib/libvrrpadm/amd64/llib-lvrrpadm.ln
+usr/src/lib/libvrrpadm/i386/lint.out
+usr/src/lib/libvrrpadm/i386/llib-lvrrpadm.ln
+usr/src/lib/libvscan/i386/lint.out
+usr/src/lib/libvscan/i386/llib-lvscan.ln
+usr/src/lib/libwanboot/i386/lint.out
+usr/src/lib/libwanboot/i386/llib-lwanboot.ln
+usr/src/lib/libwanbootutil/common/key_xdr.c
+usr/src/lib/libwanbootutil/common/key_xdr.h
+usr/src/lib/libwanbootutil/i386/lint.out
+usr/src/lib/libwanbootutil/i386/llib-lwanbootutil.ln
+usr/src/lib/libwrap/THIRDPARTYLICENSE
+usr/src/lib/libwrap/i386/libwrap.so.1.0
+usr/src/lib/libwrap/i386/lint.out
+usr/src/lib/libwrap/i386/llib-lwrap.ln
+usr/src/lib/libxcurses/h/term.h
+usr/src/lib/libxcurses/src/libc/xcurses/boolcode.c
+usr/src/lib/libxcurses/src/libc/xcurses/boolfnam.c
+usr/src/lib/libxcurses/src/libc/xcurses/boolname.c
+usr/src/lib/libxcurses/src/libc/xcurses/keyindex.c
+usr/src/lib/libxcurses/src/libc/xcurses/numcode.c
+usr/src/lib/libxcurses/src/libc/xcurses/numfnam.c
+usr/src/lib/libxcurses/src/libc/xcurses/numname.c
+usr/src/lib/libxcurses/src/libc/xcurses/strcode.c
+usr/src/lib/libxcurses/src/libc/xcurses/strfnam.c
+usr/src/lib/libxcurses/src/libc/xcurses/strname.c
+usr/src/lib/libxcurses2/amd64/libcurses.so.2
+usr/src/lib/libxcurses2/amd64/lint.out
+usr/src/lib/libxcurses2/amd64/llib-lcurses.ln
+usr/src/lib/libxcurses2/h/term.h
+usr/src/lib/libxcurses2/i386/libcurses.so.2
+usr/src/lib/libxcurses2/i386/lint.out
+usr/src/lib/libxcurses2/i386/llib-lcurses.ln
+usr/src/lib/libxcurses2/src/libc/xcurses/boolcode.c
+usr/src/lib/libxcurses2/src/libc/xcurses/boolfnam.c
+usr/src/lib/libxcurses2/src/libc/xcurses/boolname.c
+usr/src/lib/libxcurses2/src/libc/xcurses/keyindex.c
+usr/src/lib/libxcurses2/src/libc/xcurses/numcode.c
+usr/src/lib/libxcurses2/src/libc/xcurses/numfnam.c
+usr/src/lib/libxcurses2/src/libc/xcurses/numname.c
+usr/src/lib/libxcurses2/src/libc/xcurses/strcode.c
+usr/src/lib/libxcurses2/src/libc/xcurses/strfnam.c
+usr/src/lib/libxcurses2/src/libc/xcurses/strname.c
+usr/src/lib/libxnet/amd64/lint.out
+usr/src/lib/libxnet/amd64/llib-lxnet.ln
+usr/src/lib/libxnet/i386/lint.out
+usr/src/lib/libxnet/i386/llib-lxnet.ln
+usr/src/lib/libzdoor/amd64/lint.out
+usr/src/lib/libzdoor/amd64/llib-lzdoor.ln
+usr/src/lib/libzdoor/i386/lint.out
+usr/src/lib/libzdoor/i386/llib-lzdoor.ln
+usr/src/lib/libzfs/amd64/lint.out
+usr/src/lib/libzfs/amd64/llib-lzfs.ln
+usr/src/lib/libzfs/i386/lint.out
+usr/src/lib/libzfs/i386/llib-lzfs.ln
+usr/src/lib/libzfs_jni/amd64/lint.out
+usr/src/lib/libzfs_jni/amd64/llib-lzfs_jni.ln
+usr/src/lib/libzfs_jni/i386/lint.out
+usr/src/lib/libzfs_jni/i386/llib-lzfs_jni.ln
+usr/src/lib/libzonecfg/amd64/lint.out
+usr/src/lib/libzonecfg/amd64/llib-lzonecfg.ln
+usr/src/lib/libzonecfg/i386/lint.out
+usr/src/lib/libzonecfg/i386/llib-lzonecfg.ln
+usr/src/lib/libzoneinfo/i386/lint.out
+usr/src/lib/libzoneinfo/i386/llib-lzoneinfo.ln
+usr/src/lib/libzonestat/amd64/lint.out
+usr/src/lib/libzonestat/amd64/llib-lzonestat.ln
+usr/src/lib/libzonestat/i386/lint.out
+usr/src/lib/libzonestat/i386/llib-lzonestat.ln
+usr/src/lib/libzpool/amd64/lint.out
+usr/src/lib/libzpool/amd64/llib-lzpool.ln
+usr/src/lib/libzpool/i386/lint.out
+usr/src/lib/libzpool/i386/llib-lzpool.ln
+usr/src/lib/mpapi/libmpapi/amd64/lint.out
+usr/src/lib/mpapi/libmpapi/amd64/llib-lMPAPI.ln
+usr/src/lib/mpapi/libmpapi/i386/lint.out
+usr/src/lib/mpapi/libmpapi/i386/llib-lMPAPI.ln
+usr/src/lib/nametoaddr/straddr/amd64/straddr.so.2
+usr/src/lib/nametoaddr/straddr/i386/straddr.so.2
+usr/src/lib/passwdutil/amd64/lint.out
+usr/src/lib/passwdutil/amd64/llib-lpasswdutil.ln
+usr/src/lib/passwdutil/i386/lint.out
+usr/src/lib/passwdutil/i386/llib-lpasswdutil.ln
+usr/src/lib/pkcs11/libkcfd/i386/lint.out
+usr/src/lib/pkcs11/libkcfd/i386/llib-lkcfd.ln
+usr/src/lib/pkcs11/libpkcs11/amd64/lint.out
+usr/src/lib/pkcs11/libpkcs11/amd64/llib-lpkcs11.ln
+usr/src/lib/pkcs11/libpkcs11/i386/lint.out
+usr/src/lib/pkcs11/libpkcs11/i386/llib-lpkcs11.ln
+usr/src/lib/pkcs11/libsoftcrypto/amd64/arcfour-x86_64.s
+usr/src/lib/pkcs11/libsoftcrypto/amd64/lint.out
+usr/src/lib/pkcs11/libsoftcrypto/amd64/llib-lsoftcrypto.ln
+usr/src/lib/pkcs11/libsoftcrypto/i386/lint.out
+usr/src/lib/pkcs11/libsoftcrypto/i386/llib-lsoftcrypto.ln
+usr/src/lib/policykit/libpolkit/i386/libpolkit.so.0.0.0
+usr/src/lib/policykit/libpolkit/i386/lint.out
+usr/src/lib/policykit/libpolkit/i386/llib-lpolkit.ln
+usr/src/lib/policykit/libpolkit/i386/polkit.pc
+usr/src/lib/sasl_plugins/gssapi/THIRDPARTYLICENSE
+usr/src/lib/scsi/libscsi/amd64/lint.out
+usr/src/lib/scsi/libscsi/amd64/llib-lscsi.ln
+usr/src/lib/scsi/libscsi/common/scsi_errno.c
+usr/src/lib/scsi/libscsi/i386/lint.out
+usr/src/lib/scsi/libscsi/i386/llib-lscsi.ln
+usr/src/lib/scsi/libses/amd64/lint.out
+usr/src/lib/scsi/libses/amd64/llib-lses.ln
+usr/src/lib/scsi/libses/common/ses_errno.c
+usr/src/lib/scsi/libses/i386/lint.out
+usr/src/lib/scsi/libses/i386/llib-lses.ln
+usr/src/lib/scsi/libsmp/amd64/lint.out
+usr/src/lib/scsi/libsmp/amd64/llib-lsmp.ln
+usr/src/lib/scsi/libsmp/common/smp_errno.c
+usr/src/lib/scsi/libsmp/i386/lint.out
+usr/src/lib/scsi/libsmp/i386/llib-lsmp.ln
+usr/src/lib/scsi/plugins/ses/libses/common/libses_elemtype.c
+usr/src/lib/smbsrv/libmlrpc/amd64/lint.out
+usr/src/lib/smbsrv/libmlrpc/amd64/llib-lmlrpc.ln
+usr/src/lib/smbsrv/libmlrpc/amd64/rpcpdu_ndr.c
+usr/src/lib/smbsrv/libmlrpc/i386/lint.out
+usr/src/lib/smbsrv/libmlrpc/i386/llib-lmlrpc.ln
+usr/src/lib/smbsrv/libmlrpc/i386/rpcpdu_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/dssetup_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/eventlog_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/lint.out
+usr/src/lib/smbsrv/libmlsvc/amd64/llib-lmlsvc.ln
+usr/src/lib/smbsrv/libmlsvc/amd64/lsarpc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/msgsvc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/netdfs_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/netlogon_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/samrpc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/spoolss_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/srvsvc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/svcctl_ndr.c
+usr/src/lib/smbsrv/libmlsvc/amd64/winreg_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/dssetup_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/eventlog_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/lint.out
+usr/src/lib/smbsrv/libmlsvc/i386/llib-lmlsvc.ln
+usr/src/lib/smbsrv/libmlsvc/i386/lsarpc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/msgsvc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/netdfs_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/netlogon_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/samrpc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/spoolss_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/srvsvc_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/svcctl_ndr.c
+usr/src/lib/smbsrv/libmlsvc/i386/winreg_ndr.c
+usr/src/lib/smbsrv/libsmb/amd64/lint.out
+usr/src/lib/smbsrv/libsmb/amd64/llib-lsmb.ln
+usr/src/lib/smbsrv/libsmb/common/smb_status_tbl.h
+usr/src/lib/smbsrv/libsmb/i386/lint.out
+usr/src/lib/smbsrv/libsmb/i386/llib-lsmb.ln
+usr/src/lib/smbsrv/libsmbns/amd64/lint.out
+usr/src/lib/smbsrv/libsmbns/amd64/llib-lsmbns.ln
+usr/src/lib/smbsrv/libsmbns/i386/lint.out
+usr/src/lib/smbsrv/libsmbns/i386/llib-lsmbns.ln
+usr/src/lib/smbsrv/libsmbrdr/amd64/lint.out
+usr/src/lib/smbsrv/libsmbrdr/amd64/llib-lsmbrdr.ln
+usr/src/lib/smbsrv/libsmbrdr/i386/lint.out
+usr/src/lib/smbsrv/libsmbrdr/i386/llib-lsmbrdr.ln
+usr/src/lib/smbsrv/libsmbrp/amd64/lint.out
+usr/src/lib/smbsrv/libsmbrp/amd64/llib-lreparse_smb.ln
+usr/src/lib/smbsrv/libsmbrp/i386/lint.out
+usr/src/lib/smbsrv/libsmbrp/i386/llib-lreparse_smb.ln
+usr/src/lib/smhba/amd64/lint.out
+usr/src/lib/smhba/amd64/llib-lSMHBAAPI.ln
+usr/src/lib/smhba/i386/lint.out
+usr/src/lib/smhba/i386/llib-lSMHBAAPI.ln
+usr/src/lib/udapl/libdat/amd64/lint.out
+usr/src/lib/udapl/libdat/amd64/llib-ldat.ln
+usr/src/lib/udapl/libdat/i386/lint.out
+usr/src/lib/udapl/libdat/i386/llib-ldat.ln
+usr/src/man/man1/batch.1
+usr/src/man/man1/bg.1
+usr/src/man/man1/case.1
+usr/src/man/man1/chdir.1
+usr/src/man/man1/checkeq.1
+usr/src/man/man1/continue.1
+usr/src/man/man1/decrypt.1
+usr/src/man/man1/dirname.1
+usr/src/man/man1/dirs.1
+usr/src/man/man1/disable.1
+usr/src/man/man1/dumpkeys.1
+usr/src/man/man1/edit.1
+usr/src/man/man1/errange.1
+usr/src/man/man1/errdate.1
+usr/src/man/man1/errgid.1
+usr/src/man/man1/errint.1
+usr/src/man/man1/erritem.1
+usr/src/man/man1/errpath.1
+usr/src/man/man1/errstr.1
+usr/src/man/man1/errtime.1
+usr/src/man/man1/erruid.1
+usr/src/man/man1/erryorn.1
+usr/src/man/man1/eval.1
+usr/src/man/man1/export.1
+usr/src/man/man1/false.1
+usr/src/man/man1/fc.1
+usr/src/man/man1/fg.1
+usr/src/man/man1/for.1
+usr/src/man/man1/foreach.1
+usr/src/man/man1/function.1
+usr/src/man/man1/goto.1
+usr/src/man/man1/hashcheck.1
+usr/src/man/man1/hashmake.1
+usr/src/man/man1/hashstat.1
+usr/src/man/man1/helpdate.1
+usr/src/man/man1/helpgid.1
+usr/src/man/man1/helpint.1
+usr/src/man/man1/helpitem.1
+usr/src/man/man1/helppath.1
+usr/src/man/man1/helprange.1
+usr/src/man/man1/helpstr.1
+usr/src/man/man1/helptime.1
+usr/src/man/man1/helpuid.1
+usr/src/man/man1/helpyorn.1
+usr/src/man/man1/hist.1
+usr/src/man/man1/i286.1
+usr/src/man/man1/i386.1
+usr/src/man/man1/i486.1
+usr/src/man/man1/i860.1
+usr/src/man/man1/iAPX286.1
+usr/src/man/man1/if.1
+usr/src/man/man1/intro.1
+usr/src/man/man1/jsh.1
+usr/src/man/man1/ksh.1
+usr/src/man/man1/ldapadd.1
+usr/src/man/man1/neqn.1
+usr/src/man/man1/notify.1
+usr/src/man/man1/onintr.1
+usr/src/man/man1/page.1
+usr/src/man/man1/pcat.1
+usr/src/man/man1/pcred.1
+usr/src/man/man1/pdp11.1
+usr/src/man/man1/pfcsh.1
+usr/src/man/man1/pfiles.1
+usr/src/man/man1/pfksh.1
+usr/src/man/man1/pflags.1
+usr/src/man/man1/pfsh.1
+usr/src/man/man1/pkill.1
+usr/src/man/man1/pldd.1
+usr/src/man/man1/popd.1
+usr/src/man/man1/prun.1
+usr/src/man/man1/psig.1
+usr/src/man/man1/pstack.1
+usr/src/man/man1/pstop.1
+usr/src/man/man1/ptime.1
+usr/src/man/man1/pushd.1
+usr/src/man/man1/pwait.1
+usr/src/man/man1/pwdx.1
+usr/src/man/man1/red.1
+usr/src/man/man1/rehash.1
+usr/src/man/man1/remote_shell.1
+usr/src/man/man1/remsh.1
+usr/src/man/man1/repeat.1
+usr/src/man/man1/return.1
+usr/src/man/man1/rksh.1
+usr/src/man/man1/rksh93.1
+usr/src/man/man1/rmail.1
+usr/src/man/man1/rmdir.1
+usr/src/man/man1/rmumount.1
+usr/src/man/man1/select.1
+usr/src/man/man1/setenv.1
+usr/src/man/man1/settime.1
+usr/src/man/man1/sh.1
+usr/src/man/man1/snca.1
+usr/src/man/man1/source.1
+usr/src/man/man1/sparc.1
+usr/src/man/man1/spellin.1
+usr/src/man/man1/stop.1
+usr/src/man/man1/strconf.1
+usr/src/man/man1/sun.1
+usr/src/man/man1/switch.1
+usr/src/man/man1/t300.1
+usr/src/man/man1/t300s.1
+usr/src/man/man1/t4014.1
+usr/src/man/man1/t450.1
+usr/src/man/man1/tek.1
+usr/src/man/man1/u370.1
+usr/src/man/man1/u3b.1
+usr/src/man/man1/u3b15.1
+usr/src/man/man1/u3b2.1
+usr/src/man/man1/u3b5.1
+usr/src/man/man1/ulimit.1
+usr/src/man/man1/unalias.1
+usr/src/man/man1/uncompress.1
+usr/src/man/man1/unexpand.1
+usr/src/man/man1/unhash.1
+usr/src/man/man1/unlimit.1
+usr/src/man/man1/unpack.1
+usr/src/man/man1/unset.1
+usr/src/man/man1/unsetenv.1
+usr/src/man/man1/until.1
+usr/src/man/man1/valdate.1
+usr/src/man/man1/valgid.1
+usr/src/man/man1/valint.1
+usr/src/man/man1/valpath.1
+usr/src/man/man1/valrange.1
+usr/src/man/man1/valstr.1
+usr/src/man/man1/valtime.1
+usr/src/man/man1/valuid.1
+usr/src/man/man1/valyorn.1
+usr/src/man/man1/vax.1
+usr/src/man/man1/vedit.1
+usr/src/man/man1/ver.1
+usr/src/man/man1/whence.1
+usr/src/man/man1/while.1
+usr/src/man/man1/zcat.1
+usr/src/man/man1b/Mail.1b
+usr/src/man/man1b/fasthalt.1b
+usr/src/man/man1b/reset.1b
+usr/src/man/man1c/uudecode.1c
+usr/src/man/man1c/uulog.1c
+usr/src/man/man1c/uuname.1c
+usr/src/man/man1c/uupick.1c
+usr/src/man/man1m/acctcon1.1m
+usr/src/man/man1m/acctcon2.1m
+usr/src/man/man1m/acctdisk.1m
+usr/src/man/man1m/acctdusg.1m
+usr/src/man/man1m/accton.1m
+usr/src/man/man1m/acctprc1.1m
+usr/src/man/man1m/acctprc2.1m
+usr/src/man/man1m/acctwtmp.1m
+usr/src/man/man1m/bootparamd.1m
+usr/src/man/man1m/chargefee.1m
+usr/src/man/man1m/ckpacct.1m
+usr/src/man/man1m/closewtmp.1m
+usr/src/man/man1m/comsat.1m
+usr/src/man/man1m/dcopy.1m
+usr/src/man/man1m/devfsadmd.1m
+usr/src/man/man1m/dodisk.1m
+usr/src/man/man1m/fcadm.1m
+usr/src/man/man1m/fingerd.1m
+usr/src/man/man1m/ftpd.1m
+usr/src/man/man1m/grpck.1m
+usr/src/man/man1m/hal-find-by-capability.1m
+usr/src/man/man1m/hal-find-by-property.1m
+usr/src/man/man1m/hal-set-property.1m
+usr/src/man/man1m/intro.1m
+usr/src/man/man1m/kadmin.local.1m
+usr/src/man/man1m/lastlogin.1m
+usr/src/man/man1m/metadetach.1m
+usr/src/man/man1m/metaonline.1m
+usr/src/man/man1m/monacct.1m
+usr/src/man/man1m/nulladm.1m
+usr/src/man/man1m/poweroff.1m
+usr/src/man/man1m/prctmp.1m
+usr/src/man/man1m/prdaily.1m
+usr/src/man/man1m/prtacct.1m
+usr/src/man/man1m/quotaoff.1m
+usr/src/man/man1m/rarpd.1m
+usr/src/man/man1m/rdisc.1m
+usr/src/man/man1m/reject.1m
+usr/src/man/man1m/restricted_shell.1m
+usr/src/man/man1m/rexd.1m
+usr/src/man/man1m/rexecd.1m
+usr/src/man/man1m/rlogind.1m
+usr/src/man/man1m/routed.1m
+usr/src/man/man1m/rshd.1m
+usr/src/man/man1m/rstatd.1m
+usr/src/man/man1m/rusersd.1m
+usr/src/man/man1m/rwalld.1m
+usr/src/man/man1m/rwhod.1m
+usr/src/man/man1m/sa1.1m
+usr/src/man/man1m/sa2.1m
+usr/src/man/man1m/sadc.1m
+usr/src/man/man1m/shutacct.1m
+usr/src/man/man1m/sprayd.1m
+usr/src/man/man1m/startup.1m
+usr/src/man/man1m/talkd.1m
+usr/src/man/man1m/telinit.1m
+usr/src/man/man1m/telnetd.1m
+usr/src/man/man1m/tftpd.1m
+usr/src/man/man1m/turnacct.1m
+usr/src/man/man1m/umount.1m
+usr/src/man/man1m/umount_smbfs.1m
+usr/src/man/man1m/umountall.1m
+usr/src/man/man1m/unlink.1m
+usr/src/man/man1m/unshareall.1m
+usr/src/man/man1m/utmp2wtmp.1m
+usr/src/man/man1m/uucpd.1m
+usr/src/man/man1m/uutry.1m
+usr/src/man/man1m/wtmpfix.1m
+usr/src/man/man1m/yppasswdd.1m
+usr/src/man/man1m/ypstop.1m
+usr/src/man/man1m/ypupdated.1m
+usr/src/man/man1m/ypxfr_1perday.1m
+usr/src/man/man1m/ypxfr_1perhour.1m
+usr/src/man/man1m/ypxfr_2perday.1m
+usr/src/man/man1m/ypxfrd.1m
+usr/src/man/man2/_Exit.2
+usr/src/man/man2/_exit.2
+usr/src/man/man2/_lwp_cond_broadcast.2
+usr/src/man/man2/_lwp_cond_reltimedwait.2
+usr/src/man/man2/_lwp_cond_timedwait.2
+usr/src/man/man2/_lwp_continue.2
+usr/src/man/man2/_lwp_mutex_trylock.2
+usr/src/man/man2/_lwp_mutex_unlock.2
+usr/src/man/man2/_lwp_sema_init.2
+usr/src/man/man2/_lwp_sema_post.2
+usr/src/man/man2/_lwp_sema_trywait.2
+usr/src/man/man2/execl.2
+usr/src/man/man2/execle.2
+usr/src/man/man2/execlp.2
+usr/src/man/man2/execv.2
+usr/src/man/man2/execve.2
+usr/src/man/man2/execvp.2
+usr/src/man/man2/faccessat.2
+usr/src/man/man2/facl.2
+usr/src/man/man2/fchdir.2
+usr/src/man/man2/fchmod.2
+usr/src/man/man2/fchown.2
+usr/src/man/man2/fchownat.2
+usr/src/man/man2/fchroot.2
+usr/src/man/man2/fgetlabel.2
+usr/src/man/man2/fork1.2
+usr/src/man/man2/forkall.2
+usr/src/man/man2/forkallx.2
+usr/src/man/man2/forkx.2
+usr/src/man/man2/fstat.2
+usr/src/man/man2/fstatat.2
+usr/src/man/man2/fstatvfs.2
+usr/src/man/man2/futimesat.2
+usr/src/man/man2/getaudit_addr.2
+usr/src/man/man2/getegid.2
+usr/src/man/man2/geteuid.2
+usr/src/man/man2/getgid.2
+usr/src/man/man2/getpgid.2
+usr/src/man/man2/getpgrp.2
+usr/src/man/man2/getpmsg.2
+usr/src/man/man2/getppid.2
+usr/src/man/man2/getprojid.2
+usr/src/man/man2/getrctl.2
+usr/src/man/man2/gettaskid.2
+usr/src/man/man2/intro.2
+usr/src/man/man2/lchown.2
+usr/src/man/man2/lstat.2
+usr/src/man/man2/openat.2
+usr/src/man/man2/pathconf.2
+usr/src/man/man2/pread.2
+usr/src/man/man2/pset_assign.2
+usr/src/man/man2/pset_destroy.2
+usr/src/man/man2/pset_getattr.2
+usr/src/man/man2/putacct.2
+usr/src/man/man2/putpmsg.2
+usr/src/man/man2/pwrite.2
+usr/src/man/man2/readv.2
+usr/src/man/man2/renameat.2
+usr/src/man/man2/sbrk.2
+usr/src/man/man2/semtimedop.2
+usr/src/man/man2/setaudit.2
+usr/src/man/man2/setaudit_addr.2
+usr/src/man/man2/setauid.2
+usr/src/man/man2/setcontext.2
+usr/src/man/man2/setegid.2
+usr/src/man/man2/seteuid.2
+usr/src/man/man2/setgid.2
+usr/src/man/man2/setgroups.2
+usr/src/man/man2/setitimer.2
+usr/src/man/man2/setpflags.2
+usr/src/man/man2/setppriv.2
+usr/src/man/man2/setrlimit.2
+usr/src/man/man2/setustack.2
+usr/src/man/man2/shmat.2
+usr/src/man/man2/shmdt.2
+usr/src/man/man2/sigsendset.2
+usr/src/man/man2/umount2.2
+usr/src/man/man2/unlinkat.2
+usr/src/man/man2/vforkx.2
+usr/src/man/man2/wracct.2
+usr/src/man/man2/writev.2
+usr/src/man/man3/intro.3
+usr/src/man/man3bsm/au_close.3bsm
+usr/src/man/man3bsm/au_to_arg.3bsm
+usr/src/man/man3bsm/au_to_arg32.3bsm
+usr/src/man/man3bsm/au_to_arg64.3bsm
+usr/src/man/man3bsm/au_to_attr.3bsm
+usr/src/man/man3bsm/au_to_cmd.3bsm
+usr/src/man/man3bsm/au_to_data.3bsm
+usr/src/man/man3bsm/au_to_groups.3bsm
+usr/src/man/man3bsm/au_to_in_addr.3bsm
+usr/src/man/man3bsm/au_to_ipc.3bsm
+usr/src/man/man3bsm/au_to_iport.3bsm
+usr/src/man/man3bsm/au_to_me.3bsm
+usr/src/man/man3bsm/au_to_newgroups.3bsm
+usr/src/man/man3bsm/au_to_opaque.3bsm
+usr/src/man/man3bsm/au_to_path.3bsm
+usr/src/man/man3bsm/au_to_process.3bsm
+usr/src/man/man3bsm/au_to_process_ex.3bsm
+usr/src/man/man3bsm/au_to_return.3bsm
+usr/src/man/man3bsm/au_to_return32.3bsm
+usr/src/man/man3bsm/au_to_return64.3bsm
+usr/src/man/man3bsm/au_to_socket.3bsm
+usr/src/man/man3bsm/au_to_subject.3bsm
+usr/src/man/man3bsm/au_to_subject_ex.3bsm
+usr/src/man/man3bsm/au_to_text.3bsm
+usr/src/man/man3bsm/au_write.3bsm
+usr/src/man/man3bsm/endac.3bsm
+usr/src/man/man3bsm/endauclass.3bsm
+usr/src/man/man3bsm/endauevent.3bsm
+usr/src/man/man3bsm/endauuser.3bsm
+usr/src/man/man3bsm/endddent.3bsm
+usr/src/man/man3bsm/getacdir.3bsm
+usr/src/man/man3bsm/getacflg.3bsm
+usr/src/man/man3bsm/getacmin.3bsm
+usr/src/man/man3bsm/getacna.3bsm
+usr/src/man/man3bsm/getauclassent_r.3bsm
+usr/src/man/man3bsm/getauclassnam.3bsm
+usr/src/man/man3bsm/getauclassnam_r.3bsm
+usr/src/man/man3bsm/getauditflagsbin.3bsm
+usr/src/man/man3bsm/getauditflagschar.3bsm
+usr/src/man/man3bsm/getauevent_r.3bsm
+usr/src/man/man3bsm/getauevnam.3bsm
+usr/src/man/man3bsm/getauevnam_r.3bsm
+usr/src/man/man3bsm/getauevnonam.3bsm
+usr/src/man/man3bsm/getauevnum.3bsm
+usr/src/man/man3bsm/getauevnum_r.3bsm
+usr/src/man/man3bsm/getauuserent.3bsm
+usr/src/man/man3bsm/getauuserent_r.3bsm
+usr/src/man/man3bsm/getauusernam_r.3bsm
+usr/src/man/man3bsm/getddnam.3bsm
+usr/src/man/man3bsm/setac.3bsm
+usr/src/man/man3bsm/setauclass.3bsm
+usr/src/man/man3bsm/setauevent.3bsm
+usr/src/man/man3bsm/setauuser.3bsm
+usr/src/man/man3bsm/setddent.3bsm
+usr/src/man/man3bsm/setddfile.3bsm
+usr/src/man/man3c/FD_CLR.3c
+usr/src/man/man3c/FD_ISSET.3c
+usr/src/man/man3c/FD_SET.3c
+usr/src/man/man3c/FD_ZERO.3c
+usr/src/man/man3c/__flbf.3c
+usr/src/man/man3c/__fpending.3c
+usr/src/man/man3c/__fpurge.3c
+usr/src/man/man3c/__freadable.3c
+usr/src/man/man3c/__freading.3c
+usr/src/man/man3c/__fsetlocking.3c
+usr/src/man/man3c/__fwritable.3c
+usr/src/man/man3c/__fwriting.3c
+usr/src/man/man3c/_edata.3c
+usr/src/man/man3c/_end.3c
+usr/src/man/man3c/_etext.3c
+usr/src/man/man3c/_exithandle.3c
+usr/src/man/man3c/_flushlbf.3c
+usr/src/man/man3c/_setjmp.3c
+usr/src/man/man3c/addrtosymstr.3c
+usr/src/man/man3c/aiowrite.3c
+usr/src/man/man3c/alloca.3c
+usr/src/man/man3c/alphasort.3c
+usr/src/man/man3c/ascftime.3c
+usr/src/man/man3c/asctime.3c
+usr/src/man/man3c/asctime_r.3c
+usr/src/man/man3c/asprintf.3c
+usr/src/man/man3c/atof.3c
+usr/src/man/man3c/atoi.3c
+usr/src/man/man3c/atol.3c
+usr/src/man/man3c/atoll.3c
+usr/src/man/man3c/atomic_add_16.3c
+usr/src/man/man3c/atomic_add_16_nv.3c
+usr/src/man/man3c/atomic_add_32.3c
+usr/src/man/man3c/atomic_add_32_nv.3c
+usr/src/man/man3c/atomic_add_64.3c
+usr/src/man/man3c/atomic_add_64_nv.3c
+usr/src/man/man3c/atomic_add_8.3c
+usr/src/man/man3c/atomic_add_8_nv.3c
+usr/src/man/man3c/atomic_add_char.3c
+usr/src/man/man3c/atomic_add_char_nv.3c
+usr/src/man/man3c/atomic_add_int.3c
+usr/src/man/man3c/atomic_add_int_nv.3c
+usr/src/man/man3c/atomic_add_long.3c
+usr/src/man/man3c/atomic_add_long_nv.3c
+usr/src/man/man3c/atomic_add_ptr.3c
+usr/src/man/man3c/atomic_add_ptr_nv.3c
+usr/src/man/man3c/atomic_add_short.3c
+usr/src/man/man3c/atomic_add_short_nv.3c
+usr/src/man/man3c/atomic_and_16.3c
+usr/src/man/man3c/atomic_and_16_nv.3c
+usr/src/man/man3c/atomic_and_32.3c
+usr/src/man/man3c/atomic_and_32_nv.3c
+usr/src/man/man3c/atomic_and_64.3c
+usr/src/man/man3c/atomic_and_64_nv.3c
+usr/src/man/man3c/atomic_and_8.3c
+usr/src/man/man3c/atomic_and_8_nv.3c
+usr/src/man/man3c/atomic_and_uchar.3c
+usr/src/man/man3c/atomic_and_uchar_nv.3c
+usr/src/man/man3c/atomic_and_uint.3c
+usr/src/man/man3c/atomic_and_uint_nv.3c
+usr/src/man/man3c/atomic_and_ulong.3c
+usr/src/man/man3c/atomic_and_ulong_nv.3c
+usr/src/man/man3c/atomic_and_ushort.3c
+usr/src/man/man3c/atomic_and_ushort_nv.3c
+usr/src/man/man3c/atomic_cas_16.3c
+usr/src/man/man3c/atomic_cas_32.3c
+usr/src/man/man3c/atomic_cas_64.3c
+usr/src/man/man3c/atomic_cas_8.3c
+usr/src/man/man3c/atomic_cas_ptr.3c
+usr/src/man/man3c/atomic_cas_uchar.3c
+usr/src/man/man3c/atomic_cas_uint.3c
+usr/src/man/man3c/atomic_cas_ulong.3c
+usr/src/man/man3c/atomic_cas_ushort.3c
+usr/src/man/man3c/atomic_clear_long_excl.3c
+usr/src/man/man3c/atomic_dec_16.3c
+usr/src/man/man3c/atomic_dec_16_nv.3c
+usr/src/man/man3c/atomic_dec_32.3c
+usr/src/man/man3c/atomic_dec_32_nv.3c
+usr/src/man/man3c/atomic_dec_64.3c
+usr/src/man/man3c/atomic_dec_64_nv.3c
+usr/src/man/man3c/atomic_dec_8.3c
+usr/src/man/man3c/atomic_dec_8_nv.3c
+usr/src/man/man3c/atomic_dec_ptr.3c
+usr/src/man/man3c/atomic_dec_ptr_nv.3c
+usr/src/man/man3c/atomic_dec_uchar.3c
+usr/src/man/man3c/atomic_dec_uchar_nv.3c
+usr/src/man/man3c/atomic_dec_uint.3c
+usr/src/man/man3c/atomic_dec_uint_nv.3c
+usr/src/man/man3c/atomic_dec_ulong.3c
+usr/src/man/man3c/atomic_dec_ulong_nv.3c
+usr/src/man/man3c/atomic_dec_ushort.3c
+usr/src/man/man3c/atomic_dec_ushort_nv.3c
+usr/src/man/man3c/atomic_inc_16.3c
+usr/src/man/man3c/atomic_inc_16_nv.3c
+usr/src/man/man3c/atomic_inc_32.3c
+usr/src/man/man3c/atomic_inc_32_nv.3c
+usr/src/man/man3c/atomic_inc_64.3c
+usr/src/man/man3c/atomic_inc_64_nv.3c
+usr/src/man/man3c/atomic_inc_8.3c
+usr/src/man/man3c/atomic_inc_8_nv.3c
+usr/src/man/man3c/atomic_inc_ptr.3c
+usr/src/man/man3c/atomic_inc_ptr_nv.3c
+usr/src/man/man3c/atomic_inc_uchar.3c
+usr/src/man/man3c/atomic_inc_uchar_nv.3c
+usr/src/man/man3c/atomic_inc_uint.3c
+usr/src/man/man3c/atomic_inc_uint_nv.3c
+usr/src/man/man3c/atomic_inc_ulong.3c
+usr/src/man/man3c/atomic_inc_ulong_nv.3c
+usr/src/man/man3c/atomic_inc_ushort.3c
+usr/src/man/man3c/atomic_inc_ushort_nv.3c
+usr/src/man/man3c/atomic_or_16.3c
+usr/src/man/man3c/atomic_or_16_nv.3c
+usr/src/man/man3c/atomic_or_32.3c
+usr/src/man/man3c/atomic_or_32_nv.3c
+usr/src/man/man3c/atomic_or_64.3c
+usr/src/man/man3c/atomic_or_64_nv.3c
+usr/src/man/man3c/atomic_or_8.3c
+usr/src/man/man3c/atomic_or_8_nv.3c
+usr/src/man/man3c/atomic_or_uchar.3c
+usr/src/man/man3c/atomic_or_uchar_nv.3c
+usr/src/man/man3c/atomic_or_uint.3c
+usr/src/man/man3c/atomic_or_uint_nv.3c
+usr/src/man/man3c/atomic_or_ulong.3c
+usr/src/man/man3c/atomic_or_ulong_nv.3c
+usr/src/man/man3c/atomic_or_ushort.3c
+usr/src/man/man3c/atomic_or_ushort_nv.3c
+usr/src/man/man3c/atomic_set_long_excl.3c
+usr/src/man/man3c/atomic_swap_16.3c
+usr/src/man/man3c/atomic_swap_32.3c
+usr/src/man/man3c/atomic_swap_64.3c
+usr/src/man/man3c/atomic_swap_8.3c
+usr/src/man/man3c/atomic_swap_ptr.3c
+usr/src/man/man3c/atomic_swap_uchar.3c
+usr/src/man/man3c/atomic_swap_uint.3c
+usr/src/man/man3c/atomic_swap_ulong.3c
+usr/src/man/man3c/atomic_swap_ushort.3c
+usr/src/man/man3c/backtrace.3c
+usr/src/man/man3c/backtrace_symbols.3c
+usr/src/man/man3c/backtrace_symbols_fd.3c
+usr/src/man/man3c/bcmp.3c
+usr/src/man/man3c/bcopy.3c
+usr/src/man/man3c/bind_textdomain_codeset.3c
+usr/src/man/man3c/bindtextdomain.3c
+usr/src/man/man3c/bzero.3c
+usr/src/man/man3c/calloc.3c
+usr/src/man/man3c/catclose.3c
+usr/src/man/man3c/cfgetospeed.3c
+usr/src/man/man3c/cfsetospeed.3c
+usr/src/man/man3c/cftime.3c
+usr/src/man/man3c/clearerr.3c
+usr/src/man/man3c/clock_getres.3c
+usr/src/man/man3c/clock_gettime.3c
+usr/src/man/man3c/closelog.3c
+usr/src/man/man3c/cond_broadcast.3c
+usr/src/man/man3c/cond_destroy.3c
+usr/src/man/man3c/cond_reltimedwait.3c
+usr/src/man/man3c/cond_signal.3c
+usr/src/man/man3c/cond_timedwait.3c
+usr/src/man/man3c/cond_wait.3c
+usr/src/man/man3c/csetcol.3c
+usr/src/man/man3c/csetlen.3c
+usr/src/man/man3c/csetno.3c
+usr/src/man/man3c/ctermid_r.3c
+usr/src/man/man3c/ctime_r.3c
+usr/src/man/man3c/dbm_clearerr.3c
+usr/src/man/man3c/dbm_close.3c
+usr/src/man/man3c/dbm_delete.3c
+usr/src/man/man3c/dbm_error.3c
+usr/src/man/man3c/dbm_fetch.3c
+usr/src/man/man3c/dbm_firstkey.3c
+usr/src/man/man3c/dbm_nextkey.3c
+usr/src/man/man3c/dbm_open.3c
+usr/src/man/man3c/dbm_store.3c
+usr/src/man/man3c/dcgettext.3c
+usr/src/man/man3c/dcngettext.3c
+usr/src/man/man3c/decimal_to_double.3c
+usr/src/man/man3c/decimal_to_extended.3c
+usr/src/man/man3c/decimal_to_quadruple.3c
+usr/src/man/man3c/decimal_to_single.3c
+usr/src/man/man3c/dgettext.3c
+usr/src/man/man3c/dladdr1.3c
+usr/src/man/man3c/dlmopen.3c
+usr/src/man/man3c/dngettext.3c
+usr/src/man/man3c/door_setparam.3c
+usr/src/man/man3c/door_unbind.3c
+usr/src/man/man3c/double_to_decimal.3c
+usr/src/man/man3c/edata.3c
+usr/src/man/man3c/endgrent.3c
+usr/src/man/man3c/endnetgrent.3c
+usr/src/man/man3c/endpwent.3c
+usr/src/man/man3c/endspent.3c
+usr/src/man/man3c/endusershell.3c
+usr/src/man/man3c/endutent.3c
+usr/src/man/man3c/endutxent.3c
+usr/src/man/man3c/erand48.3c
+usr/src/man/man3c/errno.3c
+usr/src/man/man3c/errx.3c
+usr/src/man/man3c/etext.3c
+usr/src/man/man3c/euccol.3c
+usr/src/man/man3c/eucscol.3c
+usr/src/man/man3c/extended_to_decimal.3c
+usr/src/man/man3c/fconvert.3c
+usr/src/man/man3c/fcvt.3c
+usr/src/man/man3c/fdopendir.3c
+usr/src/man/man3c/fdwalk.3c
+usr/src/man/man3c/feof.3c
+usr/src/man/man3c/fgetgrent.3c
+usr/src/man/man3c/fgetgrent_r.3c
+usr/src/man/man3c/fgetpwent.3c
+usr/src/man/man3c/fgetpwent_r.3c
+usr/src/man/man3c/fgets.3c
+usr/src/man/man3c/fgetspent.3c
+usr/src/man/man3c/fgetspent_r.3c
+usr/src/man/man3c/fgetws.3c
+usr/src/man/man3c/file_to_decimal.3c
+usr/src/man/man3c/fileno.3c
+usr/src/man/man3c/finite.3c
+usr/src/man/man3c/fpclass.3c
+usr/src/man/man3c/fpgetmask.3c
+usr/src/man/man3c/fpgetsticky.3c
+usr/src/man/man3c/fprintf.3c
+usr/src/man/man3c/fpsetmask.3c
+usr/src/man/man3c/fpsetround.3c
+usr/src/man/man3c/fpsetsticky.3c
+usr/src/man/man3c/fputs.3c
+usr/src/man/man3c/free.3c
+usr/src/man/man3c/fscanf.3c
+usr/src/man/man3c/fseeko.3c
+usr/src/man/man3c/fsetattr.3c
+usr/src/man/man3c/ftello.3c
+usr/src/man/man3c/ftruncate.3c
+usr/src/man/man3c/ftrylockfile.3c
+usr/src/man/man3c/func_to_decimal.3c
+usr/src/man/man3c/funlockfile.3c
+usr/src/man/man3c/gconvert.3c
+usr/src/man/man3c/gcvt.3c
+usr/src/man/man3c/getattrat.3c
+usr/src/man/man3c/getc.3c
+usr/src/man/man3c/getc_unlocked.3c
+usr/src/man/man3c/getchar.3c
+usr/src/man/man3c/getchar_unlocked.3c
+usr/src/man/man3c/getextmntent.3c
+usr/src/man/man3c/getgrent.3c
+usr/src/man/man3c/getgrent_r.3c
+usr/src/man/man3c/getgrgid.3c
+usr/src/man/man3c/getgrgid_r.3c
+usr/src/man/man3c/getgrnam_r.3c
+usr/src/man/man3c/gethomelgroup.3c
+usr/src/man/man3c/gethrvtime.3c
+usr/src/man/man3c/getlogin_r.3c
+usr/src/man/man3c/getmntany.3c
+usr/src/man/man3c/getnetgrent_r.3c
+usr/src/man/man3c/getpassphrase.3c
+usr/src/man/man3c/getpwent.3c
+usr/src/man/man3c/getpwent_r.3c
+usr/src/man/man3c/getpwnam_r.3c
+usr/src/man/man3c/getpwuid.3c
+usr/src/man/man3c/getpwuid_r.3c
+usr/src/man/man3c/getspent.3c
+usr/src/man/man3c/getspent_r.3c
+usr/src/man/man3c/getspnam_r.3c
+usr/src/man/man3c/getutid.3c
+usr/src/man/man3c/getutline.3c
+usr/src/man/man3c/getutmp.3c
+usr/src/man/man3c/getutmpx.3c
+usr/src/man/man3c/getutxid.3c
+usr/src/man/man3c/getutxline.3c
+usr/src/man/man3c/getvfsany.3c
+usr/src/man/man3c/getvfsfile.3c
+usr/src/man/man3c/getvfsspec.3c
+usr/src/man/man3c/getw.3c
+usr/src/man/man3c/getzoneidbyname.3c
+usr/src/man/man3c/getzonenamebyid.3c
+usr/src/man/man3c/globfree.3c
+usr/src/man/man3c/gmtime.3c
+usr/src/man/man3c/gmtime_r.3c
+usr/src/man/man3c/gsignal.3c
+usr/src/man/man3c/hasmntopt.3c
+usr/src/man/man3c/hcreate.3c
+usr/src/man/man3c/hdestroy.3c
+usr/src/man/man3c/initstate.3c
+usr/src/man/man3c/innetgr.3c
+usr/src/man/man3c/isalnum.3c
+usr/src/man/man3c/isalpha.3c
+usr/src/man/man3c/isascii.3c
+usr/src/man/man3c/isblank.3c
+usr/src/man/man3c/iscntrl.3c
+usr/src/man/man3c/isdigit.3c
+usr/src/man/man3c/isenglish.3c
+usr/src/man/man3c/isgraph.3c
+usr/src/man/man3c/isideogram.3c
+usr/src/man/man3c/islower.3c
+usr/src/man/man3c/isnanf.3c
+usr/src/man/man3c/isnumber.3c
+usr/src/man/man3c/isphonogram.3c
+usr/src/man/man3c/isprint.3c
+usr/src/man/man3c/ispunct.3c
+usr/src/man/man3c/isspace.3c
+usr/src/man/man3c/isspecial.3c
+usr/src/man/man3c/isupper.3c
+usr/src/man/man3c/iswalnum.3c
+usr/src/man/man3c/iswascii.3c
+usr/src/man/man3c/iswblank.3c
+usr/src/man/man3c/iswcntrl.3c
+usr/src/man/man3c/iswdigit.3c
+usr/src/man/man3c/iswgraph.3c
+usr/src/man/man3c/iswlower.3c
+usr/src/man/man3c/iswprint.3c
+usr/src/man/man3c/iswpunct.3c
+usr/src/man/man3c/iswspace.3c
+usr/src/man/man3c/iswupper.3c
+usr/src/man/man3c/iswxdigit.3c
+usr/src/man/man3c/isxdigit.3c
+usr/src/man/man3c/jrand48.3c
+usr/src/man/man3c/l64a.3c
+usr/src/man/man3c/labs.3c
+usr/src/man/man3c/lcong48.3c
+usr/src/man/man3c/ldiv.3c
+usr/src/man/man3c/lfind.3c
+usr/src/man/man3c/llabs.3c
+usr/src/man/man3c/lldiv.3c
+usr/src/man/man3c/lltostr.3c
+usr/src/man/man3c/localtime.3c
+usr/src/man/man3c/localtime_r.3c
+usr/src/man/man3c/longjmp.3c
+usr/src/man/man3c/lrand48.3c
+usr/src/man/man3c/major.3c
+usr/src/man/man3c/memalign.3c
+usr/src/man/man3c/membar_consumer.3c
+usr/src/man/man3c/membar_enter.3c
+usr/src/man/man3c/membar_exit.3c
+usr/src/man/man3c/membar_producer.3c
+usr/src/man/man3c/memccpy.3c
+usr/src/man/man3c/memchr.3c
+usr/src/man/man3c/memcmp.3c
+usr/src/man/man3c/memcpy.3c
+usr/src/man/man3c/memmove.3c
+usr/src/man/man3c/memset.3c
+usr/src/man/man3c/minor.3c
+usr/src/man/man3c/mkdtemp.3c
+usr/src/man/man3c/mkstemps.3c
+usr/src/man/man3c/mq_reltimedreceive_np.3c
+usr/src/man/man3c/mq_reltimedsend_np.3c
+usr/src/man/man3c/mq_timedreceive.3c
+usr/src/man/man3c/mq_timedsend.3c
+usr/src/man/man3c/mrand48.3c
+usr/src/man/man3c/munlock.3c
+usr/src/man/man3c/munlockall.3c
+usr/src/man/man3c/mutex_consistent.3c
+usr/src/man/man3c/mutex_destroy.3c
+usr/src/man/man3c/mutex_lock.3c
+usr/src/man/man3c/mutex_trylock.3c
+usr/src/man/man3c/mutex_unlock.3c
+usr/src/man/man3c/nftw.3c
+usr/src/man/man3c/ngettext.3c
+usr/src/man/man3c/nrand48.3c
+usr/src/man/man3c/openlog.3c
+usr/src/man/man3c/pclose.3c
+usr/src/man/man3c/port_dissociate.3c
+usr/src/man/man3c/port_getn.3c
+usr/src/man/man3c/port_sendn.3c
+usr/src/man/man3c/posix_spawn_file_actions_addopen.3c
+usr/src/man/man3c/posix_spawn_file_actions_init.3c
+usr/src/man/man3c/posix_spawnattr_init.3c
+usr/src/man/man3c/posix_spawnattr_setflags.3c
+usr/src/man/man3c/posix_spawnattr_setpgroup.3c
+usr/src/man/man3c/posix_spawnattr_setschedparam.3c
+usr/src/man/man3c/posix_spawnattr_setschedpolicy.3c
+usr/src/man/man3c/posix_spawnattr_setsigdefault.3c
+usr/src/man/man3c/posix_spawnattr_setsigignore_np.3c
+usr/src/man/man3c/posix_spawnattr_setsigmask.3c
+usr/src/man/man3c/posix_spawnp.3c
+usr/src/man/man3c/printstack.3c
+usr/src/man/man3c/priv_allocset.3c
+usr/src/man/man3c/priv_basicset.3c
+usr/src/man/man3c/priv_copyset.3c
+usr/src/man/man3c/priv_delset.3c
+usr/src/man/man3c/priv_emptyset.3c
+usr/src/man/man3c/priv_fillset.3c
+usr/src/man/man3c/priv_freeset.3c
+usr/src/man/man3c/priv_getbyname.3c
+usr/src/man/man3c/priv_getbynum.3c
+usr/src/man/man3c/priv_getsetbyname.3c
+usr/src/man/man3c/priv_getsetbynum.3c
+usr/src/man/man3c/priv_gettext.3c
+usr/src/man/man3c/priv_ineffect.3c
+usr/src/man/man3c/priv_intersect.3c
+usr/src/man/man3c/priv_inverse.3c
+usr/src/man/man3c/priv_isemptyset.3c
+usr/src/man/man3c/priv_isequalset.3c
+usr/src/man/man3c/priv_isfullset.3c
+usr/src/man/man3c/priv_ismember.3c
+usr/src/man/man3c/priv_issubset.3c
+usr/src/man/man3c/priv_set_to_str.3c
+usr/src/man/man3c/priv_union.3c
+usr/src/man/man3c/pselect.3c
+usr/src/man/man3c/psiginfo.3c
+usr/src/man/man3c/pthread_attr_destroy.3c
+usr/src/man/man3c/pthread_attr_setdetachstate.3c
+usr/src/man/man3c/pthread_attr_setguardsize.3c
+usr/src/man/man3c/pthread_attr_setinheritsched.3c
+usr/src/man/man3c/pthread_attr_setschedparam.3c
+usr/src/man/man3c/pthread_attr_setschedpolicy.3c
+usr/src/man/man3c/pthread_attr_setscope.3c
+usr/src/man/man3c/pthread_attr_setstack.3c
+usr/src/man/man3c/pthread_attr_setstackaddr.3c
+usr/src/man/man3c/pthread_attr_setstacksize.3c
+usr/src/man/man3c/pthread_barrier_init.3c
+usr/src/man/man3c/pthread_barrierattr_init.3c
+usr/src/man/man3c/pthread_barrierattr_setpshared.3c
+usr/src/man/man3c/pthread_cond_broadcast.3c
+usr/src/man/man3c/pthread_cond_destroy.3c
+usr/src/man/man3c/pthread_cond_reltimedwait_np.3c
+usr/src/man/man3c/pthread_cond_timedwait.3c
+usr/src/man/man3c/pthread_condattr_destroy.3c
+usr/src/man/man3c/pthread_condattr_setclock.3c
+usr/src/man/man3c/pthread_condattr_setpshared.3c
+usr/src/man/man3c/pthread_key_create_once_np.3c
+usr/src/man/man3c/pthread_mutex_destroy.3c
+usr/src/man/man3c/pthread_mutex_reltimedlock_np.3c
+usr/src/man/man3c/pthread_mutex_setprioceiling.3c
+usr/src/man/man3c/pthread_mutex_trylock.3c
+usr/src/man/man3c/pthread_mutex_unlock.3c
+usr/src/man/man3c/pthread_mutexattr_destroy.3c
+usr/src/man/man3c/pthread_mutexattr_setprioceiling.3c
+usr/src/man/man3c/pthread_mutexattr_setprotocol.3c
+usr/src/man/man3c/pthread_mutexattr_setpshared.3c
+usr/src/man/man3c/pthread_mutexattr_settype.3c
+usr/src/man/man3c/pthread_rwlock_destroy.3c
+usr/src/man/man3c/pthread_rwlock_reltimedrdlock_np.3c
+usr/src/man/man3c/pthread_rwlock_reltimedwrlock_np.3c
+usr/src/man/man3c/pthread_rwlock_tryrdlock.3c
+usr/src/man/man3c/pthread_rwlock_trywrlock.3c
+usr/src/man/man3c/pthread_rwlockattr_destroy.3c
+usr/src/man/man3c/pthread_rwlockattr_setpshared.3c
+usr/src/man/man3c/pthread_setconcurrency.3c
+usr/src/man/man3c/pthread_setschedparam.3c
+usr/src/man/man3c/pthread_setspecific.3c
+usr/src/man/man3c/pthread_spin_init.3c
+usr/src/man/man3c/pthread_spin_trylock.3c
+usr/src/man/man3c/putc.3c
+usr/src/man/man3c/putc_unlocked.3c
+usr/src/man/man3c/putchar.3c
+usr/src/man/man3c/putchar_unlocked.3c
+usr/src/man/man3c/putmntent.3c
+usr/src/man/man3c/pututline.3c
+usr/src/man/man3c/pututxline.3c
+usr/src/man/man3c/putw.3c
+usr/src/man/man3c/putwc.3c
+usr/src/man/man3c/putwchar.3c
+usr/src/man/man3c/qeconvert.3c
+usr/src/man/man3c/qfconvert.3c
+usr/src/man/man3c/qgconvert.3c
+usr/src/man/man3c/quadruple_to_decimal.3c
+usr/src/man/man3c/rand_r.3c
+usr/src/man/man3c/rctlblk_get_enforced_value.3c
+usr/src/man/man3c/rctlblk_get_firing_time.3c
+usr/src/man/man3c/rctlblk_get_global_action.3c
+usr/src/man/man3c/rctlblk_get_global_flags.3c
+usr/src/man/man3c/rctlblk_get_local_action.3c
+usr/src/man/man3c/rctlblk_get_local_flags.3c
+usr/src/man/man3c/rctlblk_get_privilege.3c
+usr/src/man/man3c/rctlblk_get_recipient_pid.3c
+usr/src/man/man3c/rctlblk_get_value.3c
+usr/src/man/man3c/rctlblk_set_local_action.3c
+usr/src/man/man3c/rctlblk_set_local_flags.3c
+usr/src/man/man3c/rctlblk_set_privilege.3c
+usr/src/man/man3c/rctlblk_set_recipient_pid.3c
+usr/src/man/man3c/rctlblk_size.3c
+usr/src/man/man3c/re_exec.3c
+usr/src/man/man3c/readdir_r.3c
+usr/src/man/man3c/realloc.3c
+usr/src/man/man3c/regerror.3c
+usr/src/man/man3c/regex.3c
+usr/src/man/man3c/regexec.3c
+usr/src/man/man3c/regfree.3c
+usr/src/man/man3c/remque.3c
+usr/src/man/man3c/resetmnttab.3c
+usr/src/man/man3c/rindex.3c
+usr/src/man/man3c/rw_rdlock.3c
+usr/src/man/man3c/rw_tryrdlock.3c
+usr/src/man/man3c/rw_trywrlock.3c
+usr/src/man/man3c/rw_unlock.3c
+usr/src/man/man3c/rw_wrlock.3c
+usr/src/man/man3c/rwlock_destroy.3c
+usr/src/man/man3c/rwlock_init.3c
+usr/src/man/man3c/sched_get_priority_min.3c
+usr/src/man/man3c/schedctl_exit.3c
+usr/src/man/man3c/schedctl_lookup.3c
+usr/src/man/man3c/schedctl_start.3c
+usr/src/man/man3c/schedctl_stop.3c
+usr/src/man/man3c/seconvert.3c
+usr/src/man/man3c/seed48.3c
+usr/src/man/man3c/sem_reltimedwait_np.3c
+usr/src/man/man3c/sem_trywait.3c
+usr/src/man/man3c/sema_destroy.3c
+usr/src/man/man3c/sema_init.3c
+usr/src/man/man3c/sema_post.3c
+usr/src/man/man3c/sema_trywait.3c
+usr/src/man/man3c/sema_wait.3c
+usr/src/man/man3c/setattrat.3c
+usr/src/man/man3c/setgrent.3c
+usr/src/man/man3c/sethostname.3c
+usr/src/man/man3c/setlinebuf.3c
+usr/src/man/man3c/setlogmask.3c
+usr/src/man/man3c/setnetgrent.3c
+usr/src/man/man3c/setpriority.3c
+usr/src/man/man3c/setpwent.3c
+usr/src/man/man3c/setspent.3c
+usr/src/man/man3c/setstate.3c
+usr/src/man/man3c/settimeofday.3c
+usr/src/man/man3c/setusershell.3c
+usr/src/man/man3c/setutent.3c
+usr/src/man/man3c/setutxent.3c
+usr/src/man/man3c/setvbuf.3c
+usr/src/man/man3c/sfconvert.3c
+usr/src/man/man3c/sgconvert.3c
+usr/src/man/man3c/sig2str.3c
+usr/src/man/man3c/sigaddset.3c
+usr/src/man/man3c/sigdelset.3c
+usr/src/man/man3c/sigemptyset.3c
+usr/src/man/man3c/sigfillset.3c
+usr/src/man/man3c/sighold.3c
+usr/src/man/man3c/sigignore.3c
+usr/src/man/man3c/sigismember.3c
+usr/src/man/man3c/siglongjmp.3c
+usr/src/man/man3c/sigpause.3c
+usr/src/man/man3c/sigrelse.3c
+usr/src/man/man3c/sigset.3c
+usr/src/man/man3c/sigsetjmp.3c
+usr/src/man/man3c/sigtimedwait.3c
+usr/src/man/man3c/single_to_decimal.3c
+usr/src/man/man3c/snprintf.3c
+usr/src/man/man3c/sprintf.3c
+usr/src/man/man3c/srand.3c
+usr/src/man/man3c/srand48.3c
+usr/src/man/man3c/srandom.3c
+usr/src/man/man3c/sscanf.3c
+usr/src/man/man3c/strcasecmp.3c
+usr/src/man/man3c/strcat.3c
+usr/src/man/man3c/strchr.3c
+usr/src/man/man3c/strcmp.3c
+usr/src/man/man3c/strcpy.3c
+usr/src/man/man3c/strcspn.3c
+usr/src/man/man3c/strdup.3c
+usr/src/man/man3c/strerror_r.3c
+usr/src/man/man3c/strlcat.3c
+usr/src/man/man3c/strlcpy.3c
+usr/src/man/man3c/strlen.3c
+usr/src/man/man3c/strncasecmp.3c
+usr/src/man/man3c/strncat.3c
+usr/src/man/man3c/strncmp.3c
+usr/src/man/man3c/strncpy.3c
+usr/src/man/man3c/strnlen.3c
+usr/src/man/man3c/strpbrk.3c
+usr/src/man/man3c/strrchr.3c
+usr/src/man/man3c/strsep.3c
+usr/src/man/man3c/strspn.3c
+usr/src/man/man3c/strstr.3c
+usr/src/man/man3c/strtof.3c
+usr/src/man/man3c/strtok.3c
+usr/src/man/man3c/strtok_r.3c
+usr/src/man/man3c/strtold.3c
+usr/src/man/man3c/strtoll.3c
+usr/src/man/man3c/strtoull.3c
+usr/src/man/man3c/strtoumax.3c
+usr/src/man/man3c/swapcontext.3c
+usr/src/man/man3c/swprintf.3c
+usr/src/man/man3c/swscanf.3c
+usr/src/man/man3c/tdelete.3c
+usr/src/man/man3c/tempnam.3c
+usr/src/man/man3c/textdomain.3c
+usr/src/man/man3c/tfind.3c
+usr/src/man/man3c/thr_continue.3c
+usr/src/man/man3c/thr_getspecific.3c
+usr/src/man/man3c/thr_keycreate_once.3c
+usr/src/man/man3c/thr_setconcurrency.3c
+usr/src/man/man3c/thr_setprio.3c
+usr/src/man/man3c/thr_setspecific.3c
+usr/src/man/man3c/timer_getoverrun.3c
+usr/src/man/man3c/timer_gettime.3c
+usr/src/man/man3c/timerclear.3c
+usr/src/man/man3c/timercmp.3c
+usr/src/man/man3c/timerisset.3c
+usr/src/man/man3c/timersub.3c
+usr/src/man/man3c/tmpnam_r.3c
+usr/src/man/man3c/ttyname_r.3c
+usr/src/man/man3c/twalk.3c
+usr/src/man/man3c/tzset.3c
+usr/src/man/man3c/uconv_u16tou8.3c
+usr/src/man/man3c/uconv_u32tou16.3c
+usr/src/man/man3c/uconv_u32tou8.3c
+usr/src/man/man3c/uconv_u8tou16.3c
+usr/src/man/man3c/uconv_u8tou32.3c
+usr/src/man/man3c/ucred_free.3c
+usr/src/man/man3c/ucred_getegid.3c
+usr/src/man/man3c/ucred_geteuid.3c
+usr/src/man/man3c/ucred_getgroups.3c
+usr/src/man/man3c/ucred_getlabel.3c
+usr/src/man/man3c/ucred_getpflags.3c
+usr/src/man/man3c/ucred_getpid.3c
+usr/src/man/man3c/ucred_getprivset.3c
+usr/src/man/man3c/ucred_getprojid.3c
+usr/src/man/man3c/ucred_getrgid.3c
+usr/src/man/man3c/ucred_getruid.3c
+usr/src/man/man3c/ucred_getsgid.3c
+usr/src/man/man3c/ucred_getsuid.3c
+usr/src/man/man3c/ucred_getzoneid.3c
+usr/src/man/man3c/ucred_size.3c
+usr/src/man/man3c/ulckpwdf.3c
+usr/src/man/man3c/ulltostr.3c
+usr/src/man/man3c/unordered.3c
+usr/src/man/man3c/updwtmp.3c
+usr/src/man/man3c/updwtmpx.3c
+usr/src/man/man3c/utmpname.3c
+usr/src/man/man3c/utmpxname.3c
+usr/src/man/man3c/valloc.3c
+usr/src/man/man3c/vasprintf.3c
+usr/src/man/man3c/verr.3c
+usr/src/man/man3c/verrx.3c
+usr/src/man/man3c/vfprintf.3c
+usr/src/man/man3c/vfscanf.3c
+usr/src/man/man3c/vfwscanf.3c
+usr/src/man/man3c/vscanf.3c
+usr/src/man/man3c/vsnprintf.3c
+usr/src/man/man3c/vsprintf.3c
+usr/src/man/man3c/vsscanf.3c
+usr/src/man/man3c/vswprintf.3c
+usr/src/man/man3c/vswscanf.3c
+usr/src/man/man3c/vwarn.3c
+usr/src/man/man3c/vwarnx.3c
+usr/src/man/man3c/vwprintf.3c
+usr/src/man/man3c/vwscanf.3c
+usr/src/man/man3c/wait4.3c
+usr/src/man/man3c/warn.3c
+usr/src/man/man3c/warnx.3c
+usr/src/man/man3c/watof.3c
+usr/src/man/man3c/watoi.3c
+usr/src/man/man3c/watol.3c
+usr/src/man/man3c/watoll.3c
+usr/src/man/man3c/wcscat.3c
+usr/src/man/man3c/wcschr.3c
+usr/src/man/man3c/wcscmp.3c
+usr/src/man/man3c/wcscpy.3c
+usr/src/man/man3c/wcscspn.3c
+usr/src/man/man3c/wcsetno.3c
+usr/src/man/man3c/wcslen.3c
+usr/src/man/man3c/wcsncat.3c
+usr/src/man/man3c/wcsncmp.3c
+usr/src/man/man3c/wcsncpy.3c
+usr/src/man/man3c/wcspbrk.3c
+usr/src/man/man3c/wcsrchr.3c
+usr/src/man/man3c/wcsspn.3c
+usr/src/man/man3c/wcstof.3c
+usr/src/man/man3c/wcstok.3c
+usr/src/man/man3c/wcstold.3c
+usr/src/man/man3c/wcstoll.3c
+usr/src/man/man3c/wcstoull.3c
+usr/src/man/man3c/wcstoumax.3c
+usr/src/man/man3c/wcswcs.3c
+usr/src/man/man3c/windex.3c
+usr/src/man/man3c/wordfree.3c
+usr/src/man/man3c/wprintf.3c
+usr/src/man/man3c/wrindex.3c
+usr/src/man/man3c/wscanf.3c
+usr/src/man/man3c/wscasecmp.3c
+usr/src/man/man3c/wscat.3c
+usr/src/man/man3c/wschr.3c
+usr/src/man/man3c/wscmp.3c
+usr/src/man/man3c/wscol.3c
+usr/src/man/man3c/wscoll.3c
+usr/src/man/man3c/wscpy.3c
+usr/src/man/man3c/wscspn.3c
+usr/src/man/man3c/wsdup.3c
+usr/src/man/man3c/wslen.3c
+usr/src/man/man3c/wsncasecmp.3c
+usr/src/man/man3c/wsncat.3c
+usr/src/man/man3c/wsncmp.3c
+usr/src/man/man3c/wsncpy.3c
+usr/src/man/man3c/wspbrk.3c
+usr/src/man/man3c/wsrchr.3c
+usr/src/man/man3c/wsspn.3c
+usr/src/man/man3c/wstod.3c
+usr/src/man/man3c/wstok.3c
+usr/src/man/man3c/wstol.3c
+usr/src/man/man3c/wstostr.3c
+usr/src/man/man3c/wsxfrm.3c
+usr/src/man/man3c_db/td_event_addset.3c_db
+usr/src/man/man3c_db/td_event_delset.3c_db
+usr/src/man/man3c_db/td_event_emptyset.3c_db
+usr/src/man/man3c_db/td_event_fillset.3c_db
+usr/src/man/man3c_db/td_eventisempty.3c_db
+usr/src/man/man3c_db/td_eventismember.3c_db
+usr/src/man/man3c_db/td_sync_get_stats.3c_db
+usr/src/man/man3c_db/td_sync_setstate.3c_db
+usr/src/man/man3c_db/td_sync_waiters.3c_db
+usr/src/man/man3c_db/td_ta_clear_event.3c_db
+usr/src/man/man3c_db/td_ta_delete.3c_db
+usr/src/man/man3c_db/td_ta_event_getmsg.3c_db
+usr/src/man/man3c_db/td_ta_get_ph.3c_db
+usr/src/man/man3c_db/td_ta_get_stats.3c_db
+usr/src/man/man3c_db/td_ta_map_lwp2thr.3c_db
+usr/src/man/man3c_db/td_ta_reset_stats.3c_db
+usr/src/man/man3c_db/td_ta_set_event.3c_db
+usr/src/man/man3c_db/td_ta_sync_tracking_enable.3c_db
+usr/src/man/man3c_db/td_ta_thr_iter.3c_db
+usr/src/man/man3c_db/td_ta_tsd_iter.3c_db
+usr/src/man/man3c_db/td_thr_clear_event.3c_db
+usr/src/man/man3c_db/td_thr_dbresume.3c_db
+usr/src/man/man3c_db/td_thr_event_enable.3c_db
+usr/src/man/man3c_db/td_thr_event_getmsg.3c_db
+usr/src/man/man3c_db/td_thr_getfpregs.3c_db
+usr/src/man/man3c_db/td_thr_getxregs.3c_db
+usr/src/man/man3c_db/td_thr_getxregsize.3c_db
+usr/src/man/man3c_db/td_thr_set_event.3c_db
+usr/src/man/man3c_db/td_thr_setfpregs.3c_db
+usr/src/man/man3c_db/td_thr_setgregs.3c_db
+usr/src/man/man3c_db/td_thr_setxregs.3c_db
+usr/src/man/man3c_db/td_thr_sigsetmask.3c_db
+usr/src/man/man3cfgadm/config_ap_id_cmp.3cfgadm
+usr/src/man/man3cfgadm/config_change_state.3cfgadm
+usr/src/man/man3cfgadm/config_list.3cfgadm
+usr/src/man/man3cfgadm/config_list_ext.3cfgadm
+usr/src/man/man3cfgadm/config_private_func.3cfgadm
+usr/src/man/man3cfgadm/config_stat.3cfgadm
+usr/src/man/man3cfgadm/config_strerror.3cfgadm
+usr/src/man/man3cfgadm/config_test.3cfgadm
+usr/src/man/man3cfgadm/config_unload_libs.3cfgadm
+usr/src/man/man3commputil/sdp_add_attribute.3commputil
+usr/src/man/man3commputil/sdp_add_bandwidth.3commputil
+usr/src/man/man3commputil/sdp_add_connection.3commputil
+usr/src/man/man3commputil/sdp_add_email.3commputil
+usr/src/man/man3commputil/sdp_add_information.3commputil
+usr/src/man/man3commputil/sdp_add_key.3commputil
+usr/src/man/man3commputil/sdp_add_media.3commputil
+usr/src/man/man3commputil/sdp_add_name.3commputil
+usr/src/man/man3commputil/sdp_add_phone.3commputil
+usr/src/man/man3commputil/sdp_add_repeat.3commputil
+usr/src/man/man3commputil/sdp_add_time.3commputil
+usr/src/man/man3commputil/sdp_add_uri.3commputil
+usr/src/man/man3commputil/sdp_add_zone.3commputil
+usr/src/man/man3commputil/sdp_delete_all_media_field.3commputil
+usr/src/man/man3commputil/sdp_delete_attribute.3commputil
+usr/src/man/man3commputil/sdp_free_session.3commputil
+usr/src/man/man3contract/ct_ctl_abandon.3contract
+usr/src/man/man3contract/ct_ctl_ack.3contract
+usr/src/man/man3contract/ct_ctl_nack.3contract
+usr/src/man/man3contract/ct_ctl_newct.3contract
+usr/src/man/man3contract/ct_ctl_qack.3contract
+usr/src/man/man3contract/ct_dev_status_get_aset.3contract
+usr/src/man/man3contract/ct_dev_status_get_minor.3contract
+usr/src/man/man3contract/ct_dev_status_get_noneg.3contract
+usr/src/man/man3contract/ct_dev_tmpl_clear_noneg.3contract
+usr/src/man/man3contract/ct_dev_tmpl_get_aset.3contract
+usr/src/man/man3contract/ct_dev_tmpl_get_minor.3contract
+usr/src/man/man3contract/ct_dev_tmpl_get_noneg.3contract
+usr/src/man/man3contract/ct_dev_tmpl_set_minor.3contract
+usr/src/man/man3contract/ct_dev_tmpl_set_noneg.3contract
+usr/src/man/man3contract/ct_event_free.3contract
+usr/src/man/man3contract/ct_event_get_ctid.3contract
+usr/src/man/man3contract/ct_event_get_evid.3contract
+usr/src/man/man3contract/ct_event_get_flags.3contract
+usr/src/man/man3contract/ct_event_get_nevid.3contract
+usr/src/man/man3contract/ct_event_get_newct.3contract
+usr/src/man/man3contract/ct_event_get_type.3contract
+usr/src/man/man3contract/ct_event_read_critical.3contract
+usr/src/man/man3contract/ct_event_reliable.3contract
+usr/src/man/man3contract/ct_event_reset.3contract
+usr/src/man/man3contract/ct_pr_event_get_exitstatus.3contract
+usr/src/man/man3contract/ct_pr_event_get_gcorefile.3contract
+usr/src/man/man3contract/ct_pr_event_get_pcorefile.3contract
+usr/src/man/man3contract/ct_pr_event_get_ppid.3contract
+usr/src/man/man3contract/ct_pr_event_get_sender.3contract
+usr/src/man/man3contract/ct_pr_event_get_senderct.3contract
+usr/src/man/man3contract/ct_pr_event_get_signal.3contract
+usr/src/man/man3contract/ct_pr_event_get_zcorefile.3contract
+usr/src/man/man3contract/ct_pr_status_get_contracts.3contract
+usr/src/man/man3contract/ct_pr_status_get_fatal.3contract
+usr/src/man/man3contract/ct_pr_status_get_members.3contract
+usr/src/man/man3contract/ct_pr_status_get_svc_aux.3contract
+usr/src/man/man3contract/ct_pr_status_get_svc_creator.3contract
+usr/src/man/man3contract/ct_pr_status_get_svc_ctid.3contract
+usr/src/man/man3contract/ct_pr_status_get_svc_fmri.3contract
+usr/src/man/man3contract/ct_pr_tmpl_get_fatal.3contract
+usr/src/man/man3contract/ct_pr_tmpl_get_param.3contract
+usr/src/man/man3contract/ct_pr_tmpl_get_svc_aux.3contract
+usr/src/man/man3contract/ct_pr_tmpl_get_svc_fmri.3contract
+usr/src/man/man3contract/ct_pr_tmpl_get_transfer.3contract
+usr/src/man/man3contract/ct_pr_tmpl_set_fatal.3contract
+usr/src/man/man3contract/ct_pr_tmpl_set_param.3contract
+usr/src/man/man3contract/ct_pr_tmpl_set_svc_aux.3contract
+usr/src/man/man3contract/ct_pr_tmpl_set_svc_fmri.3contract
+usr/src/man/man3contract/ct_status_free.3contract
+usr/src/man/man3contract/ct_status_get_cookie.3contract
+usr/src/man/man3contract/ct_status_get_critical.3contract
+usr/src/man/man3contract/ct_status_get_holder.3contract
+usr/src/man/man3contract/ct_status_get_id.3contract
+usr/src/man/man3contract/ct_status_get_informative.3contract
+usr/src/man/man3contract/ct_status_get_nevents.3contract
+usr/src/man/man3contract/ct_status_get_nevid.3contract
+usr/src/man/man3contract/ct_status_get_ntime.3contract
+usr/src/man/man3contract/ct_status_get_qtime.3contract
+usr/src/man/man3contract/ct_status_get_state.3contract
+usr/src/man/man3contract/ct_status_get_type.3contract
+usr/src/man/man3contract/ct_status_get_zoneid.3contract
+usr/src/man/man3contract/ct_tmpl_clear.3contract
+usr/src/man/man3contract/ct_tmpl_create.3contract
+usr/src/man/man3contract/ct_tmpl_get_cookie.3contract
+usr/src/man/man3contract/ct_tmpl_get_critical.3contract
+usr/src/man/man3contract/ct_tmpl_get_informative.3contract
+usr/src/man/man3contract/ct_tmpl_set_cookie.3contract
+usr/src/man/man3contract/ct_tmpl_set_critical.3contract
+usr/src/man/man3contract/ct_tmpl_set_informative.3contract
+usr/src/man/man3cpc/cpc_bind_cpu.3cpc
+usr/src/man/man3cpc/cpc_bind_pctx.3cpc
+usr/src/man/man3cpc/cpc_buf_add.3cpc
+usr/src/man/man3cpc/cpc_buf_copy.3cpc
+usr/src/man/man3cpc/cpc_buf_destroy.3cpc
+usr/src/man/man3cpc/cpc_buf_get.3cpc
+usr/src/man/man3cpc/cpc_buf_hrtime.3cpc
+usr/src/man/man3cpc/cpc_buf_set.3cpc
+usr/src/man/man3cpc/cpc_buf_sub.3cpc
+usr/src/man/man3cpc/cpc_buf_tick.3cpc
+usr/src/man/man3cpc/cpc_buf_zero.3cpc
+usr/src/man/man3cpc/cpc_caps.3cpc
+usr/src/man/man3cpc/cpc_cciname.3cpc
+usr/src/man/man3cpc/cpc_close.3cpc
+usr/src/man/man3cpc/cpc_count_sys_events.3cpc
+usr/src/man/man3cpc/cpc_cpuref.3cpc
+usr/src/man/man3cpc/cpc_disable.3cpc
+usr/src/man/man3cpc/cpc_event_accum.3cpc
+usr/src/man/man3cpc/cpc_eventtostr.3cpc
+usr/src/man/man3cpc/cpc_getcciname.3cpc
+usr/src/man/man3cpc/cpc_getcpuref.3cpc
+usr/src/man/man3cpc/cpc_getnpic.3cpc
+usr/src/man/man3cpc/cpc_getusage.3cpc
+usr/src/man/man3cpc/cpc_pctx_invalidate.3cpc
+usr/src/man/man3cpc/cpc_pctx_rele.3cpc
+usr/src/man/man3cpc/cpc_pctx_take_sample.3cpc
+usr/src/man/man3cpc/cpc_rele.3cpc
+usr/src/man/man3cpc/cpc_request_preset.3cpc
+usr/src/man/man3cpc/cpc_set_add_request.3cpc
+usr/src/man/man3cpc/cpc_set_destroy.3cpc
+usr/src/man/man3cpc/cpc_set_restart.3cpc
+usr/src/man/man3cpc/cpc_set_sample.3cpc
+usr/src/man/man3cpc/cpc_shared_bind_event.3cpc
+usr/src/man/man3cpc/cpc_shared_close.3cpc
+usr/src/man/man3cpc/cpc_shared_rele.3cpc
+usr/src/man/man3cpc/cpc_shared_take_sample.3cpc
+usr/src/man/man3cpc/cpc_take_sample.3cpc
+usr/src/man/man3cpc/cpc_unbind.3cpc
+usr/src/man/man3cpc/cpc_walk_attrs.3cpc
+usr/src/man/man3cpc/cpc_walk_events_all.3cpc
+usr/src/man/man3cpc/cpc_walk_events_pic.3cpc
+usr/src/man/man3cpc/cpc_walk_generic_events_all.3cpc
+usr/src/man/man3cpc/cpc_walk_generic_events_pic.3cpc
+usr/src/man/man3cpc/cpc_walk_names.3cpc
+usr/src/man/man3cpc/cpc_walk_requests.3cpc
+usr/src/man/man3cpc/pctx_create.3cpc
+usr/src/man/man3cpc/pctx_release.3cpc
+usr/src/man/man3cpc/pctx_run.3cpc
+usr/src/man/man3curses/addch.3curses
+usr/src/man/man3curses/addchnstr.3curses
+usr/src/man/man3curses/addchstr.3curses
+usr/src/man/man3curses/addnstr.3curses
+usr/src/man/man3curses/addnwstr.3curses
+usr/src/man/man3curses/addstr.3curses
+usr/src/man/man3curses/addwch.3curses
+usr/src/man/man3curses/addwchnstr.3curses
+usr/src/man/man3curses/addwchstr.3curses
+usr/src/man/man3curses/addwstr.3curses
+usr/src/man/man3curses/adjcurspos.3curses
+usr/src/man/man3curses/attroff.3curses
+usr/src/man/man3curses/attron.3curses
+usr/src/man/man3curses/attrset.3curses
+usr/src/man/man3curses/baudrate.3curses
+usr/src/man/man3curses/beep.3curses
+usr/src/man/man3curses/bkgd.3curses
+usr/src/man/man3curses/bkgdset.3curses
+usr/src/man/man3curses/border.3curses
+usr/src/man/man3curses/bottom_panel.3curses
+usr/src/man/man3curses/box.3curses
+usr/src/man/man3curses/can_change_color.3curses
+usr/src/man/man3curses/cbreak.3curses
+usr/src/man/man3curses/clear.3curses
+usr/src/man/man3curses/clearok.3curses
+usr/src/man/man3curses/clrtobot.3curses
+usr/src/man/man3curses/clrtoeol.3curses
+usr/src/man/man3curses/color_content.3curses
+usr/src/man/man3curses/copywin.3curses
+usr/src/man/man3curses/current_field.3curses
+usr/src/man/man3curses/current_item.3curses
+usr/src/man/man3curses/curs_set.3curses
+usr/src/man/man3curses/data_ahead.3curses
+usr/src/man/man3curses/data_behind.3curses
+usr/src/man/man3curses/def_prog_mode.3curses
+usr/src/man/man3curses/def_shell_mode.3curses
+usr/src/man/man3curses/del_curterm.3curses
+usr/src/man/man3curses/del_panel.3curses
+usr/src/man/man3curses/delay_output.3curses
+usr/src/man/man3curses/delch.3curses
+usr/src/man/man3curses/deleteln.3curses
+usr/src/man/man3curses/delscreen.3curses
+usr/src/man/man3curses/delwin.3curses
+usr/src/man/man3curses/derwin.3curses
+usr/src/man/man3curses/doupdate.3curses
+usr/src/man/man3curses/dup_field.3curses
+usr/src/man/man3curses/dupwin.3curses
+usr/src/man/man3curses/dynamic_field_info.3curses
+usr/src/man/man3curses/echo.3curses
+usr/src/man/man3curses/echochar.3curses
+usr/src/man/man3curses/echowchar.3curses
+usr/src/man/man3curses/endwin.3curses
+usr/src/man/man3curses/erase.3curses
+usr/src/man/man3curses/erasechar.3curses
+usr/src/man/man3curses/field_arg.3curses
+usr/src/man/man3curses/field_back.3curses
+usr/src/man/man3curses/field_buffer.3curses
+usr/src/man/man3curses/field_count.3curses
+usr/src/man/man3curses/field_fore.3curses
+usr/src/man/man3curses/field_index.3curses
+usr/src/man/man3curses/field_info.3curses
+usr/src/man/man3curses/field_init.3curses
+usr/src/man/man3curses/field_just.3curses
+usr/src/man/man3curses/field_opts.3curses
+usr/src/man/man3curses/field_opts_off.3curses
+usr/src/man/man3curses/field_opts_on.3curses
+usr/src/man/man3curses/field_pad.3curses
+usr/src/man/man3curses/field_status.3curses
+usr/src/man/man3curses/field_term.3curses
+usr/src/man/man3curses/field_type.3curses
+usr/src/man/man3curses/field_userptr.3curses
+usr/src/man/man3curses/filter.3curses
+usr/src/man/man3curses/flash.3curses
+usr/src/man/man3curses/flushinp.3curses
+usr/src/man/man3curses/form_fields.3curses
+usr/src/man/man3curses/form_init.3curses
+usr/src/man/man3curses/form_opts_off.3curses
+usr/src/man/man3curses/form_opts_on.3curses
+usr/src/man/man3curses/form_sub.3curses
+usr/src/man/man3curses/form_term.3curses
+usr/src/man/man3curses/free_field.3curses
+usr/src/man/man3curses/free_fieldtype.3curses
+usr/src/man/man3curses/free_form.3curses
+usr/src/man/man3curses/free_item.3curses
+usr/src/man/man3curses/free_menu.3curses
+usr/src/man/man3curses/getbegyx.3curses
+usr/src/man/man3curses/getch.3curses
+usr/src/man/man3curses/getmaxyx.3curses
+usr/src/man/man3curses/getnwstr.3curses
+usr/src/man/man3curses/getparyx.3curses
+usr/src/man/man3curses/getstr.3curses
+usr/src/man/man3curses/getsyx.3curses
+usr/src/man/man3curses/getwch.3curses
+usr/src/man/man3curses/getwin.3curses
+usr/src/man/man3curses/getwstr.3curses
+usr/src/man/man3curses/getyx.3curses
+usr/src/man/man3curses/halfdelay.3curses
+usr/src/man/man3curses/has_colors.3curses
+usr/src/man/man3curses/has_ic.3curses
+usr/src/man/man3curses/has_il.3curses
+usr/src/man/man3curses/hide_panel.3curses
+usr/src/man/man3curses/idcok.3curses
+usr/src/man/man3curses/idlok.3curses
+usr/src/man/man3curses/immedok.3curses
+usr/src/man/man3curses/inch.3curses
+usr/src/man/man3curses/inchnstr.3curses
+usr/src/man/man3curses/inchstr.3curses
+usr/src/man/man3curses/init_color.3curses
+usr/src/man/man3curses/init_pair.3curses
+usr/src/man/man3curses/initscr.3curses
+usr/src/man/man3curses/innstr.3curses
+usr/src/man/man3curses/innwstr.3curses
+usr/src/man/man3curses/insch.3curses
+usr/src/man/man3curses/insdelln.3curses
+usr/src/man/man3curses/insertln.3curses
+usr/src/man/man3curses/insnstr.3curses
+usr/src/man/man3curses/insnwstr.3curses
+usr/src/man/man3curses/insstr.3curses
+usr/src/man/man3curses/instr.3curses
+usr/src/man/man3curses/inswch.3curses
+usr/src/man/man3curses/inswstr.3curses
+usr/src/man/man3curses/intrflush.3curses
+usr/src/man/man3curses/inwch.3curses
+usr/src/man/man3curses/inwchnstr.3curses
+usr/src/man/man3curses/inwchstr.3curses
+usr/src/man/man3curses/inwstr.3curses
+usr/src/man/man3curses/is_linetouched.3curses
+usr/src/man/man3curses/is_wintouched.3curses
+usr/src/man/man3curses/isendwin.3curses
+usr/src/man/man3curses/item_count.3curses
+usr/src/man/man3curses/item_description.3curses
+usr/src/man/man3curses/item_index.3curses
+usr/src/man/man3curses/item_init.3curses
+usr/src/man/man3curses/item_name.3curses
+usr/src/man/man3curses/item_opts.3curses
+usr/src/man/man3curses/item_opts_off.3curses
+usr/src/man/man3curses/item_opts_on.3curses
+usr/src/man/man3curses/item_term.3curses
+usr/src/man/man3curses/item_userptr.3curses
+usr/src/man/man3curses/item_value.3curses
+usr/src/man/man3curses/item_visible.3curses
+usr/src/man/man3curses/keyname.3curses
+usr/src/man/man3curses/keypad.3curses
+usr/src/man/man3curses/killchar.3curses
+usr/src/man/man3curses/leaveok.3curses
+usr/src/man/man3curses/link_field.3curses
+usr/src/man/man3curses/link_fieldtype.3curses
+usr/src/man/man3curses/longname.3curses
+usr/src/man/man3curses/menu_back.3curses
+usr/src/man/man3curses/menu_fore.3curses
+usr/src/man/man3curses/menu_grey.3curses
+usr/src/man/man3curses/menu_init.3curses
+usr/src/man/man3curses/menu_opts_off.3curses
+usr/src/man/man3curses/menu_opts_on.3curses
+usr/src/man/man3curses/menu_pad.3curses
+usr/src/man/man3curses/menu_sub.3curses
+usr/src/man/man3curses/menu_term.3curses
+usr/src/man/man3curses/meta.3curses
+usr/src/man/man3curses/move.3curses
+usr/src/man/man3curses/move_field.3curses
+usr/src/man/man3curses/move_panel.3curses
+usr/src/man/man3curses/movenextch.3curses
+usr/src/man/man3curses/moveprevch.3curses
+usr/src/man/man3curses/mvaddch.3curses
+usr/src/man/man3curses/mvaddchnstr.3curses
+usr/src/man/man3curses/mvaddchstr.3curses
+usr/src/man/man3curses/mvaddnstr.3curses
+usr/src/man/man3curses/mvaddnwstr.3curses
+usr/src/man/man3curses/mvaddstr.3curses
+usr/src/man/man3curses/mvaddwch.3curses
+usr/src/man/man3curses/mvaddwchnstr.3curses
+usr/src/man/man3curses/mvaddwchstr.3curses
+usr/src/man/man3curses/mvaddwstr.3curses
+usr/src/man/man3curses/mvcur.3curses
+usr/src/man/man3curses/mvdelch.3curses
+usr/src/man/man3curses/mvderwin.3curses
+usr/src/man/man3curses/mvgetch.3curses
+usr/src/man/man3curses/mvgetnwstr.3curses
+usr/src/man/man3curses/mvgetstr.3curses
+usr/src/man/man3curses/mvgetwch.3curses
+usr/src/man/man3curses/mvgetwstr.3curses
+usr/src/man/man3curses/mvinch.3curses
+usr/src/man/man3curses/mvinchnstr.3curses
+usr/src/man/man3curses/mvinchstr.3curses
+usr/src/man/man3curses/mvinnstr.3curses
+usr/src/man/man3curses/mvinnwstr.3curses
+usr/src/man/man3curses/mvinsch.3curses
+usr/src/man/man3curses/mvinsnstr.3curses
+usr/src/man/man3curses/mvinsnwstr.3curses
+usr/src/man/man3curses/mvinsstr.3curses
+usr/src/man/man3curses/mvinstr.3curses
+usr/src/man/man3curses/mvinswch.3curses
+usr/src/man/man3curses/mvinswstr.3curses
+usr/src/man/man3curses/mvinwch.3curses
+usr/src/man/man3curses/mvinwchnstr.3curses
+usr/src/man/man3curses/mvinwchstr.3curses
+usr/src/man/man3curses/mvinwstr.3curses
+usr/src/man/man3curses/mvprintw.3curses
+usr/src/man/man3curses/mvscanw.3curses
+usr/src/man/man3curses/mvwaddch.3curses
+usr/src/man/man3curses/mvwaddchnstr.3curses
+usr/src/man/man3curses/mvwaddchstr.3curses
+usr/src/man/man3curses/mvwaddnstr.3curses
+usr/src/man/man3curses/mvwaddnwstr.3curses
+usr/src/man/man3curses/mvwaddstr.3curses
+usr/src/man/man3curses/mvwaddwch.3curses
+usr/src/man/man3curses/mvwaddwchnstr.3curses
+usr/src/man/man3curses/mvwaddwchstr.3curses
+usr/src/man/man3curses/mvwaddwstr.3curses
+usr/src/man/man3curses/mvwdelch.3curses
+usr/src/man/man3curses/mvwgetch.3curses
+usr/src/man/man3curses/mvwgetnwstr.3curses
+usr/src/man/man3curses/mvwgetstr.3curses
+usr/src/man/man3curses/mvwgetwch.3curses
+usr/src/man/man3curses/mvwgetwstr.3curses
+usr/src/man/man3curses/mvwin.3curses
+usr/src/man/man3curses/mvwinch.3curses
+usr/src/man/man3curses/mvwinchnstr.3curses
+usr/src/man/man3curses/mvwinchstr.3curses
+usr/src/man/man3curses/mvwinnstr.3curses
+usr/src/man/man3curses/mvwinnwstr.3curses
+usr/src/man/man3curses/mvwinsch.3curses
+usr/src/man/man3curses/mvwinsnstr.3curses
+usr/src/man/man3curses/mvwinsnwstr.3curses
+usr/src/man/man3curses/mvwinsstr.3curses
+usr/src/man/man3curses/mvwinstr.3curses
+usr/src/man/man3curses/mvwinswch.3curses
+usr/src/man/man3curses/mvwinswstr.3curses
+usr/src/man/man3curses/mvwinwch.3curses
+usr/src/man/man3curses/mvwinwchnstr.3curses
+usr/src/man/man3curses/mvwinwchstr.3curses
+usr/src/man/man3curses/mvwinwstr.3curses
+usr/src/man/man3curses/mvwprintw.3curses
+usr/src/man/man3curses/mvwscanw.3curses
+usr/src/man/man3curses/napms.3curses
+usr/src/man/man3curses/new_field.3curses
+usr/src/man/man3curses/new_fieldtype.3curses
+usr/src/man/man3curses/new_form.3curses
+usr/src/man/man3curses/new_item.3curses
+usr/src/man/man3curses/new_menu.3curses
+usr/src/man/man3curses/new_page.3curses
+usr/src/man/man3curses/new_panel.3curses
+usr/src/man/man3curses/newpad.3curses
+usr/src/man/man3curses/newterm.3curses
+usr/src/man/man3curses/newwin.3curses
+usr/src/man/man3curses/nl.3curses
+usr/src/man/man3curses/nocbreak.3curses
+usr/src/man/man3curses/nodelay.3curses
+usr/src/man/man3curses/noecho.3curses
+usr/src/man/man3curses/nonl.3curses
+usr/src/man/man3curses/noqiflush.3curses
+usr/src/man/man3curses/noraw.3curses
+usr/src/man/man3curses/notimeout.3curses
+usr/src/man/man3curses/overlay.3curses
+usr/src/man/man3curses/overwrite.3curses
+usr/src/man/man3curses/pair_content.3curses
+usr/src/man/man3curses/panel_below.3curses
+usr/src/man/man3curses/panel_hidden.3curses
+usr/src/man/man3curses/pechochar.3curses
+usr/src/man/man3curses/pechowchar.3curses
+usr/src/man/man3curses/pnoutrefresh.3curses
+usr/src/man/man3curses/pos_form_cursor.3curses
+usr/src/man/man3curses/pos_menu_cursor.3curses
+usr/src/man/man3curses/post_form.3curses
+usr/src/man/man3curses/post_menu.3curses
+usr/src/man/man3curses/prefresh.3curses
+usr/src/man/man3curses/printw.3curses
+usr/src/man/man3curses/putp.3curses
+usr/src/man/man3curses/putwin.3curses
+usr/src/man/man3curses/qiflush.3curses
+usr/src/man/man3curses/raw.3curses
+usr/src/man/man3curses/redrawwin.3curses
+usr/src/man/man3curses/refresh.3curses
+usr/src/man/man3curses/replace_panel.3curses
+usr/src/man/man3curses/reset_prog_mode.3curses
+usr/src/man/man3curses/reset_shell_mode.3curses
+usr/src/man/man3curses/resetty.3curses
+usr/src/man/man3curses/restartterm.3curses
+usr/src/man/man3curses/ripoffline.3curses
+usr/src/man/man3curses/savetty.3curses
+usr/src/man/man3curses/scale_form.3curses
+usr/src/man/man3curses/scale_menu.3curses
+usr/src/man/man3curses/scanw.3curses
+usr/src/man/man3curses/scr_dump.3curses
+usr/src/man/man3curses/scr_init.3curses
+usr/src/man/man3curses/scr_restore.3curses
+usr/src/man/man3curses/scr_set.3curses
+usr/src/man/man3curses/scrl.3curses
+usr/src/man/man3curses/scroll.3curses
+usr/src/man/man3curses/scrollok.3curses
+usr/src/man/man3curses/set_current_field.3curses
+usr/src/man/man3curses/set_current_item.3curses
+usr/src/man/man3curses/set_curterm.3curses
+usr/src/man/man3curses/set_field_back.3curses
+usr/src/man/man3curses/set_field_buffer.3curses
+usr/src/man/man3curses/set_field_fore.3curses
+usr/src/man/man3curses/set_field_init.3curses
+usr/src/man/man3curses/set_field_just.3curses
+usr/src/man/man3curses/set_field_opts.3curses
+usr/src/man/man3curses/set_field_pad.3curses
+usr/src/man/man3curses/set_field_status.3curses
+usr/src/man/man3curses/set_field_term.3curses
+usr/src/man/man3curses/set_field_type.3curses
+usr/src/man/man3curses/set_field_userptr.3curses
+usr/src/man/man3curses/set_fieldtype_arg.3curses
+usr/src/man/man3curses/set_fieldtype_choice.3curses
+usr/src/man/man3curses/set_form_fields.3curses
+usr/src/man/man3curses/set_form_init.3curses
+usr/src/man/man3curses/set_form_opts.3curses
+usr/src/man/man3curses/set_form_page.3curses
+usr/src/man/man3curses/set_form_sub.3curses
+usr/src/man/man3curses/set_form_term.3curses
+usr/src/man/man3curses/set_form_userptr.3curses
+usr/src/man/man3curses/set_form_win.3curses
+usr/src/man/man3curses/set_item_init.3curses
+usr/src/man/man3curses/set_item_opts.3curses
+usr/src/man/man3curses/set_item_term.3curses
+usr/src/man/man3curses/set_item_userptr.3curses
+usr/src/man/man3curses/set_item_value.3curses
+usr/src/man/man3curses/set_max_field.3curses
+usr/src/man/man3curses/set_menu_back.3curses
+usr/src/man/man3curses/set_menu_fore.3curses
+usr/src/man/man3curses/set_menu_format.3curses
+usr/src/man/man3curses/set_menu_grey.3curses
+usr/src/man/man3curses/set_menu_init.3curses
+usr/src/man/man3curses/set_menu_items.3curses
+usr/src/man/man3curses/set_menu_mark.3curses
+usr/src/man/man3curses/set_menu_opts.3curses
+usr/src/man/man3curses/set_menu_pad.3curses
+usr/src/man/man3curses/set_menu_pattern.3curses
+usr/src/man/man3curses/set_menu_sub.3curses
+usr/src/man/man3curses/set_menu_term.3curses
+usr/src/man/man3curses/set_menu_userptr.3curses
+usr/src/man/man3curses/set_menu_win.3curses
+usr/src/man/man3curses/set_new_page.3curses
+usr/src/man/man3curses/set_panel_userptr.3curses
+usr/src/man/man3curses/set_term.3curses
+usr/src/man/man3curses/set_top_row.3curses
+usr/src/man/man3curses/setscrreg.3curses
+usr/src/man/man3curses/setsyx.3curses
+usr/src/man/man3curses/setterm.3curses
+usr/src/man/man3curses/setupterm.3curses
+usr/src/man/man3curses/show_panel.3curses
+usr/src/man/man3curses/slk_attroff.3curses
+usr/src/man/man3curses/slk_attron.3curses
+usr/src/man/man3curses/slk_attrset.3curses
+usr/src/man/man3curses/slk_clear.3curses
+usr/src/man/man3curses/slk_init.3curses
+usr/src/man/man3curses/slk_label.3curses
+usr/src/man/man3curses/slk_noutrefresh.3curses
+usr/src/man/man3curses/slk_refresh.3curses
+usr/src/man/man3curses/slk_restore.3curses
+usr/src/man/man3curses/slk_set.3curses
+usr/src/man/man3curses/slk_touch.3curses
+usr/src/man/man3curses/standend.3curses
+usr/src/man/man3curses/standout.3curses
+usr/src/man/man3curses/start_color.3curses
+usr/src/man/man3curses/subpad.3curses
+usr/src/man/man3curses/subwin.3curses
+usr/src/man/man3curses/syncok.3curses
+usr/src/man/man3curses/termattrs.3curses
+usr/src/man/man3curses/termname.3curses
+usr/src/man/man3curses/tgetent.3curses
+usr/src/man/man3curses/tgetflag.3curses
+usr/src/man/man3curses/tgetnum.3curses
+usr/src/man/man3curses/tgetstr.3curses
+usr/src/man/man3curses/tgoto.3curses
+usr/src/man/man3curses/tigetflag.3curses
+usr/src/man/man3curses/tigetnum.3curses
+usr/src/man/man3curses/tigetstr.3curses
+usr/src/man/man3curses/timeout.3curses
+usr/src/man/man3curses/top_panel.3curses
+usr/src/man/man3curses/top_row.3curses
+usr/src/man/man3curses/touchline.3curses
+usr/src/man/man3curses/touchwin.3curses
+usr/src/man/man3curses/tparm.3curses
+usr/src/man/man3curses/tputs.3curses
+usr/src/man/man3curses/typeahead.3curses
+usr/src/man/man3curses/unctrl.3curses
+usr/src/man/man3curses/ungetch.3curses
+usr/src/man/man3curses/ungetwch.3curses
+usr/src/man/man3curses/unpost_form.3curses
+usr/src/man/man3curses/unpost_menu.3curses
+usr/src/man/man3curses/untouchwin.3curses
+usr/src/man/man3curses/update_panels.3curses
+usr/src/man/man3curses/use_env.3curses
+usr/src/man/man3curses/vidattr.3curses
+usr/src/man/man3curses/vidputs.3curses
+usr/src/man/man3curses/vwprintw.3curses
+usr/src/man/man3curses/vwscanw.3curses
+usr/src/man/man3curses/waddch.3curses
+usr/src/man/man3curses/waddchnstr.3curses
+usr/src/man/man3curses/waddchstr.3curses
+usr/src/man/man3curses/waddnstr.3curses
+usr/src/man/man3curses/waddnwstr.3curses
+usr/src/man/man3curses/waddstr.3curses
+usr/src/man/man3curses/waddwch.3curses
+usr/src/man/man3curses/waddwchnstr.3curses
+usr/src/man/man3curses/waddwchstr.3curses
+usr/src/man/man3curses/waddwstr.3curses
+usr/src/man/man3curses/wadjcurspos.3curses
+usr/src/man/man3curses/wattroff.3curses
+usr/src/man/man3curses/wattron.3curses
+usr/src/man/man3curses/wattrset.3curses
+usr/src/man/man3curses/wbkgd.3curses
+usr/src/man/man3curses/wbkgdset.3curses
+usr/src/man/man3curses/wborder.3curses
+usr/src/man/man3curses/wclear.3curses
+usr/src/man/man3curses/wclrtobot.3curses
+usr/src/man/man3curses/wclrtoeol.3curses
+usr/src/man/man3curses/wcursyncup.3curses
+usr/src/man/man3curses/wdelch.3curses
+usr/src/man/man3curses/wdeleteln.3curses
+usr/src/man/man3curses/wechochar.3curses
+usr/src/man/man3curses/wechowchar.3curses
+usr/src/man/man3curses/werase.3curses
+usr/src/man/man3curses/wgetch.3curses
+usr/src/man/man3curses/wgetnstr.3curses
+usr/src/man/man3curses/wgetnwstr.3curses
+usr/src/man/man3curses/wgetstr.3curses
+usr/src/man/man3curses/wgetwch.3curses
+usr/src/man/man3curses/wgetwstr.3curses
+usr/src/man/man3curses/whline.3curses
+usr/src/man/man3curses/winch.3curses
+usr/src/man/man3curses/winchnstr.3curses
+usr/src/man/man3curses/winchstr.3curses
+usr/src/man/man3curses/winnstr.3curses
+usr/src/man/man3curses/winnwstr.3curses
+usr/src/man/man3curses/winsch.3curses
+usr/src/man/man3curses/winsdelln.3curses
+usr/src/man/man3curses/winsertln.3curses
+usr/src/man/man3curses/winsnstr.3curses
+usr/src/man/man3curses/winsnwstr.3curses
+usr/src/man/man3curses/winsstr.3curses
+usr/src/man/man3curses/winstr.3curses
+usr/src/man/man3curses/winswch.3curses
+usr/src/man/man3curses/winswstr.3curses
+usr/src/man/man3curses/winwch.3curses
+usr/src/man/man3curses/winwchnstr.3curses
+usr/src/man/man3curses/winwchstr.3curses
+usr/src/man/man3curses/winwstr.3curses
+usr/src/man/man3curses/wmove.3curses
+usr/src/man/man3curses/wmovenextch.3curses
+usr/src/man/man3curses/wmoveprevch.3curses
+usr/src/man/man3curses/wnoutrefresh.3curses
+usr/src/man/man3curses/wprintw.3curses
+usr/src/man/man3curses/wredrawln.3curses
+usr/src/man/man3curses/wrefresh.3curses
+usr/src/man/man3curses/wscanw.3curses
+usr/src/man/man3curses/wscrl.3curses
+usr/src/man/man3curses/wsetscrreg.3curses
+usr/src/man/man3curses/wstandend.3curses
+usr/src/man/man3curses/wstandout.3curses
+usr/src/man/man3curses/wsyncdown.3curses
+usr/src/man/man3curses/wsyncup.3curses
+usr/src/man/man3curses/wtimeout.3curses
+usr/src/man/man3curses/wtouchln.3curses
+usr/src/man/man3curses/wvline.3curses
+usr/src/man/man3devid/devid_compare.3devid
+usr/src/man/man3devid/devid_deviceid_to_nmlist.3devid
+usr/src/man/man3devid/devid_free.3devid
+usr/src/man/man3devid/devid_free_nmlist.3devid
+usr/src/man/man3devid/devid_get_minor_name.3devid
+usr/src/man/man3devid/devid_sizeof.3devid
+usr/src/man/man3devid/devid_str_decode.3devid
+usr/src/man/man3devid/devid_str_encode.3devid
+usr/src/man/man3devid/devid_str_free.3devid
+usr/src/man/man3devid/devid_valid.3devid
+usr/src/man/man3devinfo/di_bus_addr.3devinfo
+usr/src/man/man3devinfo/di_compatible_names.3devinfo
+usr/src/man/man3devinfo/di_devfs_minor_path.3devinfo
+usr/src/man/man3devinfo/di_devfs_path_free.3devinfo
+usr/src/man/man3devinfo/di_devid.3devinfo
+usr/src/man/man3devinfo/di_devlink_content.3devinfo
+usr/src/man/man3devinfo/di_devlink_fini.3devinfo
+usr/src/man/man3devinfo/di_devlink_free.3devinfo
+usr/src/man/man3devinfo/di_devlink_type.3devinfo
+usr/src/man/man3devinfo/di_driver_major.3devinfo
+usr/src/man/man3devinfo/di_driver_name.3devinfo
+usr/src/man/man3devinfo/di_driver_ops.3devinfo
+usr/src/man/man3devinfo/di_drv_first_node.3devinfo
+usr/src/man/man3devinfo/di_drv_next_node.3devinfo
+usr/src/man/man3devinfo/di_fini.3devinfo
+usr/src/man/man3devinfo/di_instance.3devinfo
+usr/src/man/man3devinfo/di_link_next_by_lnode.3devinfo
+usr/src/man/man3devinfo/di_link_private_get.3devinfo
+usr/src/man/man3devinfo/di_link_private_set.3devinfo
+usr/src/man/man3devinfo/di_link_to_lnode.3devinfo
+usr/src/man/man3devinfo/di_lnode_devinfo.3devinfo
+usr/src/man/man3devinfo/di_lnode_devt.3devinfo
+usr/src/man/man3devinfo/di_lnode_private_get.3devinfo
+usr/src/man/man3devinfo/di_lnode_private_set.3devinfo
+usr/src/man/man3devinfo/di_minor_name.3devinfo
+usr/src/man/man3devinfo/di_minor_nodetype.3devinfo
+usr/src/man/man3devinfo/di_minor_private_get.3devinfo
+usr/src/man/man3devinfo/di_minor_private_set.3devinfo
+usr/src/man/man3devinfo/di_minor_spectype.3devinfo
+usr/src/man/man3devinfo/di_node_name.3devinfo
+usr/src/man/man3devinfo/di_node_private_get.3devinfo
+usr/src/man/man3devinfo/di_nodeid.3devinfo
+usr/src/man/man3devinfo/di_parent_node.3devinfo
+usr/src/man/man3devinfo/di_path_client_devfs_path.3devinfo
+usr/src/man/man3devinfo/di_path_client_node.3devinfo
+usr/src/man/man3devinfo/di_path_devfs_path.3devinfo
+usr/src/man/man3devinfo/di_path_instance.3devinfo
+usr/src/man/man3devinfo/di_path_node_name.3devinfo
+usr/src/man/man3devinfo/di_path_phci_next_path.3devinfo
+usr/src/man/man3devinfo/di_path_phci_node.3devinfo
+usr/src/man/man3devinfo/di_path_private_get.3devinfo
+usr/src/man/man3devinfo/di_path_private_set.3devinfo
+usr/src/man/man3devinfo/di_path_prop_int64s.3devinfo
+usr/src/man/man3devinfo/di_path_prop_ints.3devinfo
+usr/src/man/man3devinfo/di_path_prop_lookup_int64s.3devinfo
+usr/src/man/man3devinfo/di_path_prop_lookup_ints.3devinfo
+usr/src/man/man3devinfo/di_path_prop_lookup_strings.3devinfo
+usr/src/man/man3devinfo/di_path_prop_name.3devinfo
+usr/src/man/man3devinfo/di_path_prop_strings.3devinfo
+usr/src/man/man3devinfo/di_path_prop_type.3devinfo
+usr/src/man/man3devinfo/di_path_state.3devinfo
+usr/src/man/man3devinfo/di_prom_fini.3devinfo
+usr/src/man/man3devinfo/di_prom_prop_lookup_ints.3devinfo
+usr/src/man/man3devinfo/di_prom_prop_lookup_strings.3devinfo
+usr/src/man/man3devinfo/di_prom_prop_name.3devinfo
+usr/src/man/man3devinfo/di_prom_prop_next.3devinfo
+usr/src/man/man3devinfo/di_prop_devt.3devinfo
+usr/src/man/man3devinfo/di_prop_int64.3devinfo
+usr/src/man/man3devinfo/di_prop_ints.3devinfo
+usr/src/man/man3devinfo/di_prop_lookup_int64.3devinfo
+usr/src/man/man3devinfo/di_prop_lookup_ints.3devinfo
+usr/src/man/man3devinfo/di_prop_lookup_strings.3devinfo
+usr/src/man/man3devinfo/di_prop_name.3devinfo
+usr/src/man/man3devinfo/di_prop_strings.3devinfo
+usr/src/man/man3devinfo/di_prop_type.3devinfo
+usr/src/man/man3devinfo/di_sibling_node.3devinfo
+usr/src/man/man3dlpi/dlpi_disabmulti.3dlpi
+usr/src/man/man3dlpi/dlpi_promiscoff.3dlpi
+usr/src/man/man3dns_sd/DNSServiceAddRecord.3dns_sd
+usr/src/man/man3dns_sd/DNSServiceRegisterRecord.3dns_sd
+usr/src/man/man3dns_sd/DNSServiceRemoveRecord.3dns_sd
+usr/src/man/man3dns_sd/DNSServiceUpdateRecord.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordContainsKey.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordDeallocate.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordGetBytesPtr.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordGetCount.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordGetItemAtIndex.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordGetLength.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordGetValuePtr.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordRemoveValue.3dns_sd
+usr/src/man/man3dns_sd/TXTRecordSetValue.3dns_sd
+usr/src/man/man3elf/elf32_newehdr.3elf
+usr/src/man/man3elf/elf32_newphdr.3elf
+usr/src/man/man3elf/elf32_xlatetom.3elf
+usr/src/man/man3elf/elf64_checksum.3elf
+usr/src/man/man3elf/elf64_fsize.3elf
+usr/src/man/man3elf/elf64_getehdr.3elf
+usr/src/man/man3elf/elf64_getphdr.3elf
+usr/src/man/man3elf/elf64_getshdr.3elf
+usr/src/man/man3elf/elf64_newehdr.3elf
+usr/src/man/man3elf/elf64_newphdr.3elf
+usr/src/man/man3elf/elf64_xlatetof.3elf
+usr/src/man/man3elf/elf64_xlatetom.3elf
+usr/src/man/man3elf/elf_end.3elf
+usr/src/man/man3elf/elf_errno.3elf
+usr/src/man/man3elf/elf_flagehdr.3elf
+usr/src/man/man3elf/elf_flagelf.3elf
+usr/src/man/man3elf/elf_flagphdr.3elf
+usr/src/man/man3elf/elf_flagscn.3elf
+usr/src/man/man3elf/elf_flagshdr.3elf
+usr/src/man/man3elf/elf_getphdrnum.3elf
+usr/src/man/man3elf/elf_getphnum.3elf
+usr/src/man/man3elf/elf_getshdrnum.3elf
+usr/src/man/man3elf/elf_getshdrstrndx.3elf
+usr/src/man/man3elf/elf_getshnum.3elf
+usr/src/man/man3elf/elf_getshstrndx.3elf
+usr/src/man/man3elf/elf_memory.3elf
+usr/src/man/man3elf/elf_ndxscn.3elf
+usr/src/man/man3elf/elf_newdata.3elf
+usr/src/man/man3elf/elf_newscn.3elf
+usr/src/man/man3elf/elf_next.3elf
+usr/src/man/man3elf/elf_nextscn.3elf
+usr/src/man/man3elf/elf_rand.3elf
+usr/src/man/man3elf/elf_rawdata.3elf
+usr/src/man/man3elf/gelf_checksum.3elf
+usr/src/man/man3elf/gelf_fsize.3elf
+usr/src/man/man3elf/gelf_getcap.3elf
+usr/src/man/man3elf/gelf_getclass.3elf
+usr/src/man/man3elf/gelf_getdyn.3elf
+usr/src/man/man3elf/gelf_getehdr.3elf
+usr/src/man/man3elf/gelf_getmove.3elf
+usr/src/man/man3elf/gelf_getphdr.3elf
+usr/src/man/man3elf/gelf_getrel.3elf
+usr/src/man/man3elf/gelf_getrela.3elf
+usr/src/man/man3elf/gelf_getshdr.3elf
+usr/src/man/man3elf/gelf_getsym.3elf
+usr/src/man/man3elf/gelf_getsyminfo.3elf
+usr/src/man/man3elf/gelf_getsymshndx.3elf
+usr/src/man/man3elf/gelf_newehdr.3elf
+usr/src/man/man3elf/gelf_newphdr.3elf
+usr/src/man/man3elf/gelf_update_cap.3elf
+usr/src/man/man3elf/gelf_update_dyn.3elf
+usr/src/man/man3elf/gelf_update_ehdr.3elf
+usr/src/man/man3elf/gelf_update_getmove.3elf
+usr/src/man/man3elf/gelf_update_move.3elf
+usr/src/man/man3elf/gelf_update_phdr.3elf
+usr/src/man/man3elf/gelf_update_rel.3elf
+usr/src/man/man3elf/gelf_update_rela.3elf
+usr/src/man/man3elf/gelf_update_shdr.3elf
+usr/src/man/man3elf/gelf_update_sym.3elf
+usr/src/man/man3elf/gelf_update_syminfo.3elf
+usr/src/man/man3elf/gelf_update_symshndx.3elf
+usr/src/man/man3elf/gelf_xlatetof.3elf
+usr/src/man/man3elf/gelf_xlatetom.3elf
+usr/src/man/man3exacct/ea_alloc.3exacct
+usr/src/man/man3exacct/ea_attach_to_group.3exacct
+usr/src/man/man3exacct/ea_attach_to_object.3exacct
+usr/src/man/man3exacct/ea_close.3exacct
+usr/src/man/man3exacct/ea_copy_object.3exacct
+usr/src/man/man3exacct/ea_copy_object_tree.3exacct
+usr/src/man/man3exacct/ea_free.3exacct
+usr/src/man/man3exacct/ea_free_item.3exacct
+usr/src/man/man3exacct/ea_free_object.3exacct
+usr/src/man/man3exacct/ea_get_creator.3exacct
+usr/src/man/man3exacct/ea_get_hostname.3exacct
+usr/src/man/man3exacct/ea_get_object.3exacct
+usr/src/man/man3exacct/ea_get_object_tree.3exacct
+usr/src/man/man3exacct/ea_match_object_catalog.3exacct
+usr/src/man/man3exacct/ea_next_object.3exacct
+usr/src/man/man3exacct/ea_previous_object.3exacct
+usr/src/man/man3exacct/ea_set_group.3exacct
+usr/src/man/man3exacct/ea_strdup.3exacct
+usr/src/man/man3exacct/ea_strfree.3exacct
+usr/src/man/man3exacct/ea_unpack_object.3exacct
+usr/src/man/man3exacct/ea_write_object.3exacct
+usr/src/man/man3ext/DES_FAILED.3ext
+usr/src/man/man3ext/MD4Final.3ext
+usr/src/man/man3ext/MD4Init.3ext
+usr/src/man/man3ext/MD4Update.3ext
+usr/src/man/man3ext/MD5Final.3ext
+usr/src/man/man3ext/MD5Init.3ext
+usr/src/man/man3ext/MD5Update.3ext
+usr/src/man/man3ext/SHA1Final.3ext
+usr/src/man/man3ext/SHA1Init.3ext
+usr/src/man/man3ext/SHA1Update.3ext
+usr/src/man/man3ext/SHA256Final.3ext
+usr/src/man/man3ext/SHA256Init.3ext
+usr/src/man/man3ext/SHA256Update.3ext
+usr/src/man/man3ext/SHA2Final.3ext
+usr/src/man/man3ext/SHA2Init.3ext
+usr/src/man/man3ext/SHA2Update.3ext
+usr/src/man/man3ext/SHA384Final.3ext
+usr/src/man/man3ext/SHA384Init.3ext
+usr/src/man/man3ext/SHA384Update.3ext
+usr/src/man/man3ext/SHA512Final.3ext
+usr/src/man/man3ext/SHA512Init.3ext
+usr/src/man/man3ext/SHA512Update.3ext
+usr/src/man/man3ext/SUNW_C_KeyToObject.3ext
+usr/src/man/man3ext/_NOTE.3ext
+usr/src/man/man3ext/auto_ef_file.3ext
+usr/src/man/man3ext/auto_ef_free.3ext
+usr/src/man/man3ext/auto_ef_get_encoding.3ext
+usr/src/man/man3ext/auto_ef_get_score.3ext
+usr/src/man/man3ext/auto_ef_str.3ext
+usr/src/man/man3ext/cbc_crypt.3ext
+usr/src/man/man3ext/cplus_demangle.3ext
+usr/src/man/man3ext/crypt_close.3ext
+usr/src/man/man3ext/des_crypt.3ext
+usr/src/man/man3ext/des_encrypt.3ext
+usr/src/man/man3ext/des_setkey.3ext
+usr/src/man/man3ext/des_setparity.3ext
+usr/src/man/man3ext/efi_alloc_and_read.3ext
+usr/src/man/man3ext/efi_free.3ext
+usr/src/man/man3ext/efi_use_whole_disk.3ext
+usr/src/man/man3ext/efi_write.3ext
+usr/src/man/man3ext/encrypt.3ext
+usr/src/man/man3ext/la_activity.3ext
+usr/src/man/man3ext/la_amd64_pltenter.3ext
+usr/src/man/man3ext/la_i86_pltenter.3ext
+usr/src/man/man3ext/la_objfilter.3ext
+usr/src/man/man3ext/la_objopen.3ext
+usr/src/man/man3ext/la_objsearch.3ext
+usr/src/man/man3ext/la_pltexit.3ext
+usr/src/man/man3ext/la_pltexit64.3ext
+usr/src/man/man3ext/la_preinit.3ext
+usr/src/man/man3ext/la_sparcv8_pltenter.3ext
+usr/src/man/man3ext/la_sparcv9_pltenter.3ext
+usr/src/man/man3ext/la_symbind32.3ext
+usr/src/man/man3ext/la_symbind64.3ext
+usr/src/man/man3ext/la_version.3ext
+usr/src/man/man3ext/ld_atexit.3ext
+usr/src/man/man3ext/ld_atexit64.3ext
+usr/src/man/man3ext/ld_file.3ext
+usr/src/man/man3ext/ld_file64.3ext
+usr/src/man/man3ext/ld_input_done.3ext
+usr/src/man/man3ext/ld_input_section.3ext
+usr/src/man/man3ext/ld_input_section64.3ext
+usr/src/man/man3ext/ld_open.3ext
+usr/src/man/man3ext/ld_open64.3ext
+usr/src/man/man3ext/ld_section.3ext
+usr/src/man/man3ext/ld_section64.3ext
+usr/src/man/man3ext/ld_start.3ext
+usr/src/man/man3ext/ld_start64.3ext
+usr/src/man/man3ext/ld_version.3ext
+usr/src/man/man3ext/md5_calc.3ext
+usr/src/man/man3ext/rd_delete.3ext
+usr/src/man/man3ext/rd_errstr.3ext
+usr/src/man/man3ext/rd_event_addr.3ext
+usr/src/man/man3ext/rd_event_enable.3ext
+usr/src/man/man3ext/rd_event_getmsg.3ext
+usr/src/man/man3ext/rd_init.3ext
+usr/src/man/man3ext/rd_loadobj_iter.3ext
+usr/src/man/man3ext/rd_log.3ext
+usr/src/man/man3ext/rd_new.3ext
+usr/src/man/man3ext/rd_objpad_enable.3ext
+usr/src/man/man3ext/rd_plt_resolution.3ext
+usr/src/man/man3ext/rd_reset.3ext
+usr/src/man/man3ext/run_crypt.3ext
+usr/src/man/man3ext/run_setkey.3ext
+usr/src/man/man3ext/setkey.3ext
+usr/src/man/man3ext/tsalarm_set.3ext
+usr/src/man/man3ext/write_vtoc.3ext
+usr/src/man/man3fstyp/fstyp_fini.3fstyp
+usr/src/man/man3fstyp/fstyp_mod_dump.3fstyp
+usr/src/man/man3fstyp/fstyp_mod_fini.3fstyp
+usr/src/man/man3fstyp/fstyp_mod_get_attr.3fstyp
+usr/src/man/man3fstyp/fstyp_mod_ident.3fstyp
+usr/src/man/man3gen/advance.3gen
+usr/src/man/man3gen/compile.3gen
+usr/src/man/man3gen/p2close.3gen
+usr/src/man/man3gen/rmdirp.3gen
+usr/src/man/man3gen/step.3gen
+usr/src/man/man3gen/str.3gen
+usr/src/man/man3gen/strcadd.3gen
+usr/src/man/man3gen/streadd.3gen
+usr/src/man/man3gen/strecpy.3gen
+usr/src/man/man3gen/strrspn.3gen
+usr/src/man/man3gen/strtrns.3gen
+usr/src/man/man3head/acct.3head
+usr/src/man/man3head/aio.3head
+usr/src/man/man3head/ar.3head
+usr/src/man/man3head/archives.3head
+usr/src/man/man3head/assert.3head
+usr/src/man/man3head/complex.3head
+usr/src/man/man3head/cpio.3head
+usr/src/man/man3head/dirent.3head
+usr/src/man/man3head/errno.3head
+usr/src/man/man3head/fcntl.3head
+usr/src/man/man3head/fenv.3head
+usr/src/man/man3head/float.3head
+usr/src/man/man3head/floatingpoint.3head
+usr/src/man/man3head/fmtmsg.3head
+usr/src/man/man3head/fnmatch.3head
+usr/src/man/man3head/ftw.3head
+usr/src/man/man3head/glob.3head
+usr/src/man/man3head/grp.3head
+usr/src/man/man3head/iconv.3head
+usr/src/man/man3head/if.3head
+usr/src/man/man3head/in.3head
+usr/src/man/man3head/inet.3head
+usr/src/man/man3head/inttypes.3head
+usr/src/man/man3head/ipc.3head
+usr/src/man/man3head/iso646.3head
+usr/src/man/man3head/langinfo.3head
+usr/src/man/man3head/libgen.3head
+usr/src/man/man3head/libintl.3head
+usr/src/man/man3head/limits.3head
+usr/src/man/man3head/locale.3head
+usr/src/man/man3head/math.3head
+usr/src/man/man3head/mman.3head
+usr/src/man/man3head/monetary.3head
+usr/src/man/man3head/mqueue.3head
+usr/src/man/man3head/msg.3head
+usr/src/man/man3head/ndbm.3head
+usr/src/man/man3head/netdb.3head
+usr/src/man/man3head/nl_types.3head
+usr/src/man/man3head/poll.3head
+usr/src/man/man3head/pthread.3head
+usr/src/man/man3head/pwd.3head
+usr/src/man/man3head/regex.3head
+usr/src/man/man3head/resource.3head
+usr/src/man/man3head/sched.3head
+usr/src/man/man3head/search.3head
+usr/src/man/man3head/select.3head
+usr/src/man/man3head/sem.3head
+usr/src/man/man3head/semaphore.3head
+usr/src/man/man3head/setjmp.3head
+usr/src/man/man3head/shm.3head
+usr/src/man/man3head/siginfo.3head
+usr/src/man/man3head/signal.3head
+usr/src/man/man3head/socket.3head
+usr/src/man/man3head/spawn.3head
+usr/src/man/man3head/stat.3head
+usr/src/man/man3head/statvfs.3head
+usr/src/man/man3head/stdbool.3head
+usr/src/man/man3head/stddef.3head
+usr/src/man/man3head/stdint.3head
+usr/src/man/man3head/stdio.3head
+usr/src/man/man3head/stdlib.3head
+usr/src/man/man3head/string.3head
+usr/src/man/man3head/strings.3head
+usr/src/man/man3head/stropts.3head
+usr/src/man/man3head/syslog.3head
+usr/src/man/man3head/tar.3head
+usr/src/man/man3head/tcp.3head
+usr/src/man/man3head/termios.3head
+usr/src/man/man3head/tgmath.3head
+usr/src/man/man3head/time.3head
+usr/src/man/man3head/timeb.3head
+usr/src/man/man3head/times.3head
+usr/src/man/man3head/types.3head
+usr/src/man/man3head/types32.3head
+usr/src/man/man3head/ucontext.3head
+usr/src/man/man3head/uio.3head
+usr/src/man/man3head/ulimit.3head
+usr/src/man/man3head/un.3head
+usr/src/man/man3head/unistd.3head
+usr/src/man/man3head/utime.3head
+usr/src/man/man3head/utmpx.3head
+usr/src/man/man3head/utsname.3head
+usr/src/man/man3head/values.3head
+usr/src/man/man3head/wait.3head
+usr/src/man/man3head/wchar.3head
+usr/src/man/man3head/wctype.3head
+usr/src/man/man3head/wordexp.3head
+usr/src/man/man3iscsit/it_config_commit.3iscsit
+usr/src/man/man3iscsit/it_config_free.3iscsit
+usr/src/man/man3iscsit/it_config_setprop.3iscsit
+usr/src/man/man3iscsit/it_ini_delete.3iscsit
+usr/src/man/man3iscsit/it_ini_free.3iscsit
+usr/src/man/man3iscsit/it_ini_setprop.3iscsit
+usr/src/man/man3iscsit/it_portal_delete.3iscsit
+usr/src/man/man3iscsit/it_tgt_delete.3iscsit
+usr/src/man/man3iscsit/it_tgt_free.3iscsit
+usr/src/man/man3iscsit/it_tgt_setprop.3iscsit
+usr/src/man/man3iscsit/it_tpg_delete.3iscsit
+usr/src/man/man3iscsit/it_tpg_free.3iscsit
+usr/src/man/man3iscsit/it_tpgt_create.3iscsit
+usr/src/man/man3iscsit/it_tpgt_delete.3iscsit
+usr/src/man/man3iscsit/it_tpgt_free.3iscsit
+usr/src/man/man3kstat/kstat_close.3kstat
+usr/src/man/man3kstat/kstat_data_lookup.3kstat
+usr/src/man/man3kstat/kstat_write.3kstat
+usr/src/man/man3kvm/kvm_close.3kvm
+usr/src/man/man3kvm/kvm_getcmd.3kvm
+usr/src/man/man3kvm/kvm_getproc.3kvm
+usr/src/man/man3kvm/kvm_kwrite.3kvm
+usr/src/man/man3kvm/kvm_setproc.3kvm
+usr/src/man/man3kvm/kvm_uread.3kvm
+usr/src/man/man3kvm/kvm_uwrite.3kvm
+usr/src/man/man3kvm/kvm_write.3kvm
+usr/src/man/man3ldap/ber_alloc.3ldap
+usr/src/man/man3ldap/ber_alloc_t.3ldap
+usr/src/man/man3ldap/ber_bvdup.3ldap
+usr/src/man/man3ldap/ber_bvecfree.3ldap
+usr/src/man/man3ldap/ber_bvfree.3ldap
+usr/src/man/man3ldap/ber_first_element.3ldap
+usr/src/man/man3ldap/ber_flatten.3ldap
+usr/src/man/man3ldap/ber_free.3ldap
+usr/src/man/man3ldap/ber_get_bitstring.3ldap
+usr/src/man/man3ldap/ber_get_boolean.3ldap
+usr/src/man/man3ldap/ber_get_int.3ldap
+usr/src/man/man3ldap/ber_get_next.3ldap
+usr/src/man/man3ldap/ber_get_null.3ldap
+usr/src/man/man3ldap/ber_get_stringa.3ldap
+usr/src/man/man3ldap/ber_get_stringal.3ldap
+usr/src/man/man3ldap/ber_get_stringb.3ldap
+usr/src/man/man3ldap/ber_init.3ldap
+usr/src/man/man3ldap/ber_next_element.3ldap
+usr/src/man/man3ldap/ber_peek_tag.3ldap
+usr/src/man/man3ldap/ber_printf.3ldap
+usr/src/man/man3ldap/ber_put_bitstring.3ldap
+usr/src/man/man3ldap/ber_put_boolean.3ldap
+usr/src/man/man3ldap/ber_put_int.3ldap
+usr/src/man/man3ldap/ber_put_null.3ldap
+usr/src/man/man3ldap/ber_put_ostring.3ldap
+usr/src/man/man3ldap/ber_put_seq.3ldap
+usr/src/man/man3ldap/ber_put_set.3ldap
+usr/src/man/man3ldap/ber_put_string.3ldap
+usr/src/man/man3ldap/ber_scanf.3ldap
+usr/src/man/man3ldap/ber_skip_tag.3ldap
+usr/src/man/man3ldap/ber_start_seq.3ldap
+usr/src/man/man3ldap/ber_start_set.3ldap
+usr/src/man/man3ldap/ldap_8859_to_t61.3ldap
+usr/src/man/man3ldap/ldap_add_ext.3ldap
+usr/src/man/man3ldap/ldap_add_ext_s.3ldap
+usr/src/man/man3ldap/ldap_add_s.3ldap
+usr/src/man/man3ldap/ldap_bind_s.3ldap
+usr/src/man/man3ldap/ldap_build_filter.3ldap
+usr/src/man/man3ldap/ldap_compare_ext.3ldap
+usr/src/man/man3ldap/ldap_compare_ext_s.3ldap
+usr/src/man/man3ldap/ldap_compare_s.3ldap
+usr/src/man/man3ldap/ldap_controls_free.3ldap
+usr/src/man/man3ldap/ldap_count_entries.3ldap
+usr/src/man/man3ldap/ldap_count_messages.3ldap
+usr/src/man/man3ldap/ldap_count_references.3ldap
+usr/src/man/man3ldap/ldap_count_values.3ldap
+usr/src/man/man3ldap/ldap_count_values_len.3ldap
+usr/src/man/man3ldap/ldap_delete_ext.3ldap
+usr/src/man/man3ldap/ldap_delete_ext_s.3ldap
+usr/src/man/man3ldap/ldap_delete_s.3ldap
+usr/src/man/man3ldap/ldap_dn2ufn.3ldap
+usr/src/man/man3ldap/ldap_dn_to_url.3ldap
+usr/src/man/man3ldap/ldap_dns_to_dn.3ldap
+usr/src/man/man3ldap/ldap_dns_to_url.3ldap
+usr/src/man/man3ldap/ldap_enable_translation.3ldap
+usr/src/man/man3ldap/ldap_entry2html.3ldap
+usr/src/man/man3ldap/ldap_entry2html_search.3ldap
+usr/src/man/man3ldap/ldap_entry2text_search.3ldap
+usr/src/man/man3ldap/ldap_err2string.3ldap
+usr/src/man/man3ldap/ldap_explode_dn.3ldap
+usr/src/man/man3ldap/ldap_explode_dns.3ldap
+usr/src/man/man3ldap/ldap_first_disptmpl.3ldap
+usr/src/man/man3ldap/ldap_first_reference.3ldap
+usr/src/man/man3ldap/ldap_first_searchobj.3ldap
+usr/src/man/man3ldap/ldap_first_tmplcol.3ldap
+usr/src/man/man3ldap/ldap_first_tmplrow.3ldap
+usr/src/man/man3ldap/ldap_free_friendlymap.3ldap
+usr/src/man/man3ldap/ldap_free_searchprefs.3ldap
+usr/src/man/man3ldap/ldap_free_templates.3ldap
+usr/src/man/man3ldap/ldap_free_urldesc.3ldap
+usr/src/man/man3ldap/ldap_friendly_name.3ldap
+usr/src/man/man3ldap/ldap_get_lang_values_len.3ldap
+usr/src/man/man3ldap/ldap_get_values_len.3ldap
+usr/src/man/man3ldap/ldap_getfilter_free.3ldap
+usr/src/man/man3ldap/ldap_getfirstfilter.3ldap
+usr/src/man/man3ldap/ldap_getnextfilter.3ldap
+usr/src/man/man3ldap/ldap_init.3ldap
+usr/src/man/man3ldap/ldap_init_getfilter.3ldap
+usr/src/man/man3ldap/ldap_init_getfilter_buf.3ldap
+usr/src/man/man3ldap/ldap_init_searchprefs.3ldap
+usr/src/man/man3ldap/ldap_init_searchprefs_buf.3ldap
+usr/src/man/man3ldap/ldap_init_templates.3ldap
+usr/src/man/man3ldap/ldap_init_templates_buf.3ldap
+usr/src/man/man3ldap/ldap_is_dns_dn.3ldap
+usr/src/man/man3ldap/ldap_is_ldap_url.3ldap
+usr/src/man/man3ldap/ldap_memcache_destroy.3ldap
+usr/src/man/man3ldap/ldap_memcache_flush.3ldap
+usr/src/man/man3ldap/ldap_memcache_get.3ldap
+usr/src/man/man3ldap/ldap_memcache_init.3ldap
+usr/src/man/man3ldap/ldap_memcache_set.3ldap
+usr/src/man/man3ldap/ldap_memcache_update.3ldap
+usr/src/man/man3ldap/ldap_modify_ext.3ldap
+usr/src/man/man3ldap/ldap_modify_ext_s.3ldap
+usr/src/man/man3ldap/ldap_modify_s.3ldap
+usr/src/man/man3ldap/ldap_modrdn2.3ldap
+usr/src/man/man3ldap/ldap_modrdn2_s.3ldap
+usr/src/man/man3ldap/ldap_modrdn_s.3ldap
+usr/src/man/man3ldap/ldap_mods_free.3ldap
+usr/src/man/man3ldap/ldap_msgfree.3ldap
+usr/src/man/man3ldap/ldap_msgtype.3ldap
+usr/src/man/man3ldap/ldap_name2template.3ldap
+usr/src/man/man3ldap/ldap_next_attribute.3ldap
+usr/src/man/man3ldap/ldap_next_disptmpl.3ldap
+usr/src/man/man3ldap/ldap_next_entry.3ldap
+usr/src/man/man3ldap/ldap_next_message.3ldap
+usr/src/man/man3ldap/ldap_next_reference.3ldap
+usr/src/man/man3ldap/ldap_next_searchobj.3ldap
+usr/src/man/man3ldap/ldap_next_tmplcol.3ldap
+usr/src/man/man3ldap/ldap_next_tmplrow.3ldap
+usr/src/man/man3ldap/ldap_oc2template.3ldap
+usr/src/man/man3ldap/ldap_parse_extended_result.3ldap
+usr/src/man/man3ldap/ldap_parse_sasl_bind_result.3ldap
+usr/src/man/man3ldap/ldap_perror.3ldap
+usr/src/man/man3ldap/ldap_rename.3ldap
+usr/src/man/man3ldap/ldap_rename_s.3ldap
+usr/src/man/man3ldap/ldap_result2error.3ldap
+usr/src/man/man3ldap/ldap_sasl_bind.3ldap
+usr/src/man/man3ldap/ldap_sasl_bind_s.3ldap
+usr/src/man/man3ldap/ldap_sasl_interactive_bind_s.3ldap
+usr/src/man/man3ldap/ldap_search_ext.3ldap
+usr/src/man/man3ldap/ldap_search_ext_s.3ldap
+usr/src/man/man3ldap/ldap_search_s.3ldap
+usr/src/man/man3ldap/ldap_search_st.3ldap
+usr/src/man/man3ldap/ldap_set_option.3ldap
+usr/src/man/man3ldap/ldap_set_rebind_proc.3ldap
+usr/src/man/man3ldap/ldap_set_string_translators.3ldap
+usr/src/man/man3ldap/ldap_setfilteraffixes.3ldap
+usr/src/man/man3ldap/ldap_simple_bind.3ldap
+usr/src/man/man3ldap/ldap_simple_bind_s.3ldap
+usr/src/man/man3ldap/ldap_sort_entries.3ldap
+usr/src/man/man3ldap/ldap_sort_strcasecmp.3ldap
+usr/src/man/man3ldap/ldap_sort_values.3ldap
+usr/src/man/man3ldap/ldap_t61_to_8859.3ldap
+usr/src/man/man3ldap/ldap_tmplattrs.3ldap
+usr/src/man/man3ldap/ldap_translate_from_t61.3ldap
+usr/src/man/man3ldap/ldap_translate_to_t61.3ldap
+usr/src/man/man3ldap/ldap_ufn_search_c.3ldap
+usr/src/man/man3ldap/ldap_ufn_search_ct.3ldap
+usr/src/man/man3ldap/ldap_ufn_search_s.3ldap
+usr/src/man/man3ldap/ldap_ufn_setfilter.3ldap
+usr/src/man/man3ldap/ldap_ufn_setprefix.3ldap
+usr/src/man/man3ldap/ldap_ufn_timeout.3ldap
+usr/src/man/man3ldap/ldap_unbind.3ldap
+usr/src/man/man3ldap/ldap_unbind_ext.3ldap
+usr/src/man/man3ldap/ldap_unbind_s.3ldap
+usr/src/man/man3ldap/ldap_url_parse.3ldap
+usr/src/man/man3ldap/ldap_url_parse_nodn.3ldap
+usr/src/man/man3ldap/ldap_url_search.3ldap
+usr/src/man/man3ldap/ldap_url_search_s.3ldap
+usr/src/man/man3ldap/ldap_url_search_st.3ldap
+usr/src/man/man3ldap/ldap_vals2html.3ldap
+usr/src/man/man3ldap/ldap_vals2text.3ldap
+usr/src/man/man3ldap/ldap_value_free.3ldap
+usr/src/man/man3ldap/ldap_value_free_len.3ldap
+usr/src/man/man3lgrp/lgrp_affinity_set.3lgrp
+usr/src/man/man3lgrp/lgrp_latency_cookie.3lgrp
+usr/src/man/man3lib/SMHBA_GetAdapterAttributes.3lib
+usr/src/man/man3lib/SMHBA_GetAdapterPortAttributes.3lib
+usr/src/man/man3lib/SMHBA_GetBindingCapability.3lib
+usr/src/man/man3lib/SMHBA_GetBindingSupport.3lib
+usr/src/man/man3lib/SMHBA_GetDiscoveredPortAttributes.3lib
+usr/src/man/man3lib/SMHBA_GetFCPhyAttributes.3lib
+usr/src/man/man3lib/SMHBA_GetLUNStatistics.3lib
+usr/src/man/man3lib/SMHBA_GetNumberofPorts.3lib
+usr/src/man/man3lib/SMHBA_GetPersistentBinding.3lib
+usr/src/man/man3lib/SMHBA_GetPhyStatistics.3lib
+usr/src/man/man3lib/SMHBA_GetPortAttributesByWWN.3lib
+usr/src/man/man3lib/SMHBA_GetPortType.3lib
+usr/src/man/man3lib/SMHBA_GetProtocolStatistics.3lib
+usr/src/man/man3lib/SMHBA_GetSASPhyAttributes.3lib
+usr/src/man/man3lib/SMHBA_GetTargetMapping.3lib
+usr/src/man/man3lib/SMHBA_GetVendorLibraryAttributes.3lib
+usr/src/man/man3lib/SMHBA_GetVersion.3lib
+usr/src/man/man3lib/SMHBA_GetWrapperLibraryAttributes.3lib
+usr/src/man/man3lib/SMHBA_RegisterForAdapterAddEvents.3lib
+usr/src/man/man3lib/SMHBA_RegisterForAdapterEvents.3lib
+usr/src/man/man3lib/SMHBA_RegisterForAdapterPhyStatEvents.3lib
+usr/src/man/man3lib/SMHBA_RegisterForAdapterPortEvents.3lib
+usr/src/man/man3lib/SMHBA_RegisterForAdapterPortStatEvents.3lib
+usr/src/man/man3lib/SMHBA_RegisterForTargetEvents.3lib
+usr/src/man/man3lib/SMHBA_RegisterLibrary.3lib
+usr/src/man/man3lib/SMHBA_RemoveAllPersistentBindings.3lib
+usr/src/man/man3lib/SMHBA_RemovePersistentBinding.3lib
+usr/src/man/man3lib/SMHBA_ScsiInquiry.3lib
+usr/src/man/man3lib/SMHBA_ScsiReadCapacity.3lib
+usr/src/man/man3lib/SMHBA_ScsiReportLuns.3lib
+usr/src/man/man3lib/SMHBA_SendECHO.3lib
+usr/src/man/man3lib/SMHBA_SendSMPPassThru.3lib
+usr/src/man/man3lib/SMHBA_SendTEST.3lib
+usr/src/man/man3lib/SMHBA_SetBindingSupport.3lib
+usr/src/man/man3lib/SMHBA_SetPersistentBinding.3lib
+usr/src/man/man3lib/libmpapi.3lib
+usr/src/man/man3lib/libposix4.3lib
+usr/src/man/man3lib/libsmhbaapi.3lib
+usr/src/man/man3lib/libtermcap.3lib
+usr/src/man/man3lib/libtermlib.3lib
+usr/src/man/man3mail/mailunlock.3mail
+usr/src/man/man3mail/touchlock.3mail
+usr/src/man/man3malloc/calloc.3malloc
+usr/src/man/man3malloc/free.3malloc
+usr/src/man/man3malloc/mallinfo.3malloc
+usr/src/man/man3malloc/mallocctl.3malloc
+usr/src/man/man3malloc/mallopt.3malloc
+usr/src/man/man3malloc/memalign.3malloc
+usr/src/man/man3malloc/realloc.3malloc
+usr/src/man/man3malloc/umem_cache_alloc.3malloc
+usr/src/man/man3malloc/umem_cache_destroy.3malloc
+usr/src/man/man3malloc/umem_cache_free.3malloc
+usr/src/man/man3malloc/umem_free.3malloc
+usr/src/man/man3malloc/umem_nofail_callback.3malloc
+usr/src/man/man3malloc/umem_zalloc.3malloc
+usr/src/man/man3malloc/valloc.3malloc
+usr/src/man/man3mp/mp_gcd.3mp
+usr/src/man/man3mp/mp_itom.3mp
+usr/src/man/man3mp/mp_madd.3mp
+usr/src/man/man3mp/mp_mcmp.3mp
+usr/src/man/man3mp/mp_mdiv.3mp
+usr/src/man/man3mp/mp_mfree.3mp
+usr/src/man/man3mp/mp_min.3mp
+usr/src/man/man3mp/mp_mout.3mp
+usr/src/man/man3mp/mp_msqrt.3mp
+usr/src/man/man3mp/mp_msub.3mp
+usr/src/man/man3mp/mp_mtox.3mp
+usr/src/man/man3mp/mp_mult.3mp
+usr/src/man/man3mp/mp_pow.3mp
+usr/src/man/man3mp/mp_rpow.3mp
+usr/src/man/man3mp/mp_sdiv.3mp
+usr/src/man/man3mp/mp_xtom.3mp
+usr/src/man/man3nsl/auth_destroy.3nsl
+usr/src/man/man3nsl/authdes_create.3nsl
+usr/src/man/man3nsl/authdes_getucred.3nsl
+usr/src/man/man3nsl/authdes_seccreate.3nsl
+usr/src/man/man3nsl/authnone_create.3nsl
+usr/src/man/man3nsl/authsys_create.3nsl
+usr/src/man/man3nsl/authsys_create_default.3nsl
+usr/src/man/man3nsl/authunix_create.3nsl
+usr/src/man/man3nsl/authunix_create_default.3nsl
+usr/src/man/man3nsl/callrpc.3nsl
+usr/src/man/man3nsl/clnt_broadcast.3nsl
+usr/src/man/man3nsl/clnt_call.3nsl
+usr/src/man/man3nsl/clnt_control.3nsl
+usr/src/man/man3nsl/clnt_create.3nsl
+usr/src/man/man3nsl/clnt_create_timed.3nsl
+usr/src/man/man3nsl/clnt_create_vers.3nsl
+usr/src/man/man3nsl/clnt_create_vers_timed.3nsl
+usr/src/man/man3nsl/clnt_destroy.3nsl
+usr/src/man/man3nsl/clnt_dg_create.3nsl
+usr/src/man/man3nsl/clnt_door_create.3nsl
+usr/src/man/man3nsl/clnt_freeres.3nsl
+usr/src/man/man3nsl/clnt_geterr.3nsl
+usr/src/man/man3nsl/clnt_pcreateerror.3nsl
+usr/src/man/man3nsl/clnt_perrno.3nsl
+usr/src/man/man3nsl/clnt_perror.3nsl
+usr/src/man/man3nsl/clnt_raw_create.3nsl
+usr/src/man/man3nsl/clnt_send.3nsl
+usr/src/man/man3nsl/clnt_spcreateerror.3nsl
+usr/src/man/man3nsl/clnt_sperrno.3nsl
+usr/src/man/man3nsl/clnt_sperror.3nsl
+usr/src/man/man3nsl/clnt_tli_create.3nsl
+usr/src/man/man3nsl/clnt_tp_create.3nsl
+usr/src/man/man3nsl/clnt_tp_create_timed.3nsl
+usr/src/man/man3nsl/clnt_vc_create.3nsl
+usr/src/man/man3nsl/clntraw_create.3nsl
+usr/src/man/man3nsl/clnttcp_create.3nsl
+usr/src/man/man3nsl/clntudp_bufcreate.3nsl
+usr/src/man/man3nsl/clntudp_create.3nsl
+usr/src/man/man3nsl/endhostent.3nsl
+usr/src/man/man3nsl/endnetconfig.3nsl
+usr/src/man/man3nsl/endnetpath.3nsl
+usr/src/man/man3nsl/endrpcent.3nsl
+usr/src/man/man3nsl/freeipsecalgent.3nsl
+usr/src/man/man3nsl/freenetconfigent.3nsl
+usr/src/man/man3nsl/get_myaddress.3nsl
+usr/src/man/man3nsl/gethostbyaddr.3nsl
+usr/src/man/man3nsl/gethostbyaddr_r.3nsl
+usr/src/man/man3nsl/gethostbyname_r.3nsl
+usr/src/man/man3nsl/gethostent.3nsl
+usr/src/man/man3nsl/gethostent_r.3nsl
+usr/src/man/man3nsl/getipsecalgbynum.3nsl
+usr/src/man/man3nsl/getipsecprotobynum.3nsl
+usr/src/man/man3nsl/getnetconfigent.3nsl
+usr/src/man/man3nsl/getnetname.3nsl
+usr/src/man/man3nsl/getrpcbyname_r.3nsl
+usr/src/man/man3nsl/getrpcbynumber.3nsl
+usr/src/man/man3nsl/getrpcbynumber_r.3nsl
+usr/src/man/man3nsl/getrpcent.3nsl
+usr/src/man/man3nsl/getrpcent_r.3nsl
+usr/src/man/man3nsl/getrpcport.3nsl
+usr/src/man/man3nsl/getsecretkey.3nsl
+usr/src/man/man3nsl/host2netname.3nsl
+usr/src/man/man3nsl/key_decryptsession.3nsl
+usr/src/man/man3nsl/key_encryptsession.3nsl
+usr/src/man/man3nsl/key_gendes.3nsl
+usr/src/man/man3nsl/key_secretkey_is_set.3nsl
+usr/src/man/man3nsl/key_setsecret.3nsl
+usr/src/man/man3nsl/nc_perror.3nsl
+usr/src/man/man3nsl/nc_sperror.3nsl
+usr/src/man/man3nsl/netdir_free.3nsl
+usr/src/man/man3nsl/netdir_getbyaddr.3nsl
+usr/src/man/man3nsl/netdir_getbyname.3nsl
+usr/src/man/man3nsl/netdir_mergeaddr.3nsl
+usr/src/man/man3nsl/netdir_options.3nsl
+usr/src/man/man3nsl/netdir_perror.3nsl
+usr/src/man/man3nsl/netdir_sperror.3nsl
+usr/src/man/man3nsl/netname2host.3nsl
+usr/src/man/man3nsl/netname2user.3nsl
+usr/src/man/man3nsl/pmap_getmaps.3nsl
+usr/src/man/man3nsl/pmap_getport.3nsl
+usr/src/man/man3nsl/pmap_rmtcall.3nsl
+usr/src/man/man3nsl/pmap_set.3nsl
+usr/src/man/man3nsl/pmap_unset.3nsl
+usr/src/man/man3nsl/publickey.3nsl
+usr/src/man/man3nsl/registerrpc.3nsl
+usr/src/man/man3nsl/rpc_broadcast.3nsl
+usr/src/man/man3nsl/rpc_broadcast_exp.3nsl
+usr/src/man/man3nsl/rpc_call.3nsl
+usr/src/man/man3nsl/rpc_createerr.3nsl
+usr/src/man/man3nsl/rpc_gss_get_mech_info.3nsl
+usr/src/man/man3nsl/rpc_gss_get_versions.3nsl
+usr/src/man/man3nsl/rpc_gss_is_installed.3nsl
+usr/src/man/man3nsl/rpc_gss_qop_to_num.3nsl
+usr/src/man/man3nsl/rpc_gss_svc_max_data_length.3nsl
+usr/src/man/man3nsl/rpc_reg.3nsl
+usr/src/man/man3nsl/rpcb_getaddr.3nsl
+usr/src/man/man3nsl/rpcb_getmaps.3nsl
+usr/src/man/man3nsl/rpcb_gettime.3nsl
+usr/src/man/man3nsl/rpcb_rmtcall.3nsl
+usr/src/man/man3nsl/rpcb_set.3nsl
+usr/src/man/man3nsl/rpcb_unset.3nsl
+usr/src/man/man3nsl/sethostent.3nsl
+usr/src/man/man3nsl/setnetconfig.3nsl
+usr/src/man/man3nsl/setnetpath.3nsl
+usr/src/man/man3nsl/setrpcent.3nsl
+usr/src/man/man3nsl/svc_add_input.3nsl
+usr/src/man/man3nsl/svc_auth_reg.3nsl
+usr/src/man/man3nsl/svc_control.3nsl
+usr/src/man/man3nsl/svc_create.3nsl
+usr/src/man/man3nsl/svc_destroy.3nsl
+usr/src/man/man3nsl/svc_dg_create.3nsl
+usr/src/man/man3nsl/svc_dg_enablecache.3nsl
+usr/src/man/man3nsl/svc_done.3nsl
+usr/src/man/man3nsl/svc_door_create.3nsl
+usr/src/man/man3nsl/svc_exit.3nsl
+usr/src/man/man3nsl/svc_fd_create.3nsl
+usr/src/man/man3nsl/svc_fd_negotiate_ucred.3nsl
+usr/src/man/man3nsl/svc_fds.3nsl
+usr/src/man/man3nsl/svc_fdset.3nsl
+usr/src/man/man3nsl/svc_freeargs.3nsl
+usr/src/man/man3nsl/svc_getargs.3nsl
+usr/src/man/man3nsl/svc_getcaller.3nsl
+usr/src/man/man3nsl/svc_getcallerucred.3nsl
+usr/src/man/man3nsl/svc_getreq.3nsl
+usr/src/man/man3nsl/svc_getreq_common.3nsl
+usr/src/man/man3nsl/svc_getreq_poll.3nsl
+usr/src/man/man3nsl/svc_getreqset.3nsl
+usr/src/man/man3nsl/svc_getrpccaller.3nsl
+usr/src/man/man3nsl/svc_max_pollfd.3nsl
+usr/src/man/man3nsl/svc_pollfd.3nsl
+usr/src/man/man3nsl/svc_raw_create.3nsl
+usr/src/man/man3nsl/svc_reg.3nsl
+usr/src/man/man3nsl/svc_register.3nsl
+usr/src/man/man3nsl/svc_remove_input.3nsl
+usr/src/man/man3nsl/svc_run.3nsl
+usr/src/man/man3nsl/svc_sendreply.3nsl
+usr/src/man/man3nsl/svc_tli_create.3nsl
+usr/src/man/man3nsl/svc_tp_create.3nsl
+usr/src/man/man3nsl/svc_unreg.3nsl
+usr/src/man/man3nsl/svc_unregister.3nsl
+usr/src/man/man3nsl/svc_vc_create.3nsl
+usr/src/man/man3nsl/svcerr_auth.3nsl
+usr/src/man/man3nsl/svcerr_decode.3nsl
+usr/src/man/man3nsl/svcerr_noproc.3nsl
+usr/src/man/man3nsl/svcerr_noprog.3nsl
+usr/src/man/man3nsl/svcerr_progvers.3nsl
+usr/src/man/man3nsl/svcerr_systemerr.3nsl
+usr/src/man/man3nsl/svcerr_weakauth.3nsl
+usr/src/man/man3nsl/svcfd_create.3nsl
+usr/src/man/man3nsl/svcraw_create.3nsl
+usr/src/man/man3nsl/svctcp_create.3nsl
+usr/src/man/man3nsl/svcudp_bufcreate.3nsl
+usr/src/man/man3nsl/svcudp_create.3nsl
+usr/src/man/man3nsl/taddr2uaddr.3nsl
+usr/src/man/man3nsl/uaddr2taddr.3nsl
+usr/src/man/man3nsl/undial.3nsl
+usr/src/man/man3nsl/user2netname.3nsl
+usr/src/man/man3nsl/xdr_accepted_reply.3nsl
+usr/src/man/man3nsl/xdr_array.3nsl
+usr/src/man/man3nsl/xdr_authsys_parms.3nsl
+usr/src/man/man3nsl/xdr_authunix_parms.3nsl
+usr/src/man/man3nsl/xdr_bool.3nsl
+usr/src/man/man3nsl/xdr_bytes.3nsl
+usr/src/man/man3nsl/xdr_callhdr.3nsl
+usr/src/man/man3nsl/xdr_callmsg.3nsl
+usr/src/man/man3nsl/xdr_char.3nsl
+usr/src/man/man3nsl/xdr_control.3nsl
+usr/src/man/man3nsl/xdr_destroy.3nsl
+usr/src/man/man3nsl/xdr_double.3nsl
+usr/src/man/man3nsl/xdr_enum.3nsl
+usr/src/man/man3nsl/xdr_float.3nsl
+usr/src/man/man3nsl/xdr_free.3nsl
+usr/src/man/man3nsl/xdr_getpos.3nsl
+usr/src/man/man3nsl/xdr_hyper.3nsl
+usr/src/man/man3nsl/xdr_inline.3nsl
+usr/src/man/man3nsl/xdr_int.3nsl
+usr/src/man/man3nsl/xdr_long.3nsl
+usr/src/man/man3nsl/xdr_longlong_t.3nsl
+usr/src/man/man3nsl/xdr_opaque.3nsl
+usr/src/man/man3nsl/xdr_opaque_auth.3nsl
+usr/src/man/man3nsl/xdr_pointer.3nsl
+usr/src/man/man3nsl/xdr_quadruple.3nsl
+usr/src/man/man3nsl/xdr_reference.3nsl
+usr/src/man/man3nsl/xdr_rejected_reply.3nsl
+usr/src/man/man3nsl/xdr_replymsg.3nsl
+usr/src/man/man3nsl/xdr_setpos.3nsl
+usr/src/man/man3nsl/xdr_short.3nsl
+usr/src/man/man3nsl/xdr_sizeof.3nsl
+usr/src/man/man3nsl/xdr_string.3nsl
+usr/src/man/man3nsl/xdr_u_char.3nsl
+usr/src/man/man3nsl/xdr_u_hyper.3nsl
+usr/src/man/man3nsl/xdr_u_int.3nsl
+usr/src/man/man3nsl/xdr_u_long.3nsl
+usr/src/man/man3nsl/xdr_u_longlong_t.3nsl
+usr/src/man/man3nsl/xdr_u_short.3nsl
+usr/src/man/man3nsl/xdr_union.3nsl
+usr/src/man/man3nsl/xdr_vector.3nsl
+usr/src/man/man3nsl/xdr_void.3nsl
+usr/src/man/man3nsl/xdr_wrapstring.3nsl
+usr/src/man/man3nsl/xdrmem_create.3nsl
+usr/src/man/man3nsl/xdrrec_create.3nsl
+usr/src/man/man3nsl/xdrrec_endofrecord.3nsl
+usr/src/man/man3nsl/xdrrec_eof.3nsl
+usr/src/man/man3nsl/xdrrec_readbytes.3nsl
+usr/src/man/man3nsl/xdrrec_skiprecord.3nsl
+usr/src/man/man3nsl/xdrstdio_create.3nsl
+usr/src/man/man3nsl/xprt_register.3nsl
+usr/src/man/man3nsl/xprt_unregister.3nsl
+usr/src/man/man3nsl/yp_all.3nsl
+usr/src/man/man3nsl/yp_bind.3nsl
+usr/src/man/man3nsl/yp_first.3nsl
+usr/src/man/man3nsl/yp_get_default_domain.3nsl
+usr/src/man/man3nsl/yp_master.3nsl
+usr/src/man/man3nsl/yp_match.3nsl
+usr/src/man/man3nsl/yp_next.3nsl
+usr/src/man/man3nsl/yp_order.3nsl
+usr/src/man/man3nsl/yp_unbind.3nsl
+usr/src/man/man3nsl/yperr_string.3nsl
+usr/src/man/man3nsl/ypprot_err.3nsl
+usr/src/man/man3nvpair/nv_alloc_fini.3nvpair
+usr/src/man/man3nvpair/nv_alloc_init.3nvpair
+usr/src/man/man3nvpair/nv_alloc_reset.3nvpair
+usr/src/man/man3nvpair/nvlist_add_boolean_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_boolean_value.3nvpair
+usr/src/man/man3nvpair/nvlist_add_byte.3nvpair
+usr/src/man/man3nvpair/nvlist_add_byte_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_double.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int16.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int16_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int32.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int32_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int64.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int64_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int8.3nvpair
+usr/src/man/man3nvpair/nvlist_add_int8_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_nvlist.3nvpair
+usr/src/man/man3nvpair/nvlist_add_nvlist_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_nvpair.3nvpair
+usr/src/man/man3nvpair/nvlist_add_string.3nvpair
+usr/src/man/man3nvpair/nvlist_add_string_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint16.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint16_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint32.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint32_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint64.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint64_array.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint8.3nvpair
+usr/src/man/man3nvpair/nvlist_add_uint8_array.3nvpair
+usr/src/man/man3nvpair/nvlist_dup.3nvpair
+usr/src/man/man3nvpair/nvlist_exists.3nvpair
+usr/src/man/man3nvpair/nvlist_free.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_boolean_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_boolean_value.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_byte.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_byte_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_double.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int16.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int16_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int32.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int32_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int64.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int64_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int8.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_int8_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_nv_alloc.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_nvlist.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_nvlist_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_pairs.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_string.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_string_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint16.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint16_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint32.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint32_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint64.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint64_array.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint8.3nvpair
+usr/src/man/man3nvpair/nvlist_lookup_uint8_array.3nvpair
+usr/src/man/man3nvpair/nvlist_merge.3nvpair
+usr/src/man/man3nvpair/nvlist_pack.3nvpair
+usr/src/man/man3nvpair/nvlist_remove_all.3nvpair
+usr/src/man/man3nvpair/nvlist_size.3nvpair
+usr/src/man/man3nvpair/nvlist_unpack.3nvpair
+usr/src/man/man3nvpair/nvlist_xalloc.3nvpair
+usr/src/man/man3nvpair/nvlist_xdup.3nvpair
+usr/src/man/man3nvpair/nvlist_xpack.3nvpair
+usr/src/man/man3nvpair/nvlist_xunpack.3nvpair
+usr/src/man/man3nvpair/nvpair_name.3nvpair
+usr/src/man/man3nvpair/nvpair_type.3nvpair
+usr/src/man/man3nvpair/nvpair_value_boolean_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_boolean_value.3nvpair
+usr/src/man/man3nvpair/nvpair_value_byte_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_double.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int16.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int16_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int32.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int32_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int64.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int64_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int8.3nvpair
+usr/src/man/man3nvpair/nvpair_value_int8_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_nvlist.3nvpair
+usr/src/man/man3nvpair/nvpair_value_nvlist_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_string.3nvpair
+usr/src/man/man3nvpair/nvpair_value_string_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint16.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint16_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint32.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint32_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint64.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint64_array.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint8.3nvpair
+usr/src/man/man3nvpair/nvpair_value_uint8_array.3nvpair
+usr/src/man/man3pam/pam_close_session.3pam
+usr/src/man/man3pam/pam_end.3pam
+usr/src/man/man3pam/pam_get_data.3pam
+usr/src/man/man3pam/pam_get_item.3pam
+usr/src/man/man3pam/pam_sm_close_session.3pam
+usr/src/man/man3papi/papiAttributeListAddBoolean.3papi
+usr/src/man/man3papi/papiAttributeListAddCollection.3papi
+usr/src/man/man3papi/papiAttributeListAddDatetime.3papi
+usr/src/man/man3papi/papiAttributeListAddInteger.3papi
+usr/src/man/man3papi/papiAttributeListAddMetadata.3papi
+usr/src/man/man3papi/papiAttributeListAddRange.3papi
+usr/src/man/man3papi/papiAttributeListAddResolution.3papi
+usr/src/man/man3papi/papiAttributeListAddString.3papi
+usr/src/man/man3papi/papiAttributeListDelete.3papi
+usr/src/man/man3papi/papiAttributeListFind.3papi
+usr/src/man/man3papi/papiAttributeListFree.3papi
+usr/src/man/man3papi/papiAttributeListFromString.3papi
+usr/src/man/man3papi/papiAttributeListGetBoolean.3papi
+usr/src/man/man3papi/papiAttributeListGetCollection.3papi
+usr/src/man/man3papi/papiAttributeListGetDatetime.3papi
+usr/src/man/man3papi/papiAttributeListGetInteger.3papi
+usr/src/man/man3papi/papiAttributeListGetMetadata.3papi
+usr/src/man/man3papi/papiAttributeListGetNext.3papi
+usr/src/man/man3papi/papiAttributeListGetRange.3papi
+usr/src/man/man3papi/papiAttributeListGetResolution.3papi
+usr/src/man/man3papi/papiAttributeListGetString.3papi
+usr/src/man/man3papi/papiAttributeListGetValue.3papi
+usr/src/man/man3papi/papiAttributeListToString.3papi
+usr/src/man/man3papi/papiJobCancel.3papi
+usr/src/man/man3papi/papiJobFree.3papi
+usr/src/man/man3papi/papiJobGetAttributeList.3papi
+usr/src/man/man3papi/papiJobGetId.3papi
+usr/src/man/man3papi/papiJobGetJobTicket.3papi
+usr/src/man/man3papi/papiJobGetPrinterName.3papi
+usr/src/man/man3papi/papiJobHold.3papi
+usr/src/man/man3papi/papiJobListFree.3papi
+usr/src/man/man3papi/papiJobModify.3papi
+usr/src/man/man3papi/papiJobMove.3papi
+usr/src/man/man3papi/papiJobPromote.3papi
+usr/src/man/man3papi/papiJobQuery.3papi
+usr/src/man/man3papi/papiJobRelease.3papi
+usr/src/man/man3papi/papiJobRestart.3papi
+usr/src/man/man3papi/papiJobStreamClose.3papi
+usr/src/man/man3papi/papiJobStreamOpen.3papi
+usr/src/man/man3papi/papiJobStreamWrite.3papi
+usr/src/man/man3papi/papiJobSubmitByReference.3papi
+usr/src/man/man3papi/papiJobValidate.3papi
+usr/src/man/man3papi/papiLibrarySupportedCalls.3papi
+usr/src/man/man3papi/papiPrinterAdd.3papi
+usr/src/man/man3papi/papiPrinterDisable.3papi
+usr/src/man/man3papi/papiPrinterEnable.3papi
+usr/src/man/man3papi/papiPrinterFree.3papi
+usr/src/man/man3papi/papiPrinterGetAttributeList.3papi
+usr/src/man/man3papi/papiPrinterListFree.3papi
+usr/src/man/man3papi/papiPrinterListJobs.3papi
+usr/src/man/man3papi/papiPrinterModify.3papi
+usr/src/man/man3papi/papiPrinterPause.3papi
+usr/src/man/man3papi/papiPrinterPurgeJobs.3papi
+usr/src/man/man3papi/papiPrinterQuery.3papi
+usr/src/man/man3papi/papiPrinterRemove.3papi
+usr/src/man/man3papi/papiPrinterResume.3papi
+usr/src/man/man3papi/papiServiceDestroy.3papi
+usr/src/man/man3papi/papiServiceGetAppData.3papi
+usr/src/man/man3papi/papiServiceGetAttributeList.3papi
+usr/src/man/man3papi/papiServiceGetEncryption.3papi
+usr/src/man/man3papi/papiServiceGetPassword.3papi
+usr/src/man/man3papi/papiServiceGetServiceName.3papi
+usr/src/man/man3papi/papiServiceGetStatusMessage.3papi
+usr/src/man/man3papi/papiServiceGetUserName.3papi
+usr/src/man/man3papi/papiServiceSetAppData.3papi
+usr/src/man/man3papi/papiServiceSetAuthCB.3papi
+usr/src/man/man3papi/papiServiceSetEncryption.3papi
+usr/src/man/man3papi/papiServiceSetPassword.3papi
+usr/src/man/man3papi/papiServiceSetUserName.3papi
+usr/src/man/man3picl/picl_get_next_by_col.3picl
+usr/src/man/man3picl/picl_get_next_prop.3picl
+usr/src/man/man3picl/picl_get_propval_by_name.3picl
+usr/src/man/man3picl/picl_set_propval_by_name.3picl
+usr/src/man/man3picltree/ptree_add_row_to_table.3picltree
+usr/src/man/man3picltree/ptree_delete_node.3picltree
+usr/src/man/man3picltree/ptree_delete_prop.3picltree
+usr/src/man/man3picltree/ptree_destroy_node.3picltree
+usr/src/man/man3picltree/ptree_destroy_prop.3picltree
+usr/src/man/man3picltree/ptree_get_next_by_col.3picltree
+usr/src/man/man3picltree/ptree_get_next_prop.3picltree
+usr/src/man/man3picltree/ptree_get_propval_by_name.3picltree
+usr/src/man/man3picltree/ptree_update_propval_by_name.3picltree
+usr/src/man/man3pool/pool_conf_close.3pool
+usr/src/man/man3pool/pool_conf_commit.3pool
+usr/src/man/man3pool/pool_conf_export.3pool
+usr/src/man/man3pool/pool_conf_free.3pool
+usr/src/man/man3pool/pool_conf_info.3pool
+usr/src/man/man3pool/pool_conf_location.3pool
+usr/src/man/man3pool/pool_conf_open.3pool
+usr/src/man/man3pool/pool_conf_remove.3pool
+usr/src/man/man3pool/pool_conf_rollback.3pool
+usr/src/man/man3pool/pool_conf_status.3pool
+usr/src/man/man3pool/pool_conf_to_elem.3pool
+usr/src/man/man3pool/pool_conf_update.3pool
+usr/src/man/man3pool/pool_conf_validate.3pool
+usr/src/man/man3pool/pool_create.3pool
+usr/src/man/man3pool/pool_destroy.3pool
+usr/src/man/man3pool/pool_dissociate.3pool
+usr/src/man/man3pool/pool_get_owning_resource.3pool
+usr/src/man/man3pool/pool_get_resource.3pool
+usr/src/man/man3pool/pool_get_resource_binding.3pool
+usr/src/man/man3pool/pool_get_status.3pool
+usr/src/man/man3pool/pool_info.3pool
+usr/src/man/man3pool/pool_put_property.3pool
+usr/src/man/man3pool/pool_query_components.3pool
+usr/src/man/man3pool/pool_query_pool_resources.3pool
+usr/src/man/man3pool/pool_query_pools.3pool
+usr/src/man/man3pool/pool_query_resource_components.3pool
+usr/src/man/man3pool/pool_query_resources.3pool
+usr/src/man/man3pool/pool_resource_destroy.3pool
+usr/src/man/man3pool/pool_resource_info.3pool
+usr/src/man/man3pool/pool_resource_to_elem.3pool
+usr/src/man/man3pool/pool_resource_transfer.3pool
+usr/src/man/man3pool/pool_resource_type_list.3pool
+usr/src/man/man3pool/pool_resource_xtransfer.3pool
+usr/src/man/man3pool/pool_rm_property.3pool
+usr/src/man/man3pool/pool_set_binding.3pool
+usr/src/man/man3pool/pool_set_status.3pool
+usr/src/man/man3pool/pool_static_location.3pool
+usr/src/man/man3pool/pool_strerror.3pool
+usr/src/man/man3pool/pool_to_elem.3pool
+usr/src/man/man3pool/pool_value_free.3pool
+usr/src/man/man3pool/pool_value_get_bool.3pool
+usr/src/man/man3pool/pool_value_get_double.3pool
+usr/src/man/man3pool/pool_value_get_int64.3pool
+usr/src/man/man3pool/pool_value_get_name.3pool
+usr/src/man/man3pool/pool_value_get_string.3pool
+usr/src/man/man3pool/pool_value_get_type.3pool
+usr/src/man/man3pool/pool_value_get_uint64.3pool
+usr/src/man/man3pool/pool_value_set_bool.3pool
+usr/src/man/man3pool/pool_value_set_double.3pool
+usr/src/man/man3pool/pool_value_set_int64.3pool
+usr/src/man/man3pool/pool_value_set_name.3pool
+usr/src/man/man3pool/pool_value_set_string.3pool
+usr/src/man/man3pool/pool_value_set_uint64.3pool
+usr/src/man/man3pool/pool_version.3pool
+usr/src/man/man3pool/pool_walk_pools.3pool
+usr/src/man/man3pool/pool_walk_properties.3pool
+usr/src/man/man3pool/pool_walk_resources.3pool
+usr/src/man/man3proc/ps_kill.3proc
+usr/src/man/man3proc/ps_lcontinue.3proc
+usr/src/man/man3proc/ps_lgetfpregs.3proc
+usr/src/man/man3proc/ps_lgetxregs.3proc
+usr/src/man/man3proc/ps_lgetxregsize.3proc
+usr/src/man/man3proc/ps_lrolltoaddr.3proc
+usr/src/man/man3proc/ps_lsetfpregs.3proc
+usr/src/man/man3proc/ps_lsetregs.3proc
+usr/src/man/man3proc/ps_lsetxregs.3proc
+usr/src/man/man3proc/ps_lstop.3proc
+usr/src/man/man3proc/ps_pcontinue.3proc
+usr/src/man/man3proc/ps_pdread.3proc
+usr/src/man/man3proc/ps_pdwrite.3proc
+usr/src/man/man3proc/ps_pglobal_sym.3proc
+usr/src/man/man3proc/ps_ptread.3proc
+usr/src/man/man3proc/ps_ptwrite.3proc
+usr/src/man/man3proc/ps_pwrite.3proc
+usr/src/man/man3project/endprojent.3project
+usr/src/man/man3project/fgetprojent.3project
+usr/src/man/man3project/getdefaultproj.3project
+usr/src/man/man3project/getprojbyid.3project
+usr/src/man/man3project/getprojbyname.3project
+usr/src/man/man3project/getprojidbyname.3project
+usr/src/man/man3project/inproj.3project
+usr/src/man/man3project/setprojent.3project
+usr/src/man/man3resolv/dn_comp.3resolv
+usr/src/man/man3resolv/dn_expand.3resolv
+usr/src/man/man3resolv/fp_resstat.3resolv
+usr/src/man/man3resolv/herror.3resolv
+usr/src/man/man3resolv/hstrerror.3resolv
+usr/src/man/man3resolv/res_getservers.3resolv
+usr/src/man/man3resolv/res_hostalias.3resolv
+usr/src/man/man3resolv/res_init.3resolv
+usr/src/man/man3resolv/res_mkquery.3resolv
+usr/src/man/man3resolv/res_nclose.3resolv
+usr/src/man/man3resolv/res_ndestroy.3resolv
+usr/src/man/man3resolv/res_ninit.3resolv
+usr/src/man/man3resolv/res_nmkquery.3resolv
+usr/src/man/man3resolv/res_nquery.3resolv
+usr/src/man/man3resolv/res_nquerydomain.3resolv
+usr/src/man/man3resolv/res_nsearch.3resolv
+usr/src/man/man3resolv/res_nsend.3resolv
+usr/src/man/man3resolv/res_nsendsigned.3resolv
+usr/src/man/man3resolv/res_query.3resolv
+usr/src/man/man3resolv/res_search.3resolv
+usr/src/man/man3resolv/res_send.3resolv
+usr/src/man/man3resolv/res_setservers.3resolv
+usr/src/man/man3rpc/havedisk.3rpc
+usr/src/man/man3rpc/rnusers.3rpc
+usr/src/man/man3rsm/rsm_free_interconnect_topology.3rsm
+usr/src/man/man3rsm/rsm_free_localmemory_handle.3rsm
+usr/src/man/man3rsm/rsm_get_controller_attr.3rsm
+usr/src/man/man3rsm/rsm_intr_signal_wait.3rsm
+usr/src/man/man3rsm/rsm_memseg_export_destroy.3rsm
+usr/src/man/man3rsm/rsm_memseg_export_rebind.3rsm
+usr/src/man/man3rsm/rsm_memseg_export_republish.3rsm
+usr/src/man/man3rsm/rsm_memseg_export_unpublish.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_close_barrier.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_destroy_barrier.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_disconnect.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_get16.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_get32.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_get64.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_get8.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_get_mode.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_getv.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_order_barrier.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_put16.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_put32.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_put64.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_put8.3rsm
+usr/src/man/man3rsm/rsm_memseg_import_unmap.3rsm
+usr/src/man/man3rsm/rsm_memseg_release_pollfd.3rsm
+usr/src/man/man3rsm/rsm_release_controller.3rsm
+usr/src/man/man3sasl/prop_clear.3sasl
+usr/src/man/man3sasl/prop_dispose.3sasl
+usr/src/man/man3sasl/prop_dup.3sasl
+usr/src/man/man3sasl/prop_erase.3sasl
+usr/src/man/man3sasl/prop_format.3sasl
+usr/src/man/man3sasl/prop_get.3sasl
+usr/src/man/man3sasl/prop_getnames.3sasl
+usr/src/man/man3sasl/prop_new.3sasl
+usr/src/man/man3sasl/prop_request.3sasl
+usr/src/man/man3sasl/prop_set.3sasl
+usr/src/man/man3sasl/prop_setvals.3sasl
+usr/src/man/man3sasl/sasl_encodev.3sasl
+usr/src/man/man3scf/scf_count_ranges_destroy.3scf
+usr/src/man/man3scf/scf_entry_add_value.3scf
+usr/src/man/man3scf/scf_entry_destroy.3scf
+usr/src/man/man3scf/scf_entry_destroy_children.3scf
+usr/src/man/man3scf/scf_entry_handle.3scf
+usr/src/man/man3scf/scf_entry_reset.3scf
+usr/src/man/man3scf/scf_handle_bind.3scf
+usr/src/man/man3scf/scf_handle_decorate.3scf
+usr/src/man/man3scf/scf_handle_destroy.3scf
+usr/src/man/man3scf/scf_handle_get_scope.3scf
+usr/src/man/man3scf/scf_handle_unbind.3scf
+usr/src/man/man3scf/scf_instance_add_pg.3scf
+usr/src/man/man3scf/scf_instance_delete.3scf
+usr/src/man/man3scf/scf_instance_destroy.3scf
+usr/src/man/man3scf/scf_instance_get_name.3scf
+usr/src/man/man3scf/scf_instance_get_parent.3scf
+usr/src/man/man3scf/scf_instance_get_pg.3scf
+usr/src/man/man3scf/scf_instance_get_pg_composed.3scf
+usr/src/man/man3scf/scf_instance_get_snapshot.3scf
+usr/src/man/man3scf/scf_instance_handle.3scf
+usr/src/man/man3scf/scf_instance_to_fmri.3scf
+usr/src/man/man3scf/scf_int_ranges_destroy.3scf
+usr/src/man/man3scf/scf_iter_destroy.3scf
+usr/src/man/man3scf/scf_iter_handle.3scf
+usr/src/man/man3scf/scf_iter_handle_scopes.3scf
+usr/src/man/man3scf/scf_iter_instance_pgs.3scf
+usr/src/man/man3scf/scf_iter_instance_pgs_composed.3scf
+usr/src/man/man3scf/scf_iter_instance_pgs_typed.3scf
+usr/src/man/man3scf/scf_iter_instance_pgs_typed_composed.3scf
+usr/src/man/man3scf/scf_iter_instance_snapshots.3scf
+usr/src/man/man3scf/scf_iter_next_instance.3scf
+usr/src/man/man3scf/scf_iter_next_pg.3scf
+usr/src/man/man3scf/scf_iter_next_property.3scf
+usr/src/man/man3scf/scf_iter_next_scope.3scf
+usr/src/man/man3scf/scf_iter_next_service.3scf
+usr/src/man/man3scf/scf_iter_next_snapshot.3scf
+usr/src/man/man3scf/scf_iter_next_value.3scf
+usr/src/man/man3scf/scf_iter_pg_properties.3scf
+usr/src/man/man3scf/scf_iter_property_values.3scf
+usr/src/man/man3scf/scf_iter_reset.3scf
+usr/src/man/man3scf/scf_iter_scope_services.3scf
+usr/src/man/man3scf/scf_iter_service_instances.3scf
+usr/src/man/man3scf/scf_iter_service_pgs.3scf
+usr/src/man/man3scf/scf_iter_service_pgs_typed.3scf
+usr/src/man/man3scf/scf_iter_snaplevel_pgs.3scf
+usr/src/man/man3scf/scf_iter_snaplevel_pgs_typed.3scf
+usr/src/man/man3scf/scf_myname.3scf
+usr/src/man/man3scf/scf_pg_delete.3scf
+usr/src/man/man3scf/scf_pg_destroy.3scf
+usr/src/man/man3scf/scf_pg_get_flags.3scf
+usr/src/man/man3scf/scf_pg_get_name.3scf
+usr/src/man/man3scf/scf_pg_get_parent_instance.3scf
+usr/src/man/man3scf/scf_pg_get_parent_service.3scf
+usr/src/man/man3scf/scf_pg_get_parent_snaplevel.3scf
+usr/src/man/man3scf/scf_pg_get_property.3scf
+usr/src/man/man3scf/scf_pg_get_type.3scf
+usr/src/man/man3scf/scf_pg_get_underlying_pg.3scf
+usr/src/man/man3scf/scf_pg_handle.3scf
+usr/src/man/man3scf/scf_pg_to_fmri.3scf
+usr/src/man/man3scf/scf_pg_update.3scf
+usr/src/man/man3scf/scf_property_destroy.3scf
+usr/src/man/man3scf/scf_property_get_name.3scf
+usr/src/man/man3scf/scf_property_get_value.3scf
+usr/src/man/man3scf/scf_property_handle.3scf
+usr/src/man/man3scf/scf_property_is_type.3scf
+usr/src/man/man3scf/scf_property_to_fmri.3scf
+usr/src/man/man3scf/scf_property_type.3scf
+usr/src/man/man3scf/scf_scope_add_service.3scf
+usr/src/man/man3scf/scf_scope_destroy.3scf
+usr/src/man/man3scf/scf_scope_get_name.3scf
+usr/src/man/man3scf/scf_scope_get_service.3scf
+usr/src/man/man3scf/scf_scope_handle.3scf
+usr/src/man/man3scf/scf_scope_to_fmri.3scf
+usr/src/man/man3scf/scf_service_add_instance.3scf
+usr/src/man/man3scf/scf_service_add_pg.3scf
+usr/src/man/man3scf/scf_service_delete.3scf
+usr/src/man/man3scf/scf_service_destroy.3scf
+usr/src/man/man3scf/scf_service_get_instance.3scf
+usr/src/man/man3scf/scf_service_get_name.3scf
+usr/src/man/man3scf/scf_service_get_parent.3scf
+usr/src/man/man3scf/scf_service_get_pg.3scf
+usr/src/man/man3scf/scf_service_handle.3scf
+usr/src/man/man3scf/scf_service_to_fmri.3scf
+usr/src/man/man3scf/scf_simple_app_props_free.3scf
+usr/src/man/man3scf/scf_simple_app_props_get.3scf
+usr/src/man/man3scf/scf_simple_app_props_next.3scf
+usr/src/man/man3scf/scf_simple_app_props_search.3scf
+usr/src/man/man3scf/scf_simple_prop_free.3scf
+usr/src/man/man3scf/scf_simple_prop_name.3scf
+usr/src/man/man3scf/scf_simple_prop_next_astring.3scf
+usr/src/man/man3scf/scf_simple_prop_next_boolean.3scf
+usr/src/man/man3scf/scf_simple_prop_next_count.3scf
+usr/src/man/man3scf/scf_simple_prop_next_integer.3scf
+usr/src/man/man3scf/scf_simple_prop_next_opaque.3scf
+usr/src/man/man3scf/scf_simple_prop_next_reset.3scf
+usr/src/man/man3scf/scf_simple_prop_next_time.3scf
+usr/src/man/man3scf/scf_simple_prop_next_ustring.3scf
+usr/src/man/man3scf/scf_simple_prop_numvalues.3scf
+usr/src/man/man3scf/scf_simple_prop_pgname.3scf
+usr/src/man/man3scf/scf_simple_prop_type.3scf
+usr/src/man/man3scf/scf_snaplevel_destroy.3scf
+usr/src/man/man3scf/scf_snaplevel_get_instance_name.3scf
+usr/src/man/man3scf/scf_snaplevel_get_next_snaplevel.3scf
+usr/src/man/man3scf/scf_snaplevel_get_parent.3scf
+usr/src/man/man3scf/scf_snaplevel_get_pg.3scf
+usr/src/man/man3scf/scf_snaplevel_get_scope_name.3scf
+usr/src/man/man3scf/scf_snaplevel_get_service_name.3scf
+usr/src/man/man3scf/scf_snaplevel_handle.3scf
+usr/src/man/man3scf/scf_snapshot_destroy.3scf
+usr/src/man/man3scf/scf_snapshot_get_base_snaplevel.3scf
+usr/src/man/man3scf/scf_snapshot_get_name.3scf
+usr/src/man/man3scf/scf_snapshot_get_parent.3scf
+usr/src/man/man3scf/scf_snapshot_handle.3scf
+usr/src/man/man3scf/scf_snapshot_update.3scf
+usr/src/man/man3scf/scf_strerror.3scf
+usr/src/man/man3scf/scf_string_to_type.3scf
+usr/src/man/man3scf/scf_tmpl_error_pg.3scf
+usr/src/man/man3scf/scf_tmpl_error_pg_tmpl.3scf
+usr/src/man/man3scf/scf_tmpl_error_prop.3scf
+usr/src/man/man3scf/scf_tmpl_error_prop_tmpl.3scf
+usr/src/man/man3scf/scf_tmpl_error_source_fmri.3scf
+usr/src/man/man3scf/scf_tmpl_error_type.3scf
+usr/src/man/man3scf/scf_tmpl_error_value.3scf
+usr/src/man/man3scf/scf_tmpl_errors_destroy.3scf
+usr/src/man/man3scf/scf_tmpl_get_by_pg.3scf
+usr/src/man/man3scf/scf_tmpl_get_by_pg_name.3scf
+usr/src/man/man3scf/scf_tmpl_get_by_prop.3scf
+usr/src/man/man3scf/scf_tmpl_iter_pgs.3scf
+usr/src/man/man3scf/scf_tmpl_iter_props.3scf
+usr/src/man/man3scf/scf_tmpl_next_error.3scf
+usr/src/man/man3scf/scf_tmpl_pg_common_name.3scf
+usr/src/man/man3scf/scf_tmpl_pg_description.3scf
+usr/src/man/man3scf/scf_tmpl_pg_destroy.3scf
+usr/src/man/man3scf/scf_tmpl_pg_required.3scf
+usr/src/man/man3scf/scf_tmpl_pg_reset.3scf
+usr/src/man/man3scf/scf_tmpl_pg_target.3scf
+usr/src/man/man3scf/scf_tmpl_pg_type.3scf
+usr/src/man/man3scf/scf_tmpl_prop_cardinality.3scf
+usr/src/man/man3scf/scf_tmpl_prop_common_name.3scf
+usr/src/man/man3scf/scf_tmpl_prop_description.3scf
+usr/src/man/man3scf/scf_tmpl_prop_destroy.3scf
+usr/src/man/man3scf/scf_tmpl_prop_internal_seps.3scf
+usr/src/man/man3scf/scf_tmpl_prop_required.3scf
+usr/src/man/man3scf/scf_tmpl_prop_reset.3scf
+usr/src/man/man3scf/scf_tmpl_prop_type.3scf
+usr/src/man/man3scf/scf_tmpl_prop_units.3scf
+usr/src/man/man3scf/scf_tmpl_prop_visibility.3scf
+usr/src/man/man3scf/scf_tmpl_reset_errors.3scf
+usr/src/man/man3scf/scf_tmpl_strerror.3scf
+usr/src/man/man3scf/scf_tmpl_value_common_name.3scf
+usr/src/man/man3scf/scf_tmpl_value_count_range_choices.3scf
+usr/src/man/man3scf/scf_tmpl_value_count_range_constraints.3scf
+usr/src/man/man3scf/scf_tmpl_value_description.3scf
+usr/src/man/man3scf/scf_tmpl_value_in_constraint.3scf
+usr/src/man/man3scf/scf_tmpl_value_int_range_choices.3scf
+usr/src/man/man3scf/scf_tmpl_value_int_range_constraints.3scf
+usr/src/man/man3scf/scf_tmpl_value_name_choices.3scf
+usr/src/man/man3scf/scf_tmpl_value_name_constraints.3scf
+usr/src/man/man3scf/scf_tmpl_visibility_to_string.3scf
+usr/src/man/man3scf/scf_transaction_commit.3scf
+usr/src/man/man3scf/scf_transaction_destroy.3scf
+usr/src/man/man3scf/scf_transaction_destroy_children.3scf
+usr/src/man/man3scf/scf_transaction_handle.3scf
+usr/src/man/man3scf/scf_transaction_property_change.3scf
+usr/src/man/man3scf/scf_transaction_property_change_type.3scf
+usr/src/man/man3scf/scf_transaction_property_delete.3scf
+usr/src/man/man3scf/scf_transaction_property_new.3scf
+usr/src/man/man3scf/scf_transaction_reset.3scf
+usr/src/man/man3scf/scf_transaction_reset_all.3scf
+usr/src/man/man3scf/scf_transaction_start.3scf
+usr/src/man/man3scf/scf_type_base_type.3scf
+usr/src/man/man3scf/scf_type_to_string.3scf
+usr/src/man/man3scf/scf_value_base_type.3scf
+usr/src/man/man3scf/scf_value_destroy.3scf
+usr/src/man/man3scf/scf_value_get_as_string.3scf
+usr/src/man/man3scf/scf_value_get_as_string_typed.3scf
+usr/src/man/man3scf/scf_value_get_astring.3scf
+usr/src/man/man3scf/scf_value_get_boolean.3scf
+usr/src/man/man3scf/scf_value_get_count.3scf
+usr/src/man/man3scf/scf_value_get_integer.3scf
+usr/src/man/man3scf/scf_value_get_opaque.3scf
+usr/src/man/man3scf/scf_value_get_time.3scf
+usr/src/man/man3scf/scf_value_get_ustring.3scf
+usr/src/man/man3scf/scf_value_handle.3scf
+usr/src/man/man3scf/scf_value_is_type.3scf
+usr/src/man/man3scf/scf_value_reset.3scf
+usr/src/man/man3scf/scf_value_set_astring.3scf
+usr/src/man/man3scf/scf_value_set_boolean.3scf
+usr/src/man/man3scf/scf_value_set_count.3scf
+usr/src/man/man3scf/scf_value_set_from_string.3scf
+usr/src/man/man3scf/scf_value_set_integer.3scf
+usr/src/man/man3scf/scf_value_set_opaque.3scf
+usr/src/man/man3scf/scf_value_set_time.3scf
+usr/src/man/man3scf/scf_value_set_ustring.3scf
+usr/src/man/man3scf/scf_value_type.3scf
+usr/src/man/man3scf/scf_values_destroy.3scf
+usr/src/man/man3scf/smf_degrade_instance.3scf
+usr/src/man/man3scf/smf_disable_instance.3scf
+usr/src/man/man3scf/smf_get_state.3scf
+usr/src/man/man3scf/smf_maintain_instance.3scf
+usr/src/man/man3scf/smf_refresh_instance.3scf
+usr/src/man/man3scf/smf_restart_instance.3scf
+usr/src/man/man3scf/smf_restore_instance.3scf
+usr/src/man/man3sec/acl_fromtext.3sec
+usr/src/man/man3sec/acl_set.3sec
+usr/src/man/man3sec/aclfrommode.3sec
+usr/src/man/man3sec/aclfromtext.3sec
+usr/src/man/man3sec/facl_get.3sec
+usr/src/man/man3sec/facl_set.3sec
+usr/src/man/man3secdb/chkauthattr.3secdb
+usr/src/man/man3secdb/endauthattr.3secdb
+usr/src/man/man3secdb/endexecattr.3secdb
+usr/src/man/man3secdb/endprofattr.3secdb
+usr/src/man/man3secdb/enduserattr.3secdb
+usr/src/man/man3secdb/fgetuserattr.3secdb
+usr/src/man/man3secdb/free_authattr.3secdb
+usr/src/man/man3secdb/free_execattr.3secdb
+usr/src/man/man3secdb/free_profattr.3secdb
+usr/src/man/man3secdb/free_proflist.3secdb
+usr/src/man/man3secdb/free_userattr.3secdb
+usr/src/man/man3secdb/getauthnam.3secdb
+usr/src/man/man3secdb/getexecprof.3secdb
+usr/src/man/man3secdb/getexecuser.3secdb
+usr/src/man/man3secdb/getproflist.3secdb
+usr/src/man/man3secdb/getprofnam.3secdb
+usr/src/man/man3secdb/getusernam.3secdb
+usr/src/man/man3secdb/getuseruid.3secdb
+usr/src/man/man3secdb/match_execattr.3secdb
+usr/src/man/man3secdb/setauthattr.3secdb
+usr/src/man/man3secdb/setexecattr.3secdb
+usr/src/man/man3secdb/setprofattr.3secdb
+usr/src/man/man3secdb/setuserattr.3secdb
+usr/src/man/man3sip/sip_add_accept.3sip
+usr/src/man/man3sip/sip_add_accept_enc.3sip
+usr/src/man/man3sip/sip_add_accept_lang.3sip
+usr/src/man/man3sip/sip_add_alert_info.3sip
+usr/src/man/man3sip/sip_add_allow.3sip
+usr/src/man/man3sip/sip_add_allow_events.3sip
+usr/src/man/man3sip/sip_add_authen_info.3sip
+usr/src/man/man3sip/sip_add_author.3sip
+usr/src/man/man3sip/sip_add_call_info.3sip
+usr/src/man/man3sip/sip_add_callid.3sip
+usr/src/man/man3sip/sip_add_contact.3sip
+usr/src/man/man3sip/sip_add_content.3sip
+usr/src/man/man3sip/sip_add_content_disp.3sip
+usr/src/man/man3sip/sip_add_content_enc.3sip
+usr/src/man/man3sip/sip_add_content_lang.3sip
+usr/src/man/man3sip/sip_add_content_type.3sip
+usr/src/man/man3sip/sip_add_cseq.3sip
+usr/src/man/man3sip/sip_add_date.3sip
+usr/src/man/man3sip/sip_add_error_info.3sip
+usr/src/man/man3sip/sip_add_event.3sip
+usr/src/man/man3sip/sip_add_expires.3sip
+usr/src/man/man3sip/sip_add_in_reply_to.3sip
+usr/src/man/man3sip/sip_add_maxforward.3sip
+usr/src/man/man3sip/sip_add_mime_version.3sip
+usr/src/man/man3sip/sip_add_min_expires.3sip
+usr/src/man/man3sip/sip_add_org.3sip
+usr/src/man/man3sip/sip_add_passertedid.3sip
+usr/src/man/man3sip/sip_add_ppreferredid.3sip
+usr/src/man/man3sip/sip_add_priority.3sip
+usr/src/man/man3sip/sip_add_privacy.3sip
+usr/src/man/man3sip/sip_add_proxy_authen.3sip
+usr/src/man/man3sip/sip_add_proxy_author.3sip
+usr/src/man/man3sip/sip_add_proxy_require.3sip
+usr/src/man/man3sip/sip_add_rack.3sip
+usr/src/man/man3sip/sip_add_record_route.3sip
+usr/src/man/man3sip/sip_add_reply_to.3sip
+usr/src/man/man3sip/sip_add_require.3sip
+usr/src/man/man3sip/sip_add_response_line.3sip
+usr/src/man/man3sip/sip_add_retry_after.3sip
+usr/src/man/man3sip/sip_add_route.3sip
+usr/src/man/man3sip/sip_add_rseq.3sip
+usr/src/man/man3sip/sip_add_server.3sip
+usr/src/man/man3sip/sip_add_subject.3sip
+usr/src/man/man3sip/sip_add_substate.3sip
+usr/src/man/man3sip/sip_add_supported.3sip
+usr/src/man/man3sip/sip_add_to.3sip
+usr/src/man/man3sip/sip_add_tstamp.3sip
+usr/src/man/man3sip/sip_add_unsupported.3sip
+usr/src/man/man3sip/sip_add_user_agent.3sip
+usr/src/man/man3sip/sip_add_via.3sip
+usr/src/man/man3sip/sip_add_warning.3sip
+usr/src/man/man3sip/sip_add_www_authen.3sip
+usr/src/man/man3sip/sip_clear_stale_data.3sip
+usr/src/man/man3sip/sip_conn_destroyed.3sip
+usr/src/man/man3sip/sip_copy_all_headers.3sip
+usr/src/man/man3sip/sip_copy_header.3sip
+usr/src/man/man3sip/sip_copy_header_by_name.3sip
+usr/src/man/man3sip/sip_create_dialog_req_nocontact.3sip
+usr/src/man/man3sip/sip_delete_header.3sip
+usr/src/man/man3sip/sip_delete_header_by_name.3sip
+usr/src/man/man3sip/sip_delete_value.3sip
+usr/src/man/man3sip/sip_disable_counters.3sip
+usr/src/man/man3sip/sip_disable_dialog_logging.3sip
+usr/src/man/man3sip/sip_disable_trans_logging.3sip
+usr/src/man/man3sip/sip_enable_dialog_logging.3sip
+usr/src/man/man3sip/sip_free_msg.3sip
+usr/src/man/man3sip/sip_free_parsed_uri.3sip
+usr/src/man/man3sip/sip_get_accept_enc.3sip
+usr/src/man/man3sip/sip_get_accept_lang.3sip
+usr/src/man/man3sip/sip_get_accept_sub_type.3sip
+usr/src/man/man3sip/sip_get_accept_type.3sip
+usr/src/man/man3sip/sip_get_alert_info_uri.3sip
+usr/src/man/man3sip/sip_get_allow_events.3sip
+usr/src/man/man3sip/sip_get_allow_method.3sip
+usr/src/man/man3sip/sip_get_authen_info.3sip
+usr/src/man/man3sip/sip_get_author_param.3sip
+usr/src/man/man3sip/sip_get_author_scheme.3sip
+usr/src/man/man3sip/sip_get_branchid.3sip
+usr/src/man/man3sip/sip_get_call_info_uri.3sip
+usr/src/man/man3sip/sip_get_callid.3sip
+usr/src/man/man3sip/sip_get_callseq_method.3sip
+usr/src/man/man3sip/sip_get_callseq_num.3sip
+usr/src/man/man3sip/sip_get_contact_uri_str.3sip
+usr/src/man/man3sip/sip_get_content.3sip
+usr/src/man/man3sip/sip_get_content_disp.3sip
+usr/src/man/man3sip/sip_get_content_enc.3sip
+usr/src/man/man3sip/sip_get_content_lang.3sip
+usr/src/man/man3sip/sip_get_content_length.3sip
+usr/src/man/man3sip/sip_get_content_sub_type.3sip
+usr/src/man/man3sip/sip_get_content_type.3sip
+usr/src/man/man3sip/sip_get_counter_value.3sip
+usr/src/man/man3sip/sip_get_date_day.3sip
+usr/src/man/man3sip/sip_get_date_month.3sip
+usr/src/man/man3sip/sip_get_date_time.3sip
+usr/src/man/man3sip/sip_get_date_timezone.3sip
+usr/src/man/man3sip/sip_get_date_wkday.3sip
+usr/src/man/man3sip/sip_get_date_year.3sip
+usr/src/man/man3sip/sip_get_dialog_callid.3sip
+usr/src/man/man3sip/sip_get_dialog_local_contact_uri.3sip
+usr/src/man/man3sip/sip_get_dialog_local_cseq.3sip
+usr/src/man/man3sip/sip_get_dialog_local_tag.3sip
+usr/src/man/man3sip/sip_get_dialog_local_uri.3sip
+usr/src/man/man3sip/sip_get_dialog_method.3sip
+usr/src/man/man3sip/sip_get_dialog_msgcnt.3sip
+usr/src/man/man3sip/sip_get_dialog_remote_cseq.3sip
+usr/src/man/man3sip/sip_get_dialog_remote_tag.3sip
+usr/src/man/man3sip/sip_get_dialog_remote_target_uri.3sip
+usr/src/man/man3sip/sip_get_dialog_remote_uri.3sip
+usr/src/man/man3sip/sip_get_dialog_route_set.3sip
+usr/src/man/man3sip/sip_get_dialog_type.3sip
+usr/src/man/man3sip/sip_get_error_info_uri.3sip
+usr/src/man/man3sip/sip_get_event.3sip
+usr/src/man/man3sip/sip_get_expires.3sip
+usr/src/man/man3sip/sip_get_from_display_name.3sip
+usr/src/man/man3sip/sip_get_from_tag.3sip
+usr/src/man/man3sip/sip_get_from_uri_str.3sip
+usr/src/man/man3sip/sip_get_in_reply_to.3sip
+usr/src/man/man3sip/sip_get_maxforward.3sip
+usr/src/man/man3sip/sip_get_mime_version.3sip
+usr/src/man/man3sip/sip_get_min_expires.3sip
+usr/src/man/man3sip/sip_get_next_value.3sip
+usr/src/man/man3sip/sip_get_org.3sip
+usr/src/man/man3sip/sip_get_params.3sip
+usr/src/man/man3sip/sip_get_passertedid_display_name.3sip
+usr/src/man/man3sip/sip_get_passertedid_uri_str.3sip
+usr/src/man/man3sip/sip_get_ppreferredid_display_name.3sip
+usr/src/man/man3sip/sip_get_ppreferredid_uri_str.3sip
+usr/src/man/man3sip/sip_get_priority.3sip
+usr/src/man/man3sip/sip_get_priv_value.3sip
+usr/src/man/man3sip/sip_get_proxy_authen_param.3sip
+usr/src/man/man3sip/sip_get_proxy_authen_scheme.3sip
+usr/src/man/man3sip/sip_get_proxy_author_param.3sip
+usr/src/man/man3sip/sip_get_proxy_author_scheme.3sip
+usr/src/man/man3sip/sip_get_proxy_require.3sip
+usr/src/man/man3sip/sip_get_rack_cseq_num.3sip
+usr/src/man/man3sip/sip_get_rack_method.3sip
+usr/src/man/man3sip/sip_get_rack_resp_num.3sip
+usr/src/man/man3sip/sip_get_replyto_display_name.3sip
+usr/src/man/man3sip/sip_get_replyto_uri_str.3sip
+usr/src/man/man3sip/sip_get_require.3sip
+usr/src/man/man3sip/sip_get_response_code.3sip
+usr/src/man/man3sip/sip_get_response_phrase.3sip
+usr/src/man/man3sip/sip_get_retry_after_cmts.3sip
+usr/src/man/man3sip/sip_get_retry_after_time.3sip
+usr/src/man/man3sip/sip_get_route_display_name.3sip
+usr/src/man/man3sip/sip_get_route_uri_str.3sip
+usr/src/man/man3sip/sip_get_rseq.3sip
+usr/src/man/man3sip/sip_get_rseq_resp_num.3sip
+usr/src/man/man3sip/sip_get_server.3sip
+usr/src/man/man3sip/sip_get_sip_version.3sip
+usr/src/man/man3sip/sip_get_subject.3sip
+usr/src/man/man3sip/sip_get_substate.3sip
+usr/src/man/man3sip/sip_get_supported.3sip
+usr/src/man/man3sip/sip_get_to_display_name.3sip
+usr/src/man/man3sip/sip_get_to_tag.3sip
+usr/src/man/man3sip/sip_get_to_uri_str.3sip
+usr/src/man/man3sip/sip_get_trans_branchid.3sip
+usr/src/man/man3sip/sip_get_trans_conn_obj.3sip
+usr/src/man/man3sip/sip_get_trans_orig_msg.3sip
+usr/src/man/man3sip/sip_get_trans_resp_msg.3sip
+usr/src/man/man3sip/sip_get_trans_state.3sip
+usr/src/man/man3sip/sip_get_tstamp_delay.3sip
+usr/src/man/man3sip/sip_get_tstamp_value.3sip
+usr/src/man/man3sip/sip_get_unsupported.3sip
+usr/src/man/man3sip/sip_get_uri_errflags.3sip
+usr/src/man/man3sip/sip_get_uri_headers.3sip
+usr/src/man/man3sip/sip_get_uri_host.3sip
+usr/src/man/man3sip/sip_get_uri_opaque.3sip
+usr/src/man/man3sip/sip_get_uri_params.3sip
+usr/src/man/man3sip/sip_get_uri_password.3sip
+usr/src/man/man3sip/sip_get_uri_path.3sip
+usr/src/man/man3sip/sip_get_uri_port.3sip
+usr/src/man/man3sip/sip_get_uri_query.3sip
+usr/src/man/man3sip/sip_get_uri_regname.3sip
+usr/src/man/man3sip/sip_get_uri_scheme.3sip
+usr/src/man/man3sip/sip_get_uri_user.3sip
+usr/src/man/man3sip/sip_get_user_agent.3sip
+usr/src/man/man3sip/sip_get_via_sent_by_host.3sip
+usr/src/man/man3sip/sip_get_via_sent_by_port.3sip
+usr/src/man/man3sip/sip_get_via_sent_protocol_name.3sip
+usr/src/man/man3sip/sip_get_via_sent_protocol_version.3sip
+usr/src/man/man3sip/sip_get_via_sent_transport.3sip
+usr/src/man/man3sip/sip_get_warning_agent.3sip
+usr/src/man/man3sip/sip_get_warning_code.3sip
+usr/src/man/man3sip/sip_get_warning_text.3sip
+usr/src/man/man3sip/sip_get_www_authen_param.3sip
+usr/src/man/man3sip/sip_get_www_authen_scheme.3sip
+usr/src/man/man3sip/sip_hdr_to_str.3sip
+usr/src/man/man3sip/sip_is_dialog_secure.3sip
+usr/src/man/man3sip/sip_is_param_present.3sip
+usr/src/man/man3sip/sip_is_uri_teluser.3sip
+usr/src/man/man3sip/sip_message_is_response.3sip
+usr/src/man/man3sip/sip_release_dialog.3sip
+usr/src/man/man3sip/sip_release_trans.3sip
+usr/src/man/man3sip/sip_reqline_to_str.3sip
+usr/src/man/man3sip/sip_respline_to_str.3sip
+usr/src/man/man3sip/sip_sent_by_to_str.3sip
+usr/src/man/man3sip/sip_unregister_all_sent_by.3sip
+usr/src/man/man3sip/sip_unregister_sent_by.3sip
+usr/src/man/man3sip/sip_uri_errflags_to_str.3sip
+usr/src/man/man3socket/endnetent.3socket
+usr/src/man/man3socket/endprotoent.3socket
+usr/src/man/man3socket/endservent.3socket
+usr/src/man/man3socket/ether_aton.3socket
+usr/src/man/man3socket/ether_hostton.3socket
+usr/src/man/man3socket/ether_line.3socket
+usr/src/man/man3socket/ether_ntoa.3socket
+usr/src/man/man3socket/ether_ntohost.3socket
+usr/src/man/man3socket/freeaddrinfo.3socket
+usr/src/man/man3socket/freehostent.3socket
+usr/src/man/man3socket/gai_strerror.3socket
+usr/src/man/man3socket/getipnodebyaddr.3socket
+usr/src/man/man3socket/getipv4sourcefilter.3socket
+usr/src/man/man3socket/getnameinfo.3socket
+usr/src/man/man3socket/getnetbyaddr.3socket
+usr/src/man/man3socket/getnetbyaddr_r.3socket
+usr/src/man/man3socket/getnetbyname_r.3socket
+usr/src/man/man3socket/getnetent.3socket
+usr/src/man/man3socket/getnetent_r.3socket
+usr/src/man/man3socket/getprotobyname_r.3socket
+usr/src/man/man3socket/getprotobynumber.3socket
+usr/src/man/man3socket/getprotobynumber_r.3socket
+usr/src/man/man3socket/getprotoent.3socket
+usr/src/man/man3socket/getprotoent_r.3socket
+usr/src/man/man3socket/getservbyname_r.3socket
+usr/src/man/man3socket/getservbyport.3socket
+usr/src/man/man3socket/getservbyport_r.3socket
+usr/src/man/man3socket/getservent.3socket
+usr/src/man/man3socket/getservent_r.3socket
+usr/src/man/man3socket/htonl.3socket
+usr/src/man/man3socket/htonll.3socket
+usr/src/man/man3socket/htons.3socket
+usr/src/man/man3socket/if_freenameindex.3socket
+usr/src/man/man3socket/if_indextoname.3socket
+usr/src/man/man3socket/if_nameindex.3socket
+usr/src/man/man3socket/inet6.3socket
+usr/src/man/man3socket/inet6_opt_append.3socket
+usr/src/man/man3socket/inet6_opt_find.3socket
+usr/src/man/man3socket/inet6_opt_finish.3socket
+usr/src/man/man3socket/inet6_opt_get_val.3socket
+usr/src/man/man3socket/inet6_opt_init.3socket
+usr/src/man/man3socket/inet6_opt_next.3socket
+usr/src/man/man3socket/inet6_opt_set_val.3socket
+usr/src/man/man3socket/inet6_rth_add.3socket
+usr/src/man/man3socket/inet6_rth_getaddr.3socket
+usr/src/man/man3socket/inet6_rth_init.3socket
+usr/src/man/man3socket/inet6_rth_reverse.3socket
+usr/src/man/man3socket/inet6_rth_segments.3socket
+usr/src/man/man3socket/inet6_rth_space.3socket
+usr/src/man/man3socket/inet_addr.3socket
+usr/src/man/man3socket/inet_aton.3socket
+usr/src/man/man3socket/inet_lnaof.3socket
+usr/src/man/man3socket/inet_makeaddr.3socket
+usr/src/man/man3socket/inet_netof.3socket
+usr/src/man/man3socket/inet_network.3socket
+usr/src/man/man3socket/inet_ntoa.3socket
+usr/src/man/man3socket/inet_ntop.3socket
+usr/src/man/man3socket/inet_pton.3socket
+usr/src/man/man3socket/ntohl.3socket
+usr/src/man/man3socket/ntohll.3socket
+usr/src/man/man3socket/ntohs.3socket
+usr/src/man/man3socket/rcmd_af.3socket
+usr/src/man/man3socket/recvfrom.3socket
+usr/src/man/man3socket/recvmsg.3socket
+usr/src/man/man3socket/rexec_af.3socket
+usr/src/man/man3socket/rresvport.3socket
+usr/src/man/man3socket/rresvport_af.3socket
+usr/src/man/man3socket/ruserok.3socket
+usr/src/man/man3socket/sctp_freeladdrs.3socket
+usr/src/man/man3socket/sctp_freepaddrs.3socket
+usr/src/man/man3socket/sendmsg.3socket
+usr/src/man/man3socket/sendto.3socket
+usr/src/man/man3socket/setipv4sourcefilter.3socket
+usr/src/man/man3socket/setnetent.3socket
+usr/src/man/man3socket/setprotoent.3socket
+usr/src/man/man3socket/setservent.3socket
+usr/src/man/man3socket/setsockopt.3socket
+usr/src/man/man3socket/setsourcefilter.3socket
+usr/src/man/man3stmf/stmfGetLuProp.3stmf
+usr/src/man/man3stmf/stmfModifyLuByFname.3stmf
+usr/src/man/man3sysevent/sysevent_get_pid.3sysevent
+usr/src/man/man3sysevent/sysevent_get_pub_name.3sysevent
+usr/src/man/man3sysevent/sysevent_get_seq.3sysevent
+usr/src/man/man3sysevent/sysevent_get_size.3sysevent
+usr/src/man/man3sysevent/sysevent_get_subclass_name.3sysevent
+usr/src/man/man3sysevent/sysevent_get_time.3sysevent
+usr/src/man/man3sysevent/sysevent_unbind_handle.3sysevent
+usr/src/man/man3sysevent/sysevent_unsubscribe_event.3sysevent
+usr/src/man/man3tecla/cfc_file_start.3tecla
+usr/src/man/man3tecla/cfc_literal_escapes.3tecla
+usr/src/man/man3tecla/cfc_set_check_fn.3tecla
+usr/src/man/man3tecla/cpl_add_completion.3tecla
+usr/src/man/man3tecla/cpl_check_exe.3tecla
+usr/src/man/man3tecla/cpl_file_completions.3tecla
+usr/src/man/man3tecla/cpl_last_error.3tecla
+usr/src/man/man3tecla/cpl_list_completions.3tecla
+usr/src/man/man3tecla/cpl_recall_matches.3tecla
+usr/src/man/man3tecla/cpl_record_error.3tecla
+usr/src/man/man3tecla/del_CplFileConf.3tecla
+usr/src/man/man3tecla/del_ExpandFile.3tecla
+usr/src/man/man3tecla/del_GetLine.3tecla
+usr/src/man/man3tecla/del_PathCache.3tecla
+usr/src/man/man3tecla/del_PcaPathConf.3tecla
+usr/src/man/man3tecla/del_WordCompletion.3tecla
+usr/src/man/man3tecla/ef_last_error.3tecla
+usr/src/man/man3tecla/ef_list_expansions.3tecla
+usr/src/man/man3tecla/gl_abandon_line.3tecla
+usr/src/man/man3tecla/gl_append_history.3tecla
+usr/src/man/man3tecla/gl_automatic_history.3tecla
+usr/src/man/man3tecla/gl_bind_keyseq.3tecla
+usr/src/man/man3tecla/gl_catch_blocked.3tecla
+usr/src/man/man3tecla/gl_change_terminal.3tecla
+usr/src/man/man3tecla/gl_clear_history.3tecla
+usr/src/man/man3tecla/gl_completion_action.3tecla
+usr/src/man/man3tecla/gl_configure_getline.3tecla
+usr/src/man/man3tecla/gl_customize_completion.3tecla
+usr/src/man/man3tecla/gl_display_text.3tecla
+usr/src/man/man3tecla/gl_echo_mode.3tecla
+usr/src/man/man3tecla/gl_erase_terminal.3tecla
+usr/src/man/man3tecla/gl_error_message.3tecla
+usr/src/man/man3tecla/gl_group_history.3tecla
+usr/src/man/man3tecla/gl_handle_signal.3tecla
+usr/src/man/man3tecla/gl_ignore_signal.3tecla
+usr/src/man/man3tecla/gl_inactivity_timeout.3tecla
+usr/src/man/man3tecla/gl_last_signal.3tecla
+usr/src/man/man3tecla/gl_limit_history.3tecla
+usr/src/man/man3tecla/gl_list_signals.3tecla
+usr/src/man/man3tecla/gl_load_history.3tecla
+usr/src/man/man3tecla/gl_lookup_history.3tecla
+usr/src/man/man3tecla/gl_normal_io.3tecla
+usr/src/man/man3tecla/gl_pending_io.3tecla
+usr/src/man/man3tecla/gl_prompt_style.3tecla
+usr/src/man/man3tecla/gl_query_char.3tecla
+usr/src/man/man3tecla/gl_range_of_history.3tecla
+usr/src/man/man3tecla/gl_raw_io.3tecla
+usr/src/man/man3tecla/gl_read_char.3tecla
+usr/src/man/man3tecla/gl_register_action.3tecla
+usr/src/man/man3tecla/gl_replace_prompt.3tecla
+usr/src/man/man3tecla/gl_resize_history.3tecla
+usr/src/man/man3tecla/gl_return_status.3tecla
+usr/src/man/man3tecla/gl_save_history.3tecla
+usr/src/man/man3tecla/gl_set_term_size.3tecla
+usr/src/man/man3tecla/gl_show_history.3tecla
+usr/src/man/man3tecla/gl_size_of_history.3tecla
+usr/src/man/man3tecla/gl_state_of_history.3tecla
+usr/src/man/man3tecla/gl_terminal_size.3tecla
+usr/src/man/man3tecla/gl_toggle_history.3tecla
+usr/src/man/man3tecla/gl_trap_signal.3tecla
+usr/src/man/man3tecla/gl_tty_signals.3tecla
+usr/src/man/man3tecla/gl_watch_fd.3tecla
+usr/src/man/man3tecla/new_CplFileConf.3tecla
+usr/src/man/man3tecla/new_ExpandFile.3tecla
+usr/src/man/man3tecla/new_GetLine.3tecla
+usr/src/man/man3tecla/new_PathCache.3tecla
+usr/src/man/man3tecla/new_PcaPathConf.3tecla
+usr/src/man/man3tecla/new_WordCompletion.3tecla
+usr/src/man/man3tecla/pca_last_error.3tecla
+usr/src/man/man3tecla/pca_path_completions.3tecla
+usr/src/man/man3tecla/pca_scan_path.3tecla
+usr/src/man/man3tecla/pca_set_check_fn.3tecla
+usr/src/man/man3tecla/ppc_file_start.3tecla
+usr/src/man/man3tecla/ppc_literal_escapes.3tecla
+usr/src/man/man3tnf/TNF_DEBUG.3tnf
+usr/src/man/man3tnf/TNF_DEFINE_RECORD_1.3tnf
+usr/src/man/man3tnf/TNF_DEFINE_RECORD_2.3tnf
+usr/src/man/man3tnf/TNF_DEFINE_RECORD_3.3tnf
+usr/src/man/man3tnf/TNF_DEFINE_RECORD_4.3tnf
+usr/src/man/man3tnf/TNF_DEFINE_RECORD_5.3tnf
+usr/src/man/man3tnf/TNF_PROBE_0.3tnf
+usr/src/man/man3tnf/TNF_PROBE_0_DEBUG.3tnf
+usr/src/man/man3tnf/TNF_PROBE_1.3tnf
+usr/src/man/man3tnf/TNF_PROBE_1_DEBUG.3tnf
+usr/src/man/man3tnf/TNF_PROBE_2.3tnf
+usr/src/man/man3tnf/TNF_PROBE_2_DEBUG.3tnf
+usr/src/man/man3tnf/TNF_PROBE_3.3tnf
+usr/src/man/man3tnf/TNF_PROBE_3_DEBUG.3tnf
+usr/src/man/man3tnf/TNF_PROBE_4.3tnf
+usr/src/man/man3tnf/TNF_PROBE_4_DEBUG.3tnf
+usr/src/man/man3tnf/TNF_PROBE_5.3tnf
+usr/src/man/man3tnf/TNF_PROBE_5_DEBUG.3tnf
+usr/src/man/man3tnf/tnf_process_enable.3tnf
+usr/src/man/man3tnf/tnf_thread_disable.3tnf
+usr/src/man/man3tnf/tnf_thread_enable.3tnf
+usr/src/man/man3tnf/tnfctl_buffer_dealloc.3tnf
+usr/src/man/man3tnf/tnfctl_check_libs.3tnf
+usr/src/man/man3tnf/tnfctl_continue.3tnf
+usr/src/man/man3tnf/tnfctl_exec_open.3tnf
+usr/src/man/man3tnf/tnfctl_filter_list_add.3tnf
+usr/src/man/man3tnf/tnfctl_filter_list_delete.3tnf
+usr/src/man/man3tnf/tnfctl_filter_list_get.3tnf
+usr/src/man/man3tnf/tnfctl_filter_state_set.3tnf
+usr/src/man/man3tnf/tnfctl_probe_apply_ids.3tnf
+usr/src/man/man3tnf/tnfctl_probe_connect.3tnf
+usr/src/man/man3tnf/tnfctl_probe_disable.3tnf
+usr/src/man/man3tnf/tnfctl_probe_disconnect_all.3tnf
+usr/src/man/man3tnf/tnfctl_probe_enable.3tnf
+usr/src/man/man3tnf/tnfctl_probe_trace.3tnf
+usr/src/man/man3tnf/tnfctl_probe_untrace.3tnf
+usr/src/man/man3tsol/Xbcleartos.3tsol
+usr/src/man/man3tsol/Xbsltos.3tsol
+usr/src/man/man3tsol/bcleartoh.3tsol
+usr/src/man/man3tsol/bcleartoh_r.3tsol
+usr/src/man/man3tsol/bcleartos.3tsol
+usr/src/man/man3tsol/bldominates.3tsol
+usr/src/man/man3tsol/blequal.3tsol
+usr/src/man/man3tsol/blinrange.3tsol
+usr/src/man/man3tsol/blmaximum.3tsol
+usr/src/man/man3tsol/blminimum.3tsol
+usr/src/man/man3tsol/blstrictdom.3tsol
+usr/src/man/man3tsol/bltocolor_r.3tsol
+usr/src/man/man3tsol/bsltoh.3tsol
+usr/src/man/man3tsol/bsltoh_r.3tsol
+usr/src/man/man3tsol/bsltos.3tsol
+usr/src/man/man3tsol/getzoneidbylabel.3tsol
+usr/src/man/man3tsol/getzonelabelbyname.3tsol
+usr/src/man/man3tsol/getzonerootbylabel.3tsol
+usr/src/man/man3tsol/getzonerootbyname.3tsol
+usr/src/man/man3tsol/h_alloc.3tsol
+usr/src/man/man3tsol/h_free.3tsol
+usr/src/man/man3tsol/htobclear.3tsol
+usr/src/man/man3tsol/htobsl.3tsol
+usr/src/man/man3tsol/m_label_alloc.3tsol
+usr/src/man/man3tsol/m_label_dup.3tsol
+usr/src/man/man3tsol/m_label_free.3tsol
+usr/src/man/man3tsol/sbcleartos.3tsol
+usr/src/man/man3tsol/sbsltos.3tsol
+usr/src/man/man3tsol/stobclear.3tsol
+usr/src/man/man3tsol/stobsl.3tsol
+usr/src/man/man3uuid/uuid_compare.3uuid
+usr/src/man/man3uuid/uuid_copy.3uuid
+usr/src/man/man3uuid/uuid_generate.3uuid
+usr/src/man/man3uuid/uuid_generate_random.3uuid
+usr/src/man/man3uuid/uuid_generate_time.3uuid
+usr/src/man/man3uuid/uuid_is_null.3uuid
+usr/src/man/man3uuid/uuid_parse.3uuid
+usr/src/man/man3uuid/uuid_time.3uuid
+usr/src/man/man3uuid/uuid_unparse.3uuid
+usr/src/man/man3volmgt/media_setattr.3volmgt
+usr/src/man/man3volmgt/volmgt_symdev.3volmgt
+usr/src/man/man3xcurses/COLORS.3xcurses
+usr/src/man/man3xcurses/COLOR_PAIR.3xcurses
+usr/src/man/man3xcurses/COLOR_PAIRS.3xcurses
+usr/src/man/man3xcurses/PAIR_NUMBER.3xcurses
+usr/src/man/man3xcurses/add_wchstr.3xcurses
+usr/src/man/man3xcurses/addchnstr.3xcurses
+usr/src/man/man3xcurses/addstr.3xcurses
+usr/src/man/man3xcurses/addwstr.3xcurses
+usr/src/man/man3xcurses/attr_off.3xcurses
+usr/src/man/man3xcurses/attr_on.3xcurses
+usr/src/man/man3xcurses/attr_set.3xcurses
+usr/src/man/man3xcurses/attron.3xcurses
+usr/src/man/man3xcurses/attrset.3xcurses
+usr/src/man/man3xcurses/bkgdset.3xcurses
+usr/src/man/man3xcurses/bkgrndset.3xcurses
+usr/src/man/man3xcurses/box.3xcurses
+usr/src/man/man3xcurses/box_set.3xcurses
+usr/src/man/man3xcurses/color_content.3xcurses
+usr/src/man/man3xcurses/color_set.3xcurses
+usr/src/man/man3xcurses/def_shell_mode.3xcurses
+usr/src/man/man3xcurses/erase.3xcurses
+usr/src/man/man3xcurses/erasewchar.3xcurses
+usr/src/man/man3xcurses/flash.3xcurses
+usr/src/man/man3xcurses/get_wstr.3xcurses
+usr/src/man/man3xcurses/getbkgd.3xcurses
+usr/src/man/man3xcurses/getbkgrnd.3xcurses
+usr/src/man/man3xcurses/getmaxyx.3xcurses
+usr/src/man/man3xcurses/getparyx.3xcurses
+usr/src/man/man3xcurses/getstr.3xcurses
+usr/src/man/man3xcurses/getyx.3xcurses
+usr/src/man/man3xcurses/has_colors.3xcurses
+usr/src/man/man3xcurses/has_il.3xcurses
+usr/src/man/man3xcurses/idlok.3xcurses
+usr/src/man/man3xcurses/in_wchstr.3xcurses
+usr/src/man/man3xcurses/inchstr.3xcurses
+usr/src/man/man3xcurses/init_color.3xcurses
+usr/src/man/man3xcurses/init_pair.3xcurses
+usr/src/man/man3xcurses/ins_wstr.3xcurses
+usr/src/man/man3xcurses/insstr.3xcurses
+usr/src/man/man3xcurses/instr.3xcurses
+usr/src/man/man3xcurses/inwstr.3xcurses
+usr/src/man/man3xcurses/is_wintouched.3xcurses
+usr/src/man/man3xcurses/isendwin.3xcurses
+usr/src/man/man3xcurses/key_name.3xcurses
+usr/src/man/man3xcurses/killchar.3xcurses
+usr/src/man/man3xcurses/killwchar.3xcurses
+usr/src/man/man3xcurses/leaveok.3xcurses
+usr/src/man/man3xcurses/mvadd_wch.3xcurses
+usr/src/man/man3xcurses/mvadd_wchnstr.3xcurses
+usr/src/man/man3xcurses/mvadd_wchstr.3xcurses
+usr/src/man/man3xcurses/mvaddch.3xcurses
+usr/src/man/man3xcurses/mvaddchnstr.3xcurses
+usr/src/man/man3xcurses/mvaddchstr.3xcurses
+usr/src/man/man3xcurses/mvaddnstr.3xcurses
+usr/src/man/man3xcurses/mvaddnwstr.3xcurses
+usr/src/man/man3xcurses/mvaddstr.3xcurses
+usr/src/man/man3xcurses/mvaddwstr.3xcurses
+usr/src/man/man3xcurses/mvchgat.3xcurses
+usr/src/man/man3xcurses/mvdelch.3xcurses
+usr/src/man/man3xcurses/mvget_wch.3xcurses
+usr/src/man/man3xcurses/mvget_wstr.3xcurses
+usr/src/man/man3xcurses/mvgetch.3xcurses
+usr/src/man/man3xcurses/mvgetn_wstr.3xcurses
+usr/src/man/man3xcurses/mvgetnstr.3xcurses
+usr/src/man/man3xcurses/mvgetstr.3xcurses
+usr/src/man/man3xcurses/mvhline.3xcurses
+usr/src/man/man3xcurses/mvhline_set.3xcurses
+usr/src/man/man3xcurses/mvin_wch.3xcurses
+usr/src/man/man3xcurses/mvin_wchnstr.3xcurses
+usr/src/man/man3xcurses/mvin_wchstr.3xcurses
+usr/src/man/man3xcurses/mvinch.3xcurses
+usr/src/man/man3xcurses/mvinchnstr.3xcurses
+usr/src/man/man3xcurses/mvinchstr.3xcurses
+usr/src/man/man3xcurses/mvinnstr.3xcurses
+usr/src/man/man3xcurses/mvinnwstr.3xcurses
+usr/src/man/man3xcurses/mvins_nwstr.3xcurses
+usr/src/man/man3xcurses/mvins_wch.3xcurses
+usr/src/man/man3xcurses/mvins_wstr.3xcurses
+usr/src/man/man3xcurses/mvinsch.3xcurses
+usr/src/man/man3xcurses/mvinsnstr.3xcurses
+usr/src/man/man3xcurses/mvinsstr.3xcurses
+usr/src/man/man3xcurses/mvinstr.3xcurses
+usr/src/man/man3xcurses/mvinwstr.3xcurses
+usr/src/man/man3xcurses/mvvline.3xcurses
+usr/src/man/man3xcurses/mvvline_set.3xcurses
+usr/src/man/man3xcurses/mvwadd_wch.3xcurses
+usr/src/man/man3xcurses/mvwadd_wchnstr.3xcurses
+usr/src/man/man3xcurses/mvwadd_wchstr.3xcurses
+usr/src/man/man3xcurses/mvwaddch.3xcurses
+usr/src/man/man3xcurses/mvwaddchnstr.3xcurses
+usr/src/man/man3xcurses/mvwaddchstr.3xcurses
+usr/src/man/man3xcurses/mvwaddnstr.3xcurses
+usr/src/man/man3xcurses/mvwaddnwstr.3xcurses
+usr/src/man/man3xcurses/mvwaddstr.3xcurses
+usr/src/man/man3xcurses/mvwaddwstr.3xcurses
+usr/src/man/man3xcurses/mvwchgat.3xcurses
+usr/src/man/man3xcurses/mvwdelch.3xcurses
+usr/src/man/man3xcurses/mvwget_wch.3xcurses
+usr/src/man/man3xcurses/mvwget_wstr.3xcurses
+usr/src/man/man3xcurses/mvwgetch.3xcurses
+usr/src/man/man3xcurses/mvwgetn_wstr.3xcurses
+usr/src/man/man3xcurses/mvwgetnstr.3xcurses
+usr/src/man/man3xcurses/mvwgetstr.3xcurses
+usr/src/man/man3xcurses/mvwhline.3xcurses
+usr/src/man/man3xcurses/mvwhline_set.3xcurses
+usr/src/man/man3xcurses/mvwin_wch.3xcurses
+usr/src/man/man3xcurses/mvwin_wchnstr.3xcurses
+usr/src/man/man3xcurses/mvwin_wchstr.3xcurses
+usr/src/man/man3xcurses/mvwinch.3xcurses
+usr/src/man/man3xcurses/mvwinchnstr.3xcurses
+usr/src/man/man3xcurses/mvwinchstr.3xcurses
+usr/src/man/man3xcurses/mvwinnstr.3xcurses
+usr/src/man/man3xcurses/mvwinnwstr.3xcurses
+usr/src/man/man3xcurses/mvwins_nwstr.3xcurses
+usr/src/man/man3xcurses/mvwins_wch.3xcurses
+usr/src/man/man3xcurses/mvwins_wstr.3xcurses
+usr/src/man/man3xcurses/mvwinsch.3xcurses
+usr/src/man/man3xcurses/mvwinsnstr.3xcurses
+usr/src/man/man3xcurses/mvwinsstr.3xcurses
+usr/src/man/man3xcurses/mvwinstr.3xcurses
+usr/src/man/man3xcurses/mvwinwstr.3xcurses
+usr/src/man/man3xcurses/mvwprintw.3xcurses
+usr/src/man/man3xcurses/mvwscanw.3xcurses
+usr/src/man/man3xcurses/mvwvline.3xcurses
+usr/src/man/man3xcurses/mvwvline_set.3xcurses
+usr/src/man/man3xcurses/newterm.3xcurses
+usr/src/man/man3xcurses/newwin.3xcurses
+usr/src/man/man3xcurses/nocbreak.3xcurses
+usr/src/man/man3xcurses/noecho.3xcurses
+usr/src/man/man3xcurses/nonl.3xcurses
+usr/src/man/man3xcurses/noraw.3xcurses
+usr/src/man/man3xcurses/overwrite.3xcurses
+usr/src/man/man3xcurses/pair_content.3xcurses
+usr/src/man/man3xcurses/pecho_wchar.3xcurses
+usr/src/man/man3xcurses/pnoutrefresh.3xcurses
+usr/src/man/man3xcurses/prefresh.3xcurses
+usr/src/man/man3xcurses/printw.3xcurses
+usr/src/man/man3xcurses/putwin.3xcurses
+usr/src/man/man3xcurses/qiflush.3xcurses
+usr/src/man/man3xcurses/raw.3xcurses
+usr/src/man/man3xcurses/refresh.3xcurses
+usr/src/man/man3xcurses/reset_prog_mode.3xcurses
+usr/src/man/man3xcurses/reset_shell_mode.3xcurses
+usr/src/man/man3xcurses/restartterm.3xcurses
+usr/src/man/man3xcurses/savetty.3xcurses
+usr/src/man/man3xcurses/scanw.3xcurses
+usr/src/man/man3xcurses/scr_init.3xcurses
+usr/src/man/man3xcurses/scr_restore.3xcurses
+usr/src/man/man3xcurses/scr_set.3xcurses
+usr/src/man/man3xcurses/scroll.3xcurses
+usr/src/man/man3xcurses/scrollok.3xcurses
+usr/src/man/man3xcurses/set_curterm.3xcurses
+usr/src/man/man3xcurses/setscrreg.3xcurses
+usr/src/man/man3xcurses/setupterm.3xcurses
+usr/src/man/man3xcurses/slk_attr_off.3xcurses
+usr/src/man/man3xcurses/slk_attr_on.3xcurses
+usr/src/man/man3xcurses/slk_attr_set.3xcurses
+usr/src/man/man3xcurses/slk_attron.3xcurses
+usr/src/man/man3xcurses/slk_attrset.3xcurses
+usr/src/man/man3xcurses/slk_clear.3xcurses
+usr/src/man/man3xcurses/slk_color.3xcurses
+usr/src/man/man3xcurses/slk_init.3xcurses
+usr/src/man/man3xcurses/slk_label.3xcurses
+usr/src/man/man3xcurses/slk_noutrefresh.3xcurses
+usr/src/man/man3xcurses/slk_refresh.3xcurses
+usr/src/man/man3xcurses/slk_restore.3xcurses
+usr/src/man/man3xcurses/slk_set.3xcurses
+usr/src/man/man3xcurses/slk_touch.3xcurses
+usr/src/man/man3xcurses/slk_wset.3xcurses
+usr/src/man/man3xcurses/standout.3xcurses
+usr/src/man/man3xcurses/start_color.3xcurses
+usr/src/man/man3xcurses/subpad.3xcurses
+usr/src/man/man3xcurses/subwin.3xcurses
+usr/src/man/man3xcurses/term_attrs.3xcurses
+usr/src/man/man3xcurses/tgetflag.3xcurses
+usr/src/man/man3xcurses/tgetnum.3xcurses
+usr/src/man/man3xcurses/tgetstr.3xcurses
+usr/src/man/man3xcurses/tgoto.3xcurses
+usr/src/man/man3xcurses/tigetnum.3xcurses
+usr/src/man/man3xcurses/tigetstr.3xcurses
+usr/src/man/man3xcurses/timeout.3xcurses
+usr/src/man/man3xcurses/touchline.3xcurses
+usr/src/man/man3xcurses/touchwin.3xcurses
+usr/src/man/man3xcurses/tparm.3xcurses
+usr/src/man/man3xcurses/tputs.3xcurses
+usr/src/man/man3xcurses/unget_wch.3xcurses
+usr/src/man/man3xcurses/untouchwin.3xcurses
+usr/src/man/man3xcurses/vid_attr.3xcurses
+usr/src/man/man3xcurses/vid_puts.3xcurses
+usr/src/man/man3xcurses/vidputs.3xcurses
+usr/src/man/man3xcurses/vline.3xcurses
+usr/src/man/man3xcurses/vline_set.3xcurses
+usr/src/man/man3xcurses/wadd_wch.3xcurses
+usr/src/man/man3xcurses/wadd_wchnstr.3xcurses
+usr/src/man/man3xcurses/wadd_wchstr.3xcurses
+usr/src/man/man3xcurses/waddch.3xcurses
+usr/src/man/man3xcurses/waddchnstr.3xcurses
+usr/src/man/man3xcurses/waddchstr.3xcurses
+usr/src/man/man3xcurses/waddnstr.3xcurses
+usr/src/man/man3xcurses/waddnwstr.3xcurses
+usr/src/man/man3xcurses/waddstr.3xcurses
+usr/src/man/man3xcurses/waddwstr.3xcurses
+usr/src/man/man3xcurses/wattr_get.3xcurses
+usr/src/man/man3xcurses/wattr_off.3xcurses
+usr/src/man/man3xcurses/wattr_on.3xcurses
+usr/src/man/man3xcurses/wattr_set.3xcurses
+usr/src/man/man3xcurses/wattroff.3xcurses
+usr/src/man/man3xcurses/wattron.3xcurses
+usr/src/man/man3xcurses/wattrset.3xcurses
+usr/src/man/man3xcurses/wbkgd.3xcurses
+usr/src/man/man3xcurses/wbkgdset.3xcurses
+usr/src/man/man3xcurses/wbkgrnd.3xcurses
+usr/src/man/man3xcurses/wbkgrndset.3xcurses
+usr/src/man/man3xcurses/wborder.3xcurses
+usr/src/man/man3xcurses/wborder_set.3xcurses
+usr/src/man/man3xcurses/wchgat.3xcurses
+usr/src/man/man3xcurses/wclear.3xcurses
+usr/src/man/man3xcurses/wclrtobot.3xcurses
+usr/src/man/man3xcurses/wclrtoeol.3xcurses
+usr/src/man/man3xcurses/wcolor_set.3xcurses
+usr/src/man/man3xcurses/wcursyncup.3xcurses
+usr/src/man/man3xcurses/wdelch.3xcurses
+usr/src/man/man3xcurses/wdeleteln.3xcurses
+usr/src/man/man3xcurses/wecho_wchar.3xcurses
+usr/src/man/man3xcurses/wechochar.3xcurses
+usr/src/man/man3xcurses/werase.3xcurses
+usr/src/man/man3xcurses/wget_wch.3xcurses
+usr/src/man/man3xcurses/wget_wstr.3xcurses
+usr/src/man/man3xcurses/wgetbkgrnd.3xcurses
+usr/src/man/man3xcurses/wgetch.3xcurses
+usr/src/man/man3xcurses/wgetn_wstr.3xcurses
+usr/src/man/man3xcurses/wgetnstr.3xcurses
+usr/src/man/man3xcurses/wgetstr.3xcurses
+usr/src/man/man3xcurses/whline.3xcurses
+usr/src/man/man3xcurses/whline_set.3xcurses
+usr/src/man/man3xcurses/win_wch.3xcurses
+usr/src/man/man3xcurses/win_wchnstr.3xcurses
+usr/src/man/man3xcurses/win_wchstr.3xcurses
+usr/src/man/man3xcurses/winch.3xcurses
+usr/src/man/man3xcurses/winchnstr.3xcurses
+usr/src/man/man3xcurses/winchstr.3xcurses
+usr/src/man/man3xcurses/winnstr.3xcurses
+usr/src/man/man3xcurses/winnwstr.3xcurses
+usr/src/man/man3xcurses/wins_nwstr.3xcurses
+usr/src/man/man3xcurses/wins_wch.3xcurses
+usr/src/man/man3xcurses/wins_wstr.3xcurses
+usr/src/man/man3xcurses/winsch.3xcurses
+usr/src/man/man3xcurses/winsdelln.3xcurses
+usr/src/man/man3xcurses/winsertln.3xcurses
+usr/src/man/man3xcurses/winsnstr.3xcurses
+usr/src/man/man3xcurses/winsstr.3xcurses
+usr/src/man/man3xcurses/winstr.3xcurses
+usr/src/man/man3xcurses/winwstr.3xcurses
+usr/src/man/man3xcurses/wmove.3xcurses
+usr/src/man/man3xcurses/wnoutrefresh.3xcurses
+usr/src/man/man3xcurses/wprintw.3xcurses
+usr/src/man/man3xcurses/wredrawln.3xcurses
+usr/src/man/man3xcurses/wrefresh.3xcurses
+usr/src/man/man3xcurses/wscanw.3xcurses
+usr/src/man/man3xcurses/wscrl.3xcurses
+usr/src/man/man3xcurses/wsetscrreg.3xcurses
+usr/src/man/man3xcurses/wstandend.3xcurses
+usr/src/man/man3xcurses/wstandout.3xcurses
+usr/src/man/man3xcurses/wsyncdown.3xcurses
+usr/src/man/man3xcurses/wsyncup.3xcurses
+usr/src/man/man3xcurses/wtimeout.3xcurses
+usr/src/man/man3xcurses/wtouchln.3xcurses
+usr/src/man/man3xcurses/wvline.3xcurses
+usr/src/man/man3xcurses/wvline_set.3xcurses
+usr/src/man/man3xnet/getaddrinfo.3xnet
+usr/src/man/man3xnet/gethostbyaddr.3xnet
+usr/src/man/man3xnet/gethostbyname.3xnet
+usr/src/man/man3xnet/gethostent.3xnet
+usr/src/man/man3xnet/getnetbyaddr.3xnet
+usr/src/man/man3xnet/getnetbyname.3xnet
+usr/src/man/man3xnet/getnetent.3xnet
+usr/src/man/man3xnet/getprotobyname.3xnet
+usr/src/man/man3xnet/getprotobynumber.3xnet
+usr/src/man/man3xnet/getprotoent.3xnet
+usr/src/man/man3xnet/getservbyname.3xnet
+usr/src/man/man3xnet/getservbyport.3xnet
+usr/src/man/man3xnet/getservent.3xnet
+usr/src/man/man3xnet/htons.3xnet
+usr/src/man/man3xnet/if_freenameindex.3xnet
+usr/src/man/man3xnet/if_indextoname.3xnet
+usr/src/man/man3xnet/if_nameindex.3xnet
+usr/src/man/man3xnet/inet_lnaof.3xnet
+usr/src/man/man3xnet/inet_makeaddr.3xnet
+usr/src/man/man3xnet/inet_netof.3xnet
+usr/src/man/man3xnet/inet_network.3xnet
+usr/src/man/man3xnet/inet_ntoa.3xnet
+usr/src/man/man3xnet/inet_pton.3xnet
+usr/src/man/man3xnet/ntohl.3xnet
+usr/src/man/man3xnet/ntohs.3xnet
+usr/src/man/man3xnet/sethostent.3xnet
+usr/src/man/man3xnet/setnetent.3xnet
+usr/src/man/man3xnet/setprotoent.3xnet
+usr/src/man/man3xnet/setservent.3xnet
+usr/src/man/man4/addresses.4
+usr/src/man/man4/devid_cache.4
+usr/src/man/man4/devname_cache.4
+usr/src/man/man4/dir.4
+usr/src/man/man4/dumpdates.4
+usr/src/man/man4/fbtab.4
+usr/src/man/man4/forward.4
+usr/src/man/man4/fs.4
+usr/src/man/man4/intro.4
+usr/src/man/man4/isa.4
+usr/src/man/man4/md.cf.4
+usr/src/man/man4/mdi_ib_cache.4
+usr/src/man/man4/mdi_scsi_vhci_cache.4
+usr/src/man/man4/pci_unitaddr_persistent.4
+usr/src/man/man4/pcie.4
+usr/src/man/man4/qop.4
+usr/src/man/man4/rhosts.4
+usr/src/man/man4/sendmail.cf.4
+usr/src/man/man4/snapshot_cache.4
+usr/src/man/man4/submit.cf.4
+usr/src/man/man4/volume-defaults.4
+usr/src/man/man4/wtmp.4
+usr/src/man/man4/wtmpx.4
+usr/src/man/man5/ANSI.5
+usr/src/man/man5/C++.5
+usr/src/man/man5/C.5
+usr/src/man/man5/CSI.5
+usr/src/man/man5/ISO.5
+usr/src/man/man5/MT-Level.5
+usr/src/man/man5/POSIX.1.5
+usr/src/man/man5/POSIX.2.5
+usr/src/man/man5/POSIX.5
+usr/src/man/man5/RBAC.5
+usr/src/man/man5/SUS.5
+usr/src/man/man5/SUSv2.5
+usr/src/man/man5/SUSv3.5
+usr/src/man/man5/SVID.5
+usr/src/man/man5/SVID3.5
+usr/src/man/man5/XNS.5
+usr/src/man/man5/XNS4.5
+usr/src/man/man5/XNS5.5
+usr/src/man/man5/XPG.5
+usr/src/man/man5/XPG3.5
+usr/src/man/man5/XPG4.5
+usr/src/man/man5/XPG4v2.5
+usr/src/man/man5/advance.5
+usr/src/man/man5/architecture.5
+usr/src/man/man5/availability.5
+usr/src/man/man5/compile.5
+usr/src/man/man5/intro.5
+usr/src/man/man5/pthreads.5
+usr/src/man/man5/stability.5
+usr/src/man/man5/standard.5
+usr/src/man/man5/step.5
+usr/src/man/man5/teclarc.5
+usr/src/man/man7/intro.7
+usr/src/man/man7d/1394.7d
+usr/src/man/man7d/allkmem.7d
+usr/src/man/man7d/bscbus.7d
+usr/src/man/man7d/fdc.7d
+usr/src/man/man7d/firewire.7d
+usr/src/man/man7d/hwa1480_fw.7d
+usr/src/man/man7d/i2bsc.7d
+usr/src/man/man7d/kmem.7d
+usr/src/man/man7d/lo0.7d
+usr/src/man/man7d/ticots.7d
+usr/src/man/man7d/ticotsord.7d
+usr/src/man/man7d/urandom.7d
+usr/src/man/man7d/usb.7d
+usr/src/man/man7d/uwb.7d
+usr/src/man/man7m/vuid2ps2.7m
+usr/src/man/man7m/vuid3ps2.7m
+usr/src/man/man7m/vuidm3p.7m
+usr/src/man/man7m/vuidm4p.7m
+usr/src/man/man7m/vuidm5p.7m
+usr/src/man/man7p/AH.7p
+usr/src/man/man7p/ARP.7p
+usr/src/man/man7p/ESP.7p
+usr/src/man/man7p/ICMP.7p
+usr/src/man/man7p/IP.7p
+usr/src/man/man7p/RARP.7p
+usr/src/man/man7p/SCTP.7p
+usr/src/man/man7p/TCP.7p
+usr/src/man/man7p/UDP.7p
+usr/src/man/man7p/if.7p
+usr/src/man/man9/Intro.9
+usr/src/man/man9/intro.9
+usr/src/man/man9e/_info.9e
+usr/src/man/man9e/_init.9e
+usr/src/man/man9e/gldm_get_stats.9e
+usr/src/man/man9e/gldm_intr.9e
+usr/src/man/man9e/gldm_ioctl.9e
+usr/src/man/man9e/gldm_reset.9e
+usr/src/man/man9e/gldm_send.9e
+usr/src/man/man9e/gldm_set_mac_addr.9e
+usr/src/man/man9e/gldm_set_multicast.9e
+usr/src/man/man9e/gldm_set_promiscuous.9e
+usr/src/man/man9e/gldm_start.9e
+usr/src/man/man9e/gldm_stop.9e
+usr/src/man/man9e/intro.9e
+usr/src/man/man9e/tran_destroy_pkt.9e
+usr/src/man/man9e/tran_pkt_constructor.9e
+usr/src/man/man9e/tran_pkt_destructor.9e
+usr/src/man/man9e/tran_setcap.9e
+usr/src/man/man9e/tran_teardown_pkt.9e
+usr/src/man/man9e/tran_unquiesce.9e
+usr/src/man/man9f/SIZEOF_PTR.9f
+usr/src/man/man9f/SIZEOF_STRUCT.9f
+usr/src/man/man9f/STRUCT_BUF.9f
+usr/src/man/man9f/STRUCT_FADDR.9f
+usr/src/man/man9f/STRUCT_FGET.9f
+usr/src/man/man9f/STRUCT_FGETP.9f
+usr/src/man/man9f/STRUCT_FSET.9f
+usr/src/man/man9f/STRUCT_FSETP.9f
+usr/src/man/man9f/STRUCT_HANDLE.9f
+usr/src/man/man9f/STRUCT_INIT.9f
+usr/src/man/man9f/STRUCT_SET_HANDLE.9f
+usr/src/man/man9f/STRUCT_SIZE.9f
+usr/src/man/man9f/assert.9f
+usr/src/man/man9f/atomic_add_16.9f
+usr/src/man/man9f/atomic_add_16_nv.9f
+usr/src/man/man9f/atomic_add_32.9f
+usr/src/man/man9f/atomic_add_32_nv.9f
+usr/src/man/man9f/atomic_add_64.9f
+usr/src/man/man9f/atomic_add_64_nv.9f
+usr/src/man/man9f/atomic_add_8.9f
+usr/src/man/man9f/atomic_add_8_nv.9f
+usr/src/man/man9f/atomic_add_char.9f
+usr/src/man/man9f/atomic_add_char_nv.9f
+usr/src/man/man9f/atomic_add_int.9f
+usr/src/man/man9f/atomic_add_int_nv.9f
+usr/src/man/man9f/atomic_add_long.9f
+usr/src/man/man9f/atomic_add_long_nv.9f
+usr/src/man/man9f/atomic_add_ptr.9f
+usr/src/man/man9f/atomic_add_ptr_nv.9f
+usr/src/man/man9f/atomic_add_short.9f
+usr/src/man/man9f/atomic_add_short_nv.9f
+usr/src/man/man9f/atomic_and_16.9f
+usr/src/man/man9f/atomic_and_16_nv.9f
+usr/src/man/man9f/atomic_and_32.9f
+usr/src/man/man9f/atomic_and_32_nv.9f
+usr/src/man/man9f/atomic_and_64.9f
+usr/src/man/man9f/atomic_and_64_nv.9f
+usr/src/man/man9f/atomic_and_8.9f
+usr/src/man/man9f/atomic_and_8_nv.9f
+usr/src/man/man9f/atomic_and_uchar.9f
+usr/src/man/man9f/atomic_and_uchar_nv.9f
+usr/src/man/man9f/atomic_and_uint.9f
+usr/src/man/man9f/atomic_and_uint_nv.9f
+usr/src/man/man9f/atomic_and_ulong.9f
+usr/src/man/man9f/atomic_and_ulong_nv.9f
+usr/src/man/man9f/atomic_and_ushort.9f
+usr/src/man/man9f/atomic_and_ushort_nv.9f
+usr/src/man/man9f/atomic_cas_16.9f
+usr/src/man/man9f/atomic_cas_32.9f
+usr/src/man/man9f/atomic_cas_64.9f
+usr/src/man/man9f/atomic_cas_8.9f
+usr/src/man/man9f/atomic_cas_ptr.9f
+usr/src/man/man9f/atomic_cas_uchar.9f
+usr/src/man/man9f/atomic_cas_uint.9f
+usr/src/man/man9f/atomic_cas_ulong.9f
+usr/src/man/man9f/atomic_cas_ushort.9f
+usr/src/man/man9f/atomic_clear_long_excl.9f
+usr/src/man/man9f/atomic_dec_16.9f
+usr/src/man/man9f/atomic_dec_16_nv.9f
+usr/src/man/man9f/atomic_dec_32.9f
+usr/src/man/man9f/atomic_dec_32_nv.9f
+usr/src/man/man9f/atomic_dec_64.9f
+usr/src/man/man9f/atomic_dec_64_nv.9f
+usr/src/man/man9f/atomic_dec_8.9f
+usr/src/man/man9f/atomic_dec_8_nv.9f
+usr/src/man/man9f/atomic_dec_ptr.9f
+usr/src/man/man9f/atomic_dec_ptr_nv.9f
+usr/src/man/man9f/atomic_dec_uchar.9f
+usr/src/man/man9f/atomic_dec_uchar_nv.9f
+usr/src/man/man9f/atomic_dec_uint.9f
+usr/src/man/man9f/atomic_dec_uint_nv.9f
+usr/src/man/man9f/atomic_dec_ulong.9f
+usr/src/man/man9f/atomic_dec_ulong_nv.9f
+usr/src/man/man9f/atomic_dec_ushort.9f
+usr/src/man/man9f/atomic_dec_ushort_nv.9f
+usr/src/man/man9f/atomic_inc_16.9f
+usr/src/man/man9f/atomic_inc_16_nv.9f
+usr/src/man/man9f/atomic_inc_32.9f
+usr/src/man/man9f/atomic_inc_32_nv.9f
+usr/src/man/man9f/atomic_inc_64.9f
+usr/src/man/man9f/atomic_inc_64_nv.9f
+usr/src/man/man9f/atomic_inc_8.9f
+usr/src/man/man9f/atomic_inc_8_nv.9f
+usr/src/man/man9f/atomic_inc_ptr.9f
+usr/src/man/man9f/atomic_inc_ptr_nv.9f
+usr/src/man/man9f/atomic_inc_uchar.9f
+usr/src/man/man9f/atomic_inc_uchar_nv.9f
+usr/src/man/man9f/atomic_inc_uint.9f
+usr/src/man/man9f/atomic_inc_uint_nv.9f
+usr/src/man/man9f/atomic_inc_ulong.9f
+usr/src/man/man9f/atomic_inc_ulong_nv.9f
+usr/src/man/man9f/atomic_inc_ushort.9f
+usr/src/man/man9f/atomic_inc_ushort_nv.9f
+usr/src/man/man9f/atomic_or_16.9f
+usr/src/man/man9f/atomic_or_16_nv.9f
+usr/src/man/man9f/atomic_or_32.9f
+usr/src/man/man9f/atomic_or_32_nv.9f
+usr/src/man/man9f/atomic_or_64.9f
+usr/src/man/man9f/atomic_or_64_nv.9f
+usr/src/man/man9f/atomic_or_8.9f
+usr/src/man/man9f/atomic_or_8_nv.9f
+usr/src/man/man9f/atomic_or_uchar.9f
+usr/src/man/man9f/atomic_or_uchar_nv.9f
+usr/src/man/man9f/atomic_or_uint.9f
+usr/src/man/man9f/atomic_or_uint_nv.9f
+usr/src/man/man9f/atomic_or_ulong.9f
+usr/src/man/man9f/atomic_or_ulong_nv.9f
+usr/src/man/man9f/atomic_or_ushort.9f
+usr/src/man/man9f/atomic_or_ushort_nv.9f
+usr/src/man/man9f/atomic_set_long_excl.9f
+usr/src/man/man9f/atomic_swap_16.9f
+usr/src/man/man9f/atomic_swap_32.9f
+usr/src/man/man9f/atomic_swap_64.9f
+usr/src/man/man9f/atomic_swap_8.9f
+usr/src/man/man9f/atomic_swap_ptr.9f
+usr/src/man/man9f/atomic_swap_uchar.9f
+usr/src/man/man9f/atomic_swap_uint.9f
+usr/src/man/man9f/atomic_swap_ulong.9f
+usr/src/man/man9f/atomic_swap_ushort.9f
+usr/src/man/man9f/crgetgid.9f
+usr/src/man/man9f/crgetgroups.9f
+usr/src/man/man9f/crgetngroups.9f
+usr/src/man/man9f/crgetrgid.9f
+usr/src/man/man9f/crgetruid.9f
+usr/src/man/man9f/crgetsgid.9f
+usr/src/man/man9f/crgetsuid.9f
+usr/src/man/man9f/crgetuid.9f
+usr/src/man/man9f/crgetzoneid.9f
+usr/src/man/man9f/csx_Get16.9f
+usr/src/man/man9f/csx_Get32.9f
+usr/src/man/man9f/csx_Get64.9f
+usr/src/man/man9f/csx_GetEventMask.9f
+usr/src/man/man9f/csx_GetNextClient.9f
+usr/src/man/man9f/csx_GetNextTuple.9f
+usr/src/man/man9f/csx_Parse_CISTPL_DEVICE_A.9f
+usr/src/man/man9f/csx_Parse_CISTPL_DEVICE_OA.9f
+usr/src/man/man9f/csx_Parse_CISTPL_DEVICE_OC.9f
+usr/src/man/man9f/csx_Parse_CISTPL_JEDEC_A.9f
+usr/src/man/man9f/csx_Parse_CISTPL_LONGLINK_C.9f
+usr/src/man/man9f/csx_Put16.9f
+usr/src/man/man9f/csx_Put32.9f
+usr/src/man/man9f/csx_Put64.9f
+usr/src/man/man9f/csx_ReleaseIO.9f
+usr/src/man/man9f/csx_ReleaseIRQ.9f
+usr/src/man/man9f/csx_ReleaseSocketMask.9f
+usr/src/man/man9f/csx_ReleaseWindow.9f
+usr/src/man/man9f/csx_RemoveDeviceNode.9f
+usr/src/man/man9f/csx_RepGet16.9f
+usr/src/man/man9f/csx_RepGet32.9f
+usr/src/man/man9f/csx_RepGet64.9f
+usr/src/man/man9f/csx_RepPut16.9f
+usr/src/man/man9f/csx_RepPut32.9f
+usr/src/man/man9f/csx_RepPut64.9f
+usr/src/man/man9f/cv_broadcast.9f
+usr/src/man/man9f/cv_destroy.9f
+usr/src/man/man9f/cv_init.9f
+usr/src/man/man9f/cv_reltimedwait.9f
+usr/src/man/man9f/cv_reltimedwait_sig.9f
+usr/src/man/man9f/cv_signal.9f
+usr/src/man/man9f/cv_timedwait.9f
+usr/src/man/man9f/cv_timedwait_sig.9f
+usr/src/man/man9f/cv_wait.9f
+usr/src/man/man9f/cv_wait_sig.9f
+usr/src/man/man9f/ddi_btopr.9f
+usr/src/man/man9f/ddi_cb_unregister.9f
+usr/src/man/man9f/ddi_check_dma_handle.9f
+usr/src/man/man9f/ddi_devid_free.9f
+usr/src/man/man9f/ddi_devid_get.9f
+usr/src/man/man9f/ddi_devid_init.9f
+usr/src/man/man9f/ddi_devid_register.9f
+usr/src/man/man9f/ddi_devid_sizeof.9f
+usr/src/man/man9f/ddi_devid_str_decode.9f
+usr/src/man/man9f/ddi_devid_str_encode.9f
+usr/src/man/man9f/ddi_devid_str_free.9f
+usr/src/man/man9f/ddi_devid_unregister.9f
+usr/src/man/man9f/ddi_devid_valid.9f
+usr/src/man/man9f/ddi_devmap_segmap.9f
+usr/src/man/man9f/ddi_dmae_1stparty.9f
+usr/src/man/man9f/ddi_dmae_alloc.9f
+usr/src/man/man9f/ddi_dmae_disable.9f
+usr/src/man/man9f/ddi_dmae_enable.9f
+usr/src/man/man9f/ddi_dmae_getattr.9f
+usr/src/man/man9f/ddi_dmae_getcnt.9f
+usr/src/man/man9f/ddi_dmae_getlim.9f
+usr/src/man/man9f/ddi_dmae_prog.9f
+usr/src/man/man9f/ddi_dmae_release.9f
+usr/src/man/man9f/ddi_dmae_stop.9f
+usr/src/man/man9f/ddi_exit_critical.9f
+usr/src/man/man9f/ddi_fls.9f
+usr/src/man/man9f/ddi_fm_capable.9f
+usr/src/man/man9f/ddi_fm_dma_err_clear.9f
+usr/src/man/man9f/ddi_fm_dma_err_get.9f
+usr/src/man/man9f/ddi_fm_fini.9f
+usr/src/man/man9f/ddi_fm_handler_unregister.9f
+usr/src/man/man9f/ddi_get16.9f
+usr/src/man/man9f/ddi_get32.9f
+usr/src/man/man9f/ddi_get64.9f
+usr/src/man/man9f/ddi_get_iblock_cookie.9f
+usr/src/man/man9f/ddi_get_lbolt64.9f
+usr/src/man/man9f/ddi_get_name.9f
+usr/src/man/man9f/ddi_get_soft_iblock_cookie.9f
+usr/src/man/man9f/ddi_get_soft_state.9f
+usr/src/man/man9f/ddi_getb.9f
+usr/src/man/man9f/ddi_getl.9f
+usr/src/man/man9f/ddi_getll.9f
+usr/src/man/man9f/ddi_getlongprop.9f
+usr/src/man/man9f/ddi_getlongprop_buf.9f
+usr/src/man/man9f/ddi_getprop.9f
+usr/src/man/man9f/ddi_getproplen.9f
+usr/src/man/man9f/ddi_getw.9f
+usr/src/man/man9f/ddi_intr_block_disable.9f
+usr/src/man/man9f/ddi_intr_block_enable.9f
+usr/src/man/man9f/ddi_intr_clr_mask.9f
+usr/src/man/man9f/ddi_intr_disable.9f
+usr/src/man/man9f/ddi_intr_free.9f
+usr/src/man/man9f/ddi_intr_get_navail.9f
+usr/src/man/man9f/ddi_intr_get_softint_pri.9f
+usr/src/man/man9f/ddi_intr_remove_handler.9f
+usr/src/man/man9f/ddi_intr_remove_softint.9f
+usr/src/man/man9f/ddi_intr_set_cap.9f
+usr/src/man/man9f/ddi_intr_set_pri.9f
+usr/src/man/man9f/ddi_intr_set_softint_pri.9f
+usr/src/man/man9f/ddi_intr_trigger_softint.9f
+usr/src/man/man9f/ddi_io_get16.9f
+usr/src/man/man9f/ddi_io_get32.9f
+usr/src/man/man9f/ddi_io_getb.9f
+usr/src/man/man9f/ddi_io_getl.9f
+usr/src/man/man9f/ddi_io_getw.9f
+usr/src/man/man9f/ddi_io_put16.9f
+usr/src/man/man9f/ddi_io_put32.9f
+usr/src/man/man9f/ddi_io_putb.9f
+usr/src/man/man9f/ddi_io_putl.9f
+usr/src/man/man9f/ddi_io_putw.9f
+usr/src/man/man9f/ddi_io_rep_get16.9f
+usr/src/man/man9f/ddi_io_rep_get32.9f
+usr/src/man/man9f/ddi_io_rep_getb.9f
+usr/src/man/man9f/ddi_io_rep_getl.9f
+usr/src/man/man9f/ddi_io_rep_getw.9f
+usr/src/man/man9f/ddi_io_rep_put16.9f
+usr/src/man/man9f/ddi_io_rep_put32.9f
+usr/src/man/man9f/ddi_io_rep_putb.9f
+usr/src/man/man9f/ddi_io_rep_putl.9f
+usr/src/man/man9f/ddi_io_rep_putw.9f
+usr/src/man/man9f/ddi_iopb_free.9f
+usr/src/man/man9f/ddi_mem_free.9f
+usr/src/man/man9f/ddi_mem_get16.9f
+usr/src/man/man9f/ddi_mem_get32.9f
+usr/src/man/man9f/ddi_mem_get64.9f
+usr/src/man/man9f/ddi_mem_getb.9f
+usr/src/man/man9f/ddi_mem_getl.9f
+usr/src/man/man9f/ddi_mem_getll.9f
+usr/src/man/man9f/ddi_mem_getw.9f
+usr/src/man/man9f/ddi_mem_put16.9f
+usr/src/man/man9f/ddi_mem_put32.9f
+usr/src/man/man9f/ddi_mem_put64.9f
+usr/src/man/man9f/ddi_mem_putb.9f
+usr/src/man/man9f/ddi_mem_putl.9f
+usr/src/man/man9f/ddi_mem_putll.9f
+usr/src/man/man9f/ddi_mem_putw.9f
+usr/src/man/man9f/ddi_mem_rep_get16.9f
+usr/src/man/man9f/ddi_mem_rep_get32.9f
+usr/src/man/man9f/ddi_mem_rep_get64.9f
+usr/src/man/man9f/ddi_mem_rep_getb.9f
+usr/src/man/man9f/ddi_mem_rep_getl.9f
+usr/src/man/man9f/ddi_mem_rep_getll.9f
+usr/src/man/man9f/ddi_mem_rep_getw.9f
+usr/src/man/man9f/ddi_mem_rep_put16.9f
+usr/src/man/man9f/ddi_mem_rep_put32.9f
+usr/src/man/man9f/ddi_mem_rep_put64.9f
+usr/src/man/man9f/ddi_mem_rep_putb.9f
+usr/src/man/man9f/ddi_mem_rep_putl.9f
+usr/src/man/man9f/ddi_mem_rep_putll.9f
+usr/src/man/man9f/ddi_mem_rep_putw.9f
+usr/src/man/man9f/ddi_modclose.9f
+usr/src/man/man9f/ddi_modsym.9f
+usr/src/man/man9f/ddi_peek16.9f
+usr/src/man/man9f/ddi_peek32.9f
+usr/src/man/man9f/ddi_peek64.9f
+usr/src/man/man9f/ddi_peek8.9f
+usr/src/man/man9f/ddi_peekc.9f
+usr/src/man/man9f/ddi_peekd.9f
+usr/src/man/man9f/ddi_peekl.9f
+usr/src/man/man9f/ddi_peeks.9f
+usr/src/man/man9f/ddi_poke16.9f
+usr/src/man/man9f/ddi_poke32.9f
+usr/src/man/man9f/ddi_poke64.9f
+usr/src/man/man9f/ddi_poke8.9f
+usr/src/man/man9f/ddi_pokec.9f
+usr/src/man/man9f/ddi_poked.9f
+usr/src/man/man9f/ddi_pokel.9f
+usr/src/man/man9f/ddi_pokes.9f
+usr/src/man/man9f/ddi_prop_free.9f
+usr/src/man/man9f/ddi_prop_get_int64.9f
+usr/src/man/man9f/ddi_prop_lookup_byte_array.9f
+usr/src/man/man9f/ddi_prop_lookup_int64_array.9f
+usr/src/man/man9f/ddi_prop_lookup_int_array.9f
+usr/src/man/man9f/ddi_prop_lookup_string.9f
+usr/src/man/man9f/ddi_prop_lookup_string_array.9f
+usr/src/man/man9f/ddi_prop_modify.9f
+usr/src/man/man9f/ddi_prop_remove.9f
+usr/src/man/man9f/ddi_prop_remove_all.9f
+usr/src/man/man9f/ddi_prop_undefine.9f
+usr/src/man/man9f/ddi_prop_update_byte_array.9f
+usr/src/man/man9f/ddi_prop_update_int.9f
+usr/src/man/man9f/ddi_prop_update_int64.9f
+usr/src/man/man9f/ddi_prop_update_int64_array.9f
+usr/src/man/man9f/ddi_prop_update_int_array.9f
+usr/src/man/man9f/ddi_prop_update_string.9f
+usr/src/man/man9f/ddi_prop_update_string_array.9f
+usr/src/man/man9f/ddi_ptob.9f
+usr/src/man/man9f/ddi_put16.9f
+usr/src/man/man9f/ddi_put32.9f
+usr/src/man/man9f/ddi_put64.9f
+usr/src/man/man9f/ddi_putb.9f
+usr/src/man/man9f/ddi_putl.9f
+usr/src/man/man9f/ddi_putll.9f
+usr/src/man/man9f/ddi_putw.9f
+usr/src/man/man9f/ddi_remove_intr.9f
+usr/src/man/man9f/ddi_remove_softintr.9f
+usr/src/man/man9f/ddi_rep_get16.9f
+usr/src/man/man9f/ddi_rep_get32.9f
+usr/src/man/man9f/ddi_rep_get64.9f
+usr/src/man/man9f/ddi_rep_getb.9f
+usr/src/man/man9f/ddi_rep_getl.9f
+usr/src/man/man9f/ddi_rep_getll.9f
+usr/src/man/man9f/ddi_rep_getw.9f
+usr/src/man/man9f/ddi_rep_put16.9f
+usr/src/man/man9f/ddi_rep_put32.9f
+usr/src/man/man9f/ddi_rep_put64.9f
+usr/src/man/man9f/ddi_rep_putb.9f
+usr/src/man/man9f/ddi_rep_putl.9f
+usr/src/man/man9f/ddi_rep_putll.9f
+usr/src/man/man9f/ddi_rep_putw.9f
+usr/src/man/man9f/ddi_segmap_setup.9f
+usr/src/man/man9f/ddi_set_driver_private.9f
+usr/src/man/man9f/ddi_soft_state_fini.9f
+usr/src/man/man9f/ddi_soft_state_free.9f
+usr/src/man/man9f/ddi_soft_state_init.9f
+usr/src/man/man9f/ddi_soft_state_zalloc.9f
+usr/src/man/man9f/ddi_strdup.9f
+usr/src/man/man9f/ddi_strtoull.9f
+usr/src/man/man9f/ddi_taskq_create.9f
+usr/src/man/man9f/ddi_taskq_destroy.9f
+usr/src/man/man9f/ddi_taskq_dispatch.9f
+usr/src/man/man9f/ddi_taskq_resume.9f
+usr/src/man/man9f/ddi_taskq_suspend.9f
+usr/src/man/man9f/ddi_taskq_wait.9f
+usr/src/man/man9f/ddi_trigger_softintr.9f
+usr/src/man/man9f/ddi_umem_free.9f
+usr/src/man/man9f/ddi_umem_unlock.9f
+usr/src/man/man9f/ddi_unmap_regs.9f
+usr/src/man/man9f/desballoc.9f
+usr/src/man/man9f/devmap_load.9f
+usr/src/man/man9f/devmap_umem_setup.9f
+usr/src/man/man9f/dlerrorack.9f
+usr/src/man/man9f/dlokack.9f
+usr/src/man/man9f/dlphysaddrack.9f
+usr/src/man/man9f/dluderrorind.9f
+usr/src/man/man9f/free_pktiopb.9f
+usr/src/man/man9f/gld_intr.9f
+usr/src/man/man9f/gld_mac_alloc.9f
+usr/src/man/man9f/gld_mac_free.9f
+usr/src/man/man9f/gld_recv.9f
+usr/src/man/man9f/gld_register.9f
+usr/src/man/man9f/gld_sched.9f
+usr/src/man/man9f/gld_unregister.9f
+usr/src/man/man9f/id32_free.9f
+usr/src/man/man9f/id32_lookup.9f
+usr/src/man/man9f/inl.9f
+usr/src/man/man9f/intro.9f
+usr/src/man/man9f/inw.9f
+usr/src/man/man9f/kmem_cache_alloc.9f
+usr/src/man/man9f/kmem_cache_destroy.9f
+usr/src/man/man9f/kmem_cache_free.9f
+usr/src/man/man9f/kmem_cache_set_move.9f
+usr/src/man/man9f/kmem_free.9f
+usr/src/man/man9f/kmem_zalloc.9f
+usr/src/man/man9f/kstat_named_setstr.9f
+usr/src/man/man9f/kstat_runq_back_to_waitq.9f
+usr/src/man/man9f/kstat_runq_enter.9f
+usr/src/man/man9f/kstat_runq_exit.9f
+usr/src/man/man9f/kstat_waitq_enter.9f
+usr/src/man/man9f/kstat_waitq_exit.9f
+usr/src/man/man9f/kstat_waitq_to_runq.9f
+usr/src/man/man9f/ldi_awrite.9f
+usr/src/man/man9f/ldi_close.9f
+usr/src/man/man9f/ldi_get_devid.9f
+usr/src/man/man9f/ldi_get_minor_name.9f
+usr/src/man/man9f/ldi_get_otyp.9f
+usr/src/man/man9f/ldi_getmsg.9f
+usr/src/man/man9f/ldi_ident_from_dip.9f
+usr/src/man/man9f/ldi_ident_from_stream.9f
+usr/src/man/man9f/ldi_ident_release.9f
+usr/src/man/man9f/ldi_open_by_devid.9f
+usr/src/man/man9f/ldi_open_by_name.9f
+usr/src/man/man9f/ldi_prop_get_int64.9f
+usr/src/man/man9f/ldi_prop_lookup_byte_array.9f
+usr/src/man/man9f/ldi_prop_lookup_int64_array.9f
+usr/src/man/man9f/ldi_prop_lookup_string.9f
+usr/src/man/man9f/ldi_prop_lookup_string_array.9f
+usr/src/man/man9f/ldi_write.9f
+usr/src/man/man9f/list_destroy.9f
+usr/src/man/man9f/list_head.9f
+usr/src/man/man9f/list_insert_after.9f
+usr/src/man/man9f/list_insert_before.9f
+usr/src/man/man9f/list_insert_head.9f
+usr/src/man/man9f/list_insert_tail.9f
+usr/src/man/man9f/list_is_empty.9f
+usr/src/man/man9f/list_link_active.9f
+usr/src/man/man9f/list_link_init.9f
+usr/src/man/man9f/list_link_replace.9f
+usr/src/man/man9f/list_move_tail.9f
+usr/src/man/man9f/list_next.9f
+usr/src/man/man9f/list_prev.9f
+usr/src/man/man9f/list_remove.9f
+usr/src/man/man9f/list_remove_head.9f
+usr/src/man/man9f/list_remove_tail.9f
+usr/src/man/man9f/list_tail.9f
+usr/src/man/man9f/makecom_g0.9f
+usr/src/man/man9f/makecom_g0_s.9f
+usr/src/man/man9f/makecom_g1.9f
+usr/src/man/man9f/makecom_g5.9f
+usr/src/man/man9f/membar_consumer.9f
+usr/src/man/man9f/membar_enter.9f
+usr/src/man/man9f/membar_exit.9f
+usr/src/man/man9f/membar_producer.9f
+usr/src/man/man9f/memcmp.9f
+usr/src/man/man9f/memcpy.9f
+usr/src/man/man9f/memmove.9f
+usr/src/man/man9f/memset.9f
+usr/src/man/man9f/minphys.9f
+usr/src/man/man9f/mod_info.9f
+usr/src/man/man9f/mod_modname.9f
+usr/src/man/man9f/mod_remove.9f
+usr/src/man/man9f/mutex_destroy.9f
+usr/src/man/man9f/mutex_enter.9f
+usr/src/man/man9f/mutex_exit.9f
+usr/src/man/man9f/mutex_init.9f
+usr/src/man/man9f/mutex_owned.9f
+usr/src/man/man9f/mutex_tryenter.9f
+usr/src/man/man9f/net_event_notify_unregister.9f
+usr/src/man/man9f/net_instance_notify_unregister.9f
+usr/src/man/man9f/net_instance_protocol_unregister.9f
+usr/src/man/man9f/numtos.9f
+usr/src/man/man9f/nv_alloc_fini.9f
+usr/src/man/man9f/nv_alloc_init.9f
+usr/src/man/man9f/nvlist_add_boolean_array.9f
+usr/src/man/man9f/nvlist_add_boolean_value.9f
+usr/src/man/man9f/nvlist_add_byte.9f
+usr/src/man/man9f/nvlist_add_byte_array.9f
+usr/src/man/man9f/nvlist_add_int16.9f
+usr/src/man/man9f/nvlist_add_int16_array.9f
+usr/src/man/man9f/nvlist_add_int32.9f
+usr/src/man/man9f/nvlist_add_int32_array.9f
+usr/src/man/man9f/nvlist_add_int64.9f
+usr/src/man/man9f/nvlist_add_int64_array.9f
+usr/src/man/man9f/nvlist_add_int8.9f
+usr/src/man/man9f/nvlist_add_int8_array.9f
+usr/src/man/man9f/nvlist_add_nvlist.9f
+usr/src/man/man9f/nvlist_add_nvlist_array.9f
+usr/src/man/man9f/nvlist_add_nvpair.9f
+usr/src/man/man9f/nvlist_add_string.9f
+usr/src/man/man9f/nvlist_add_string_array.9f
+usr/src/man/man9f/nvlist_add_uint16.9f
+usr/src/man/man9f/nvlist_add_uint16_array.9f
+usr/src/man/man9f/nvlist_add_uint32.9f
+usr/src/man/man9f/nvlist_add_uint32_array.9f
+usr/src/man/man9f/nvlist_add_uint64.9f
+usr/src/man/man9f/nvlist_add_uint64_array.9f
+usr/src/man/man9f/nvlist_add_uint8.9f
+usr/src/man/man9f/nvlist_add_uint8_array.9f
+usr/src/man/man9f/nvlist_dup.9f
+usr/src/man/man9f/nvlist_exists.9f
+usr/src/man/man9f/nvlist_free.9f
+usr/src/man/man9f/nvlist_lookup_boolean_array.9f
+usr/src/man/man9f/nvlist_lookup_boolean_value.9f
+usr/src/man/man9f/nvlist_lookup_byte.9f
+usr/src/man/man9f/nvlist_lookup_byte_array.9f
+usr/src/man/man9f/nvlist_lookup_int16.9f
+usr/src/man/man9f/nvlist_lookup_int16_array.9f
+usr/src/man/man9f/nvlist_lookup_int32.9f
+usr/src/man/man9f/nvlist_lookup_int32_array.9f
+usr/src/man/man9f/nvlist_lookup_int64.9f
+usr/src/man/man9f/nvlist_lookup_int64_array.9f
+usr/src/man/man9f/nvlist_lookup_int8.9f
+usr/src/man/man9f/nvlist_lookup_int8_array.9f
+usr/src/man/man9f/nvlist_lookup_nvlist.9f
+usr/src/man/man9f/nvlist_lookup_nvlist_array.9f
+usr/src/man/man9f/nvlist_lookup_pairs.9f
+usr/src/man/man9f/nvlist_lookup_string.9f
+usr/src/man/man9f/nvlist_lookup_string_array.9f
+usr/src/man/man9f/nvlist_lookup_uint16.9f
+usr/src/man/man9f/nvlist_lookup_uint16_array.9f
+usr/src/man/man9f/nvlist_lookup_uint32.9f
+usr/src/man/man9f/nvlist_lookup_uint32_array.9f
+usr/src/man/man9f/nvlist_lookup_uint64.9f
+usr/src/man/man9f/nvlist_lookup_uint64_array.9f
+usr/src/man/man9f/nvlist_lookup_uint8.9f
+usr/src/man/man9f/nvlist_lookup_uint8_array.9f
+usr/src/man/man9f/nvlist_merge.9f
+usr/src/man/man9f/nvlist_pack.9f
+usr/src/man/man9f/nvlist_remove_all.9f
+usr/src/man/man9f/nvlist_size.9f
+usr/src/man/man9f/nvlist_t.9f
+usr/src/man/man9f/nvlist_unpack.9f
+usr/src/man/man9f/nvlist_xalloc.9f
+usr/src/man/man9f/nvlist_xdup.9f
+usr/src/man/man9f/nvlist_xpack.9f
+usr/src/man/man9f/nvlist_xunpack.9f
+usr/src/man/man9f/nvpair_name.9f
+usr/src/man/man9f/nvpair_type.9f
+usr/src/man/man9f/nvpair_value_boolean_array.9f
+usr/src/man/man9f/nvpair_value_byte_array.9f
+usr/src/man/man9f/nvpair_value_int16.9f
+usr/src/man/man9f/nvpair_value_int16_array.9f
+usr/src/man/man9f/nvpair_value_int32.9f
+usr/src/man/man9f/nvpair_value_int32_array.9f
+usr/src/man/man9f/nvpair_value_int64.9f
+usr/src/man/man9f/nvpair_value_int64_array.9f
+usr/src/man/man9f/nvpair_value_int8.9f
+usr/src/man/man9f/nvpair_value_int8_array.9f
+usr/src/man/man9f/nvpair_value_nvlist.9f
+usr/src/man/man9f/nvpair_value_nvlist_array.9f
+usr/src/man/man9f/nvpair_value_string.9f
+usr/src/man/man9f/nvpair_value_string_array.9f
+usr/src/man/man9f/nvpair_value_uint16.9f
+usr/src/man/man9f/nvpair_value_uint16_array.9f
+usr/src/man/man9f/nvpair_value_uint32.9f
+usr/src/man/man9f/nvpair_value_uint32_array.9f
+usr/src/man/man9f/nvpair_value_uint64.9f
+usr/src/man/man9f/nvpair_value_uint64_array.9f
+usr/src/man/man9f/nvpair_value_uint8.9f
+usr/src/man/man9f/nvpair_value_uint8_array.9f
+usr/src/man/man9f/otherq.9f
+usr/src/man/man9f/outl.9f
+usr/src/man/man9f/outw.9f
+usr/src/man/man9f/pci_config_get16.9f
+usr/src/man/man9f/pci_config_get32.9f
+usr/src/man/man9f/pci_config_get64.9f
+usr/src/man/man9f/pci_config_getb.9f
+usr/src/man/man9f/pci_config_getl.9f
+usr/src/man/man9f/pci_config_getll.9f
+usr/src/man/man9f/pci_config_getw.9f
+usr/src/man/man9f/pci_config_put16.9f
+usr/src/man/man9f/pci_config_put32.9f
+usr/src/man/man9f/pci_config_put64.9f
+usr/src/man/man9f/pci_config_put8.9f
+usr/src/man/man9f/pci_config_putb.9f
+usr/src/man/man9f/pci_config_putl.9f
+usr/src/man/man9f/pci_config_putll.9f
+usr/src/man/man9f/pci_config_putw.9f
+usr/src/man/man9f/pci_config_teardown.9f
+usr/src/man/man9f/pci_ereport_post.9f
+usr/src/man/man9f/pci_ereport_teardown.9f
+usr/src/man/man9f/pci_restore_config_regs.9f
+usr/src/man/man9f/pm_idle_component.9f
+usr/src/man/man9f/pm_lower_power.9f
+usr/src/man/man9f/priv_policy_choice.9f
+usr/src/man/man9f/priv_policy_only.9f
+usr/src/man/man9f/proc_ref.9f
+usr/src/man/man9f/proc_unref.9f
+usr/src/man/man9f/qprocsoff.9f
+usr/src/man/man9f/qwait_sig.9f
+usr/src/man/man9f/rd.9f
+usr/src/man/man9f/repinsb.9f
+usr/src/man/man9f/repinsd.9f
+usr/src/man/man9f/repinsw.9f
+usr/src/man/man9f/repoutsb.9f
+usr/src/man/man9f/repoutsd.9f
+usr/src/man/man9f/repoutsw.9f
+usr/src/man/man9f/rmallocmap_wait.9f
+usr/src/man/man9f/rmfreemap.9f
+usr/src/man/man9f/rw_destroy.9f
+usr/src/man/man9f/rw_downgrade.9f
+usr/src/man/man9f/rw_enter.9f
+usr/src/man/man9f/rw_exit.9f
+usr/src/man/man9f/rw_init.9f
+usr/src/man/man9f/rw_read_locked.9f
+usr/src/man/man9f/rw_tryenter.9f
+usr/src/man/man9f/rw_tryupgrade.9f
+usr/src/man/man9f/samestr.9f
+usr/src/man/man9f/scsi_dmafree.9f
+usr/src/man/man9f/scsi_dname.9f
+usr/src/man/man9f/scsi_hba_attach.9f
+usr/src/man/man9f/scsi_hba_detach.9f
+usr/src/man/man9f/scsi_hba_fini.9f
+usr/src/man/man9f/scsi_hba_pkt_free.9f
+usr/src/man/man9f/scsi_hba_tran_free.9f
+usr/src/man/man9f/scsi_ifsetcap.9f
+usr/src/man/man9f/scsi_mname.9f
+usr/src/man/man9f/scsi_pktfree.9f
+usr/src/man/man9f/scsi_resalloc.9f
+usr/src/man/man9f/scsi_resfree.9f
+usr/src/man/man9f/scsi_rname.9f
+usr/src/man/man9f/scsi_sense_asc.9f
+usr/src/man/man9f/scsi_sense_ascq.9f
+usr/src/man/man9f/scsi_sense_cmdspecific_uint64.9f
+usr/src/man/man9f/scsi_sense_info_uint64.9f
+usr/src/man/man9f/scsi_sname.9f
+usr/src/man/man9f/scsi_unslave.9f
+usr/src/man/man9f/sema_destroy.9f
+usr/src/man/man9f/sema_init.9f
+usr/src/man/man9f/sema_p.9f
+usr/src/man/man9f/sema_p_sig.9f
+usr/src/man/man9f/sema_tryp.9f
+usr/src/man/man9f/sema_v.9f
+usr/src/man/man9f/strcasecmp.9f
+usr/src/man/man9f/strchr.9f
+usr/src/man/man9f/strcmp.9f
+usr/src/man/man9f/strcpy.9f
+usr/src/man/man9f/strdup.9f
+usr/src/man/man9f/strfree.9f
+usr/src/man/man9f/strlcat.9f
+usr/src/man/man9f/strlcpy.9f
+usr/src/man/man9f/strlen.9f
+usr/src/man/man9f/strncasecmp.9f
+usr/src/man/man9f/strncat.9f
+usr/src/man/man9f/strncmp.9f
+usr/src/man/man9f/strncpy.9f
+usr/src/man/man9f/strnlen.9f
+usr/src/man/man9f/strrchr.9f
+usr/src/man/man9f/strspn.9f
+usr/src/man/man9f/taskq_suspended.9f
+usr/src/man/man9f/uconv_u16tou8.9f
+usr/src/man/man9f/uconv_u32tou16.9f
+usr/src/man/man9f/uconv_u32tou8.9f
+usr/src/man/man9f/uconv_u8tou16.9f
+usr/src/man/man9f/uconv_u8tou32.9f
+usr/src/man/man9f/unfreezestr.9f
+usr/src/man/man9f/usb_alloc_bulk_req.9f
+usr/src/man/man9f/usb_alloc_ctrl_req.9f
+usr/src/man/man9f/usb_alloc_intr_req.9f
+usr/src/man/man9f/usb_alloc_isoc_req.9f
+usr/src/man/man9f/usb_client_detach.9f
+usr/src/man/man9f/usb_free_bulk_req.9f
+usr/src/man/man9f/usb_free_ctrl_req.9f
+usr/src/man/man9f/usb_free_descr_tree.9f
+usr/src/man/man9f/usb_free_dev_data.9f
+usr/src/man/man9f/usb_free_intr_req.9f
+usr/src/man/man9f/usb_free_isoc_req.9f
+usr/src/man/man9f/usb_get_if_number.9f
+usr/src/man/man9f/usb_owns_device.9f
+usr/src/man/man9f/usb_pipe_ctrl_xfer_wait.9f
+usr/src/man/man9f/usb_pipe_get_private.9f
+usr/src/man/man9f/usb_pipe_stop_intr_polling.9f
+usr/src/man/man9f/usb_pipe_stop_isoc_polling.9f
+usr/src/man/man9f/usb_print_descr_tree.9f
+usr/src/man/man9f/usb_set_alt_if.9f
+usr/src/man/man9f/usb_set_cfg.9f
+usr/src/man/man9f/usb_unregister_hotplug_cbs.9f
+usr/src/man/man9f/va_copy.9f
+usr/src/man/man9f/va_end.9f
+usr/src/man/man9f/va_start.9f
+usr/src/man/man9f/vcmn_err.9f
+usr/src/man/man9f/wr.9f
+usr/src/man/man9f/zcmn_err.9f
+usr/src/man/man9p/Nblock.9p
+usr/src/man/man9p/blksize.9p
+usr/src/man/man9p/ddi-no-autodetach.9p
+usr/src/man/man9p/device-blksize.9p
+usr/src/man/man9p/device-nblocks.9p
+usr/src/man/man9p/inquiry-product-id.9p
+usr/src/man/man9p/inquiry-revision-id.9p
+usr/src/man/man9p/inquiry-serial-no.9p
+usr/src/man/man9p/inquiry-vendor-id.9p
+usr/src/man/man9s/dblk.9s
+usr/src/man/man9s/ddi_dma_lim.9s
+usr/src/man/man9s/intro.9s
+usr/src/man/man9s/mblk.9s
+usr/src/msg/magic
+usr/src/msg/mailx.help
+usr/src/msg/more.help
+usr/src/msg/priv_names
+usr/src/pkg/license-list
+usr/src/pkg/packages.i386/
+usr/src/psm/stand/bootblks/ufs/i386/installboot
+usr/src/psm/stand/bootblks/ufs/i386/mboot
+usr/src/psm/stand/bootblks/ufs/i386/mboot.exec
+usr/src/tools/aw/aw
+usr/src/tools/codereview/codereview
+usr/src/tools/codesign/findcrypto
+usr/src/tools/codesign/signit
+usr/src/tools/codesign/signproto
+usr/src/tools/cscope-fast/cscope-fast
+usr/src/tools/ctf/cvt/i386/ctfconvert
+usr/src/tools/ctf/cvt/i386/ctfmerge
+usr/src/tools/ctf/dump/i386/ctfdump
+usr/src/tools/ctf/scripts/ctfcvtptbl
+usr/src/tools/ctf/scripts/ctffindmod
+usr/src/tools/ctf/stabs/i386/ctfstabs
+usr/src/tools/cw/cw
+usr/src/tools/elfextract/elfextract
+usr/src/tools/elfsign/elfsign
+usr/src/tools/elfsign/elfsigncmp
+usr/src/tools/env/developer
+usr/src/tools/env/gatekeeper
+usr/src/tools/env/illumos
+usr/src/tools/findunref/exception_list
+usr/src/tools/findunref/findunref
+usr/src/tools/gk/cshrc
+usr/src/tools/gk/gen_make.machines
+usr/src/tools/gk/login
+usr/src/tools/install-i386.out
+usr/src/tools/install.bin/install.bin
+usr/src/tools/lintdump/lintdump
+usr/src/tools/mbh_patch/mbh_patch
+usr/src/tools/ndrgen/ndrgen
+usr/src/tools/ndrgen/ndrgen1
+usr/src/tools/ndrgen/y.tab.c
+usr/src/tools/ndrgen/y.tab.h
+usr/src/tools/pmodes/pmodes
+usr/src/tools/proto/
+usr/src/tools/protocmp/protocmp
+usr/src/tools/protolist/protolist
+usr/src/tools/scripts/Install
+usr/src/tools/scripts/bindrop
+usr/src/tools/scripts/bldenv
+usr/src/tools/scripts/bldenv.1
+usr/src/tools/scripts/bringovercheck
+usr/src/tools/scripts/build_cscope
+usr/src/tools/scripts/cddlchk
+usr/src/tools/scripts/check_rtime
+usr/src/tools/scripts/checkpaths
+usr/src/tools/scripts/checkproto
+usr/src/tools/scripts/copyrightchk
+usr/src/tools/scripts/cryptodrop
+usr/src/tools/scripts/cstyle
+usr/src/tools/scripts/elfcmp
+usr/src/tools/scripts/find_elf
+usr/src/tools/scripts/flg.flp
+usr/src/tools/scripts/genoffsets
+usr/src/tools/scripts/git-active
+usr/src/tools/scripts/hdrchk
+usr/src/tools/scripts/hg-active
+usr/src/tools/scripts/hgsetup
+usr/src/tools/scripts/interface_check
+usr/src/tools/scripts/interface_cmp
+usr/src/tools/scripts/jstyle
+usr/src/tools/scripts/mapfilechk
+usr/src/tools/scripts/mkreadme_osol
+usr/src/tools/scripts/mktpl
+usr/src/tools/scripts/nightly
+usr/src/tools/scripts/onu
+usr/src/tools/scripts/protocmp.terse
+usr/src/tools/scripts/sccscheck
+usr/src/tools/scripts/validate_flg
+usr/src/tools/scripts/validate_paths
+usr/src/tools/scripts/validate_pkg
+usr/src/tools/scripts/wdiff
+usr/src/tools/scripts/webrev
+usr/src/tools/scripts/which_scm
+usr/src/tools/scripts/ws
+usr/src/tools/scripts/wsdiff
+usr/src/tools/scripts/xref
+usr/src/ucbcmd/basename/basename
+usr/src/ucbcmd/biff/biff
+usr/src/ucbcmd/chown/chown
+usr/src/ucbcmd/df/df
+usr/src/ucbcmd/du/du
+usr/src/ucbcmd/echo/echo
+usr/src/ucbcmd/expr/expr
+usr/src/ucbcmd/fastboot/fastboot
+usr/src/ucbcmd/fasthalt/fasthalt
+usr/src/ucbcmd/file/file
+usr/src/ucbcmd/from/from
+usr/src/ucbcmd/groups/groups
+usr/src/ucbcmd/install.d/installcmd
+usr/src/ucbcmd/ln/ln
+usr/src/ucbcmd/ls/ls
+usr/src/ucbcmd/mkstr/mkstr
+usr/src/ucbcmd/printenv/printenv
+usr/src/ucbcmd/rusage/rusage
+usr/src/ucbcmd/sed/sed
+usr/src/ucbcmd/shutdown/shutdown
+usr/src/ucbcmd/stty/stty
+usr/src/ucbcmd/sum/sum
+usr/src/ucbcmd/test/test
+usr/src/ucbcmd/touch/touch
+usr/src/ucbcmd/tr/tr
+usr/src/ucbcmd/tset/tset
+usr/src/ucbcmd/users/users
+usr/src/ucbcmd/vipw/vipw
+usr/src/ucbcmd/whereis/whereis
+usr/src/ucbcmd/whoami/whoami
+usr/src/uts/common/avs/ns/rdc/rdc_prot.h
+usr/src/uts/common/gssapi/gssd_prot.c
+usr/src/uts/common/gssapi/gssd_prot.h
+usr/src/uts/common/gssapi/gssd_xdr.c
+usr/src/uts/common/idmap/idmap_xdr.c
+usr/src/uts/common/io/fibre-channel/fca/qlc/ql_fw_table.c
+usr/src/uts/common/io/lvm/md/meta_basic_xdr.c
+usr/src/uts/common/io/lvm/md/metamed_xdr.c
+usr/src/uts/common/io/usb/clients/hwa1480_fw/i1480/hwa1480_fw
+usr/src/uts/common/os/priv_const.c
+usr/src/uts/common/rpc/key_prot.h
+usr/src/uts/common/rpc/pmap_prot.h
+usr/src/uts/common/rpc/rpc_sztypes.h
+usr/src/uts/common/rpc/rpcb_prot.h
+usr/src/uts/common/rpcsvc/autofs_prot.h
+usr/src/uts/common/rpcsvc/idmap_prot.h
+usr/src/uts/common/rpcsvc/nsm_addr.h
+usr/src/uts/common/rpcsvc/sm_inter.h
+usr/src/uts/common/sys/lvm/md_basic.h
+usr/src/uts/common/sys/lvm/md_mdiox.h
+usr/src/uts/common/sys/lvm/md_mhdx.h
+usr/src/uts/common/sys/lvm/mdmed.h
+usr/src/uts/common/sys/lvm/mdmn_commd.h
+usr/src/uts/common/sys/priv_const.h
+usr/src/uts/common/sys/priv_names.h
+usr/src/uts/common/sys/usb/usbdevs.h
+usr/src/uts/i86pc/cpu/scripts/ao_gendisp
+usr/src/uts/i86pc/io/acpi/drmach_acpi/drmach_err.c
+usr/src/uts/i86pc/io/acpi/drmach_acpi/sbdgenerr
+usr/src/uts/i86pc/io/dr/dr_err.c
+usr/src/uts/i86pc/io/dr/sbdgenerr
+usr/src/uts/i86pc/unix/multiboot
+usr/src/uts/intel/arcfour/arcfour-x86_64.s
+usr/src/uts/intel/genunix/debug32/
+usr/src/uts/intel/genunix/debug64/
+usr/src/uts/intel/ip/ip.symbols.obj64.diff
+usr/src/uts/intel/ip/ip.symbols.obj64.tmp
+usr/src/uts/intel/ip/ip.symbols.obj64.tmp.new
+usr/src/uts/intel/md5/md5_amd64.s
+usr/src/uts/intel/mwlfw/mw88W8363fw
+usr/src/uts/intel/mwlfw/mwlboot
+usr/src/uts/intel/os/priv_names
+usr/src/uts/intel/sha1/sha1-x86_64.s
+usr/src/uts/intel/sha2/sha256-x86_64.s
+usr/src/uts/intel/sha2/sha512-x86_64.s
+usr/src/uts/intel/sockfs/nl7ctokgen.h
+usr/src/uts/intel/uathfw/uathbin
OS-4439
OS-4602
manifest
usr/src/Makefile.lint
--- /export/home/danmcd/ws/illumos-omnios/usr/src/Makefile.lint	Tue Jul 21 14:14:22 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/Makefile.lint	Mon Dec 28 16:27:39 2015
@@ -194,6 +194,7 @@
 	cmd/ls \
 	cmd/luxadm \
 	cmd/lvm \
+	cmd/machid \
 	cmd/mailwrapper \
 	cmd/makekey \
 	cmd/mdb \
@@ -279,7 +280,6 @@
 	cmd/split \
 	cmd/srptadm \
 	cmd/srptsvc \
-	cmd/ssh \
 	cmd/stat \
 	cmd/stmfadm \
 	cmd/stmfsvc \
@@ -460,7 +460,6 @@
 	lib/pam_modules \
 	lib/passwdutil \
 	lib/pkcs11 \
-	lib/print \
 	lib/raidcfg_plugins \
 	lib/scsi \
 	lib/smbsrv \
@@ -485,6 +484,7 @@
 	cmd/biosdev \
 	cmd/rtc \
 	cmd/ucodeadm \
+	lib/brand/lx \
 	lib/cfgadm_plugins/sata \
 	lib/cfgadm_plugins/sbd \
 	lib/libfdisk
usr/src/Makefile.master.64
--- /export/home/danmcd/ws/illumos-omnios/usr/src/Makefile.master.64	Tue Jul 21 14:14:22 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/Makefile.master.64	Wed Jun 17 17:43:36 2015
@@ -21,6 +21,7 @@
 #
 # Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
+# Copyright (c) 2014 Joyent, Inc.  All rights reserved.
 #
 
 # rebind basic build macros to 64-bit versions
@@ -67,7 +68,7 @@
 REAL_CCC=	$(CW_CCC_CMD:sh)
 
 BUILD.SO=	$(CC) $(CFLAGS) -o $@ $(GSHARED) $(DYNFLAGS) \
-		$(PICS) $(EXTPICS) -L $(ROOTLIBDIR64) $(LDLIBS)
+		$(PICS) $(EXTPICS) $(USDT_PICS) -L $(ROOTLIBDIR64) $(LDLIBS)
 
 #
 # ld(1) requires the -64 option to create a 64-bit filter solely from a mapfile
usr/src/Targetdirs
--- /export/home/danmcd/ws/illumos-omnios/usr/src/Targetdirs	Tue Jan  5 17:20:21 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/Targetdirs	Mon Dec 28 16:27:39 2015
@@ -23,10 +23,10 @@
 # Copyright 2011, Richard Lowe
 # Copyright (c) 2012 by Delphix. All rights reserved.
 # Copyright (c) 2012, Igor Kozhukhov <ikozhukhov@gmail.com>
+# Copyright 2012 OmniTI Computer Consulting, Inc.  All rights reserved.
 # Copyright (c) 2013 RackTop Systems.
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
 # Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
-# Copyright 2015 OmniTI Computer Consulting, Inc.  All rights reserved.
 #
 
 #
@@ -53,6 +53,9 @@
 	/boot/grub/bin		\
 	/platform/i86pc		\
 	/lib/libmvec		\
+	/usr/lib/brand/lx	\
+	/usr/lib/brand/lx/amd64 \
+	/usr/lib/brand/lx/distros \
 	/usr/lib/xen		\
 	/usr/lib/xen/bin
 
@@ -246,7 +249,6 @@
 	/usr/lib/abi \
 	/usr/lib/brand \
 	/usr/lib/brand/ipkg \
-	/usr/lib/brand/lipkg \
 	/usr/lib/brand/labeled \
 	/usr/lib/brand/shared \
 	/usr/lib/brand/sn1 \
@@ -282,6 +284,7 @@
 	/usr/lib/mdb/kvm \
 	/usr/lib/mdb/proc \
 	/usr/lib/nfs \
+	/usr/lib/varpd \
 	/usr/net \
 	/usr/net/servers \
 	/usr/lib/pool \
@@ -469,6 +472,7 @@
 	/usr/lib/security/$(MACH64) \
 	/usr/lib/smbsrv/$(MACH64) \
 	/usr/lib/abi/$(MACH64) \
+	/usr/lib/varpd/$(MACH64) \
 	/usr/sbin/$(MACH64) \
 	/usr/ucb/$(MACH64) \
 	/usr/ucblib/$(MACH64) \
@@ -512,6 +516,9 @@
 	/usr/ucblib/32 \
 	/var/ld/32
 
+i386_SYM.DIRS64= \
+	/usr/lib/brand/lx/64
+
 sparc_SYM.DIRS64=
 
 SYM.DIRS64= \
@@ -528,6 +535,7 @@
 	/usr/lib/lwp/64 \
 	/usr/lib/secure/64 \
 	/usr/lib/security/64 \
+	/usr/lib/varpd/64 \
 	/usr/xpg4/lib/64 \
 	/var/ld/64 \
 	/usr/ucblib/64
@@ -629,6 +637,7 @@
 $(BUILD64) $(ROOT)/lib/secure/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/64:=		LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/elfedit/64:=	LINKDEST=$(MACH64)
+$(BUILD64) $(ROOT)/usr/lib/brand/lx/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/brand/sn1/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/brand/solaris10/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/libp/64:=	LINKDEST=$(MACH64)
@@ -636,6 +645,7 @@
 $(BUILD64) $(ROOT)/usr/lib/link_audit/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/secure/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/lib/security/64:=	LINKDEST=$(MACH64)
+$(BUILD64) $(ROOT)/usr/lib/varpd/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/xpg4/lib/64:=	LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/var/ld/64:=		LINKDEST=$(MACH64)
 $(BUILD64) $(ROOT)/usr/ucblib/64:=	LINKDEST=$(MACH64)
usr/src/cmd/cmd-inet/etc/sock2path.d/system%2Fkernel
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/cmd-inet/etc/sock2path.d/system%2Fkernel	Tue Jul 21 14:14:22 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/cmd-inet/etc/sock2path.d/system%2Fkernel	Wed Jun 17 17:43:36 2015
@@ -18,6 +18,7 @@
 # CDDL HEADER END
 #
 # Copyright (c) 1995, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2014, Joyent, Inc. All rights reserved.
 #
 # socket configuration information
 #
@@ -52,3 +53,6 @@
 	29	4	1	/dev/spdsock
 
 	31	1	0	trill
+
+	33	1	0	lx_netlink
+	33	4	0	lx_netlink
usr/src/cmd/cmd-inet/lib/ipmgmtd/ipmgmt_door.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/cmd-inet/lib/ipmgmtd/ipmgmt_door.c	Tue Jul 21 14:14:22 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/cmd-inet/lib/ipmgmtd/ipmgmt_door.c	Wed Jun 17 17:43:36 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2014, Joyent, Inc. All rights reserved.
  */
 
 /*
@@ -112,7 +113,9 @@
 		goto fail;
 	}
 
-	/* check for solaris.network.interface.config authorization */
+	/*
+	 * if not root, check for solaris.network.interface.config authorization
+	 */
 	if (infop->idi_set) {
 		uid_t		uid;
 		struct passwd	pwd;
@@ -124,24 +127,32 @@
 			goto fail;
 		}
 		uid = ucred_getruid(cred);
+		ucred_free(cred);
 		if ((int)uid < 0) {
 			err = errno;
 			ipmgmt_log(LOG_ERR, "Could not get user id.");
 			goto fail;
 		}
-		if (getpwuid_r(uid, &pwd, buf, sizeof (buf)) ==
-		    NULL) {
-			err = errno;
-			ipmgmt_log(LOG_ERR, "Could not get password entry.");
-			goto fail;
+
+		/*
+		 * Branded zones may have different auth, but root always
+		 * allowed.
+		 */
+		if (uid != 0) {
+			if (getpwuid_r(uid, &pwd, buf, sizeof (buf)) == NULL) {
+				err = errno;
+				ipmgmt_log(LOG_ERR,
+				    "Could not get password entry.");
+				goto fail;
+			}
+			if (chkauthattr(NETWORK_INTERFACE_CONFIG_AUTH,
+			    pwd.pw_name) != 1) {
+				err = EPERM;
+				ipmgmt_log(LOG_ERR,
+				    "Not authorized for operation.");
+				goto fail;
+			}
 		}
-		if (chkauthattr(NETWORK_INTERFACE_CONFIG_AUTH,
-		    pwd.pw_name) != 1) {
-			err = EPERM;
-			ipmgmt_log(LOG_ERR, "Not authorized for operation.");
-			goto fail;
-		}
-		ucred_free(cred);
 	}
 
 	/* individual handlers take care of calling door_return */
usr/src/cmd/devfsadm/i386/Makefile
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/devfsadm/i386/Makefile	Tue Jul 21 14:14:22 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/devfsadm/i386/Makefile	Wed Jun 17 17:43:36 2015
@@ -24,8 +24,11 @@
 
 LINK_OBJS_i386 = \
 	misc_link_i386.o \
+	lx_link_i386.o \
 	xen_link.o
 
+lx_link_i386.o lx_link_i386.po lx_link_i386.ln := CPPFLAGS += -I$(UTSBASE)/common/brand/lx
+
 xen_link.o xen_link.ln xen_link.po := CPPFLAGS += -I$(UTSBASE)/i86xpv
 
 include ../Makefile.com
usr/src/cmd/devfsadm/i386/lx_link_i386.c
usr/src/cmd/devfsadm/misc_link.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/devfsadm/misc_link.c	Tue Nov 17 16:20:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/devfsadm/misc_link.c	Wed Jun 17 17:43:36 2015
@@ -32,6 +32,7 @@
 #include <limits.h>
 #include <sys/zone.h>
 #include <sys/zcons.h>
+#include <sys/zfd.h>
 #include <sys/cpuid_drv.h>
 
 static int display(di_minor_t minor, di_node_t node);
@@ -53,6 +54,7 @@
 static int tsalarm_create(di_minor_t minor, di_node_t node);
 static int ntwdt_create(di_minor_t minor, di_node_t node);
 static int zcons_create(di_minor_t minor, di_node_t node);
+static int zfd_create(di_minor_t minor, di_node_t node);
 static int cpuid(di_minor_t minor, di_node_t node);
 static int glvc(di_minor_t minor, di_node_t node);
 static int ses_callback(di_minor_t minor, di_node_t node);
@@ -114,6 +116,9 @@
 	    "(^nca$)|(^rds$)|(^sdp$)|(^ipnet$)|(^dlpistub$)|(^bpf$)",
 	    TYPE_EXACT | DRV_RE, ILEVEL_1, minor_name
 	},
+	{ "pseudo", "ddi_pseudo", "inotify",
+	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, minor_name
+	},
 	{ "pseudo", "ddi_pseudo", "ipd",
 	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, minor_name
 	},
@@ -180,6 +185,9 @@
 	{ "pseudo", "ddi_pseudo", "zcons",
 	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, zcons_create,
 	},
+	{ "pseudo", "ddi_pseudo", "zfd",
+	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, zfd_create,
+	},
 	{ "pseudo", "ddi_pseudo", CPUID_DRIVER_NAME,
 	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, cpuid,
 	},
@@ -204,6 +212,9 @@
 	{ "pseudo", "ddi_pseudo", "tpm",
 	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, minor_name
 	},
+	{ "pseudo", "ddi_pseudo", "overlay",
+	    TYPE_EXACT | DRV_EXACT, ILEVEL_0, minor_name
+	}
 };
 
 DEVFSADM_CREATE_INIT_V0(misc_cbt);
@@ -228,6 +239,9 @@
 		ZCONS_SLAVE_NAME ")$",
 	    RM_PRE | RM_HOT | RM_ALWAYS, ILEVEL_0, devfsadm_rm_all
 	},
+	{ "pseudo", "^zfd/" ZONENAME_REGEXP "/(master|slave)/[0-9]+$",
+	    RM_PRE | RM_HOT | RM_ALWAYS, ILEVEL_0, devfsadm_rm_all
+	},
 	{ "pseudo", "^" CPUID_SELF_NAME "$", RM_ALWAYS | RM_PRE | RM_HOT,
 	    ILEVEL_0, devfsadm_rm_all
 	},
@@ -672,6 +686,35 @@
 	    minor_str);
 	(void) devfsadm_mklink(path, node, minor, 0);
 
+	return (DEVFSADM_CONTINUE);
+}
+
+static int
+zfd_create(di_minor_t minor, di_node_t node)
+{
+	char	*minor_str;
+	char	*zonename;
+	int	*id;
+	char	path[MAXPATHLEN];
+
+	minor_str = di_minor_name(minor);
+
+	if (di_prop_lookup_strings(DDI_DEV_T_ANY, node, "zfd_zname",
+	    &zonename) == -1)
+		return (DEVFSADM_CONTINUE);
+
+	if (di_prop_lookup_ints(DDI_DEV_T_ANY, node, "zfd_id", &id) == -1)
+		return (DEVFSADM_CONTINUE);
+
+	if (strncmp(minor_str, "slave", 5) == 0) {
+		(void) snprintf(path, sizeof (path), "zfd/%s/slave/%d",
+		    zonename, id[0]);
+	} else {
+		(void) snprintf(path, sizeof (path), "zfd/%s/master/%d",
+		    zonename, id[0]);
+	}
+	(void) devfsadm_mklink(path, node, minor, 0);
+
 	return (DEVFSADM_CONTINUE);
 }
 
usr/src/cmd/mdb/common/modules/libc/libc.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/mdb/common/modules/libc/libc.c	Tue Jul 21 14:14:23 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/mdb/common/modules/libc/libc.c	Wed Jun 17 17:43:37 2015
@@ -137,6 +137,8 @@
 	    uc.uc_stack.ss_sp, uc.uc_stack.ss_size, stack_flags(&uc.uc_stack));
 	mdb_printf("  mcontext = 0x%p\n",
 	    addr + OFFSETOF(ucontext_t, uc_mcontext));
+	mdb_printf("  brand    = 0x%p 0x%p 0x%p\n",
+	    uc.uc_brand_data[0], uc.uc_brand_data[1], uc.uc_brand_data[2]);
 
 	return (DCMD_OK);
 }
@@ -841,15 +843,20 @@
 	    prt_addr(uberdata.all_lwps, 1),
 	    prt_addr(uberdata.all_zombies, 0));
 
-	HD("nthreads   nzombies   ndaemons   pid        sigacthandler");
-	mdb_printf(OFFSTR "%-10d %-10d %-10d %-10d %s\n",
+	HD("nthreads   nzombies   ndaemons   pid");
+	mdb_printf(OFFSTR "%-10d %-10d %-10d %-10d\n",
 	    OFFSET(nthreads),
 	    uberdata.nthreads,
 	    uberdata.nzombies,
 	    uberdata.ndaemons,
-	    (int)uberdata.pid,
-	    prt_addr((void *)uberdata.sigacthandler, 0));
+	    (int)uberdata.pid);
 
+	HD("sigacthandler         setctxt");
+	mdb_printf(OFFSTR "%s %s\n",
+	    OFFSET(sigacthandler),
+	    prt_addr((void *)uberdata.sigacthandler, 1),
+	    prt_addr((void *)uberdata.setctxt, 1));
+
 	HD("lwp_stacks            lwp_laststack         nfreestack stk_cache");
 	mdb_printf(OFFSTR "%s %s %-10d %d\n",
 	    OFFSET(lwp_stacks),
@@ -871,13 +878,18 @@
 	    prt_addr(uberdata.ulwp_replace_last, 1),
 	    prt_addr(uberdata.atforklist, 0));
 
-	HD("robustlocks           robustlist            progname");
-	mdb_printf(OFFSTR "%s %s %s\n",
+	HD("robustlocks           robustlist");
+	mdb_printf(OFFSTR "%s %s\n",
 	    OFFSET(robustlocks),
 	    prt_addr(uberdata.robustlocks, 1),
-	    prt_addr(uberdata.robustlist, 1),
-	    prt_addr(uberdata.progname, 0));
+	    prt_addr(uberdata.robustlist, 1));
 
+	HD("progname              ub_broot");
+	mdb_printf(OFFSTR "%s %s\n",
+	    OFFSET(progname),
+	    prt_addr(uberdata.progname, 1),
+	    prt_addr(uberdata.ub_broot, 1));
+
 	HD("tdb_bootstrap         tdb_sync_addr_hash    tdb_'count tdb_'fail");
 	mdb_printf(OFFSTR "%s %s %-10d %d\n",
 	    OFFSET(tdb_bootstrap),
usr/src/cmd/mdb/i86pc/modules/unix/unix.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/mdb/i86pc/modules/unix/unix.c	Tue Jul 21 14:14:23 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/mdb/i86pc/modules/unix/unix.c	Mon Dec 14 10:47:45 2015
@@ -918,6 +918,7 @@
 		{ "SMXE",	CR4_SMXE,	CR4_SMXE },
 		{ "OSXSAVE",	CR4_OSXSAVE,	CR4_OSXSAVE },
 		{ "SMEP",	CR4_SMEP,	CR4_SMEP },
+		{ "SMAP",	CR4_SMAP,	CR4_SMAP },
 		{ NULL,		0,		0 }
 	};
 
usr/src/cmd/pgrep/pgrep.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/pgrep/pgrep.c	Tue Jul 21 14:14:23 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/pgrep/pgrep.c	Wed Jun 17 17:43:37 2015
@@ -597,6 +597,8 @@
 	const char *optstr;
 	optdesc_t *optd;
 	int nmatches, c;
+	const char *zroot;
+	char buf[PATH_MAX];
 
 	DIR *dirp;
 
@@ -626,6 +628,12 @@
 
 	opterr = 0;
 
+	zroot = zone_get_nroot();
+	if (zroot != NULL) {
+		(void) snprintf(buf, sizeof (buf), "%s/%s", zroot, g_procdir);
+		g_procdir = buf;
+	}
+
 	while (optind < argc) {
 		while ((c = getopt(argc, argv, optstr)) != (int)EOF) {
 
usr/src/cmd/prstat/prstat.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/prstat/prstat.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/prstat/prstat.c	Wed Jun 17 17:43:38 2015
@@ -26,6 +26,7 @@
  * Use is subject to license terms.
  *
  * Portions Copyright 2009 Chad Mynhier
+ * Copyright 2012 Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/types.h>
@@ -181,6 +182,33 @@
 	-1			/* sort in decreasing order */
 };
 
+
+static int
+proc_snprintf(char *_RESTRICT_KYWD s, size_t n,
+    const char *_RESTRICT_KYWD fmt, ...)
+{
+	static boolean_t ptools_zroot_valid = B_FALSE;
+	static const char *ptools_zroot = NULL;
+	va_list args;
+	int ret, nret = 0;
+
+	if (ptools_zroot_valid == B_FALSE) {
+		ptools_zroot_valid = B_TRUE;
+		ptools_zroot = zone_get_nroot();
+	}
+
+	if (ptools_zroot != NULL) {
+		nret = snprintf(s, n, "%s", ptools_zroot);
+		if (nret > n)
+			return (nret);
+	}
+	va_start(args, fmt);
+	ret = vsnprintf(s + nret, n - nret, fmt, args);
+	va_end(args);
+
+	return (ret + nret);
+}
+
 /*
  * Print timestamp as decimal reprentation of time_t value (-d u was specified)
  * or the standard date format (-d d was specified).
@@ -236,8 +264,13 @@
 	size_t i;
 	uint_t flags = 0;
 	int ret;
-	size_t physmem = sysconf(_SC_PHYS_PAGES) * pagesize;
+	size_t physmem;
 
+	if (!(opts.o_outpmode & OPT_VMUSAGE))
+		return;
+
+	physmem = sysconf(_SC_PHYS_PAGES) * pagesize;
+
 	/*
 	 * Determine what swap/rss results to calculate.  getvmusage() will
 	 * prune results returned to non-global zones automatically, so
@@ -848,9 +881,9 @@
 static int
 read_procfile(fd_t **fd, char *pidstr, char *file, void *buf, size_t bufsize)
 {
-	char procfile[MAX_PROCFS_PATH];
+	char procfile[PATH_MAX];
 
-	(void) snprintf(procfile, MAX_PROCFS_PATH,
+	(void) proc_snprintf(procfile, PATH_MAX,
 	    "/proc/%s/%s", pidstr, file);
 	if ((*fd = fd_open(procfile, O_RDONLY, *fd)) == NULL)
 		return (1);
@@ -1376,6 +1409,7 @@
 	int timeout;
 	struct pollfd pollset;
 	char key;
+	char procpath[PATH_MAX];
 
 	(void) setlocale(LC_ALL, "");
 	(void) textdomain(TEXT_DOMAIN);
@@ -1386,7 +1420,7 @@
 	pagesize = sysconf(_SC_PAGESIZE);
 
 	while ((opt = getopt(argc, argv,
-	    "vcd:HmarRLtu:U:n:p:C:P:h:s:S:j:k:TJWz:Z")) != (int)EOF) {
+	    "vVcd:HmarRLtu:U:n:p:C:P:h:s:S:j:k:TJWz:Z")) != (int)EOF) {
 		switch (opt) {
 		case 'r':
 			opts.o_outpmode |= OPT_NORESOLVE;
@@ -1466,6 +1500,9 @@
 			while (p = strtok(NULL, ", "))
 				add_uid(&ruid_tbl, p);
 			break;
+		case 'V':
+			opts.o_outpmode |= OPT_VMUSAGE;
+			break;
 		case 'p':
 			fill_table(&pid_tbl, optarg, 'p');
 			break;
@@ -1575,7 +1612,8 @@
 	list_setkeyfunc(NULL, &opts, &lgroups, LT_LGRPS);
 	if (opts.o_outpmode & OPT_TERMCAP)
 		curses_on();
-	if ((procdir = opendir("/proc")) == NULL)
+	(void) proc_snprintf(procpath, sizeof (procpath), "/proc");
+	if ((procdir = opendir(procpath)) == NULL)
 		Die(gettext("cannot open /proc directory\n"));
 	if (opts.o_outpmode & OPT_TTY) {
 		(void) printf(gettext("Please wait...\r"));
usr/src/cmd/ptools/Makefile.bld
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/Makefile.bld	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/Makefile.bld	Wed Oct 14 16:03:01 2015
@@ -22,10 +22,13 @@
 #
 # Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
+# Copyright 2015 Joyent, Inc.
 #
 
 PROG:sh = basename `cd ..; pwd`
 
+include ../../../Makefile.ctf
+
 OBJS = $(PROG).o
 
 SRCS = ../$(PROG).c
@@ -69,6 +72,12 @@
 
 CERRWARN += $(CERRWARN_$(PROG))
 
+#
+# Common code definitions
+#
+COBJS =	ptools_common.o
+CINC = -I../../common
+
 # pargs depends on ../../common/elfcap components
 # pmadvise depends on pmap components
 
@@ -79,14 +88,34 @@
 OBJS_pargs =		elfcap.o
 SRCS_pargs =		$(ELFCAP)/elfcap.c
 
-CPPFLAGS_pmap =		-I$(PMAP)
-OBJS_pmap =		pmap_common.o
+CPPFLAGS_pmap =		-I$(PMAP) $(CINC)
+OBJS_pmap =		pmap_common.o $(COBJS)
 SRCS_pmap =		$(PMAP)/pmap_common.c
 
-CPPFLAGS_pmadvise =	-I$(PMAP)
-OBJS_pmadvise =		pmap_common.o
+CPPFLAGS_pmadvise =	-I$(PMAP) $(CINC)
+OBJS_pmadvise =		pmap_common.o $(COBJS)
 SRCS_pmadvise =		$(PMAP)/pmap_common.c
 
+CPPFLAGS_preap =	$(CINC)
+OBJS_preap =		$(COBJS)
+
+CPPFLAGS_psig =		$(CINC)
+OBJS_psig =		$(COBJS)
+
+CPPFLAGS_ptime =	$(CINC)
+OBJS_ptime =		$(COBJS)
+
+CPPFLAGS_ptree =	$(CINC)
+OBJS_ptree =		$(COBJS)
+
+CPPFLAGS_pwait =	$(CINC)
+OBJS_pwait =		$(COBJS)
+
+CPPFLAGS_pwdx =		$(CINC)
+OBJS_pwdx =		$(COBJS)
+
+LN_pargs =		penv pauxv
+
 CPPFLAGS +=	$(CPPFLAGS_$(PROG))
 OBJS +=		$(OBJS_$(PROG))
 SRCS +=		$(SRCS_$(PROG))
@@ -99,15 +128,23 @@
 
 elfcap.o:	$(ELFCAP)/elfcap.c
 		$(COMPILE.c) -o $@ $(ELFCAP)/elfcap.c
+		$(POST_PROCESS_O)
 
 pmap_common.o:	$(PMAP)/pmap_common.c
 		$(COMPILE.c) -o $@ $(PMAP)/pmap_common.c
+		$(POST_PROCESS_O)
 
 %.o:	../%.c
 	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
 
-all:	$(PROG)
+%.o:	../../common/%.c
+	$(COMPILE.c) $<
+	$(POST_PROCESS_O)
 
+all:	$(PROG) $(LN_$(PROG))
+
+ROOTBINLN=$(LN_$(PROG):%=$(ROOTBIN)/%)
 ROOTBINPROG=$(ROOTBIN)/$(PROG)
 ROOTPROCBINSYMLINK=$(ROOT)/usr/proc/bin/$(PROG)
 
@@ -119,11 +156,23 @@
 # Install the ptool, symlinking it into /usr/proc/bin if PTOOL_TYPE is set
 # to LEGACY.
 #
-install: all $(ROOTISAPROG)
+install: all $(ROOTISAPROG) $(ROOTISALN)
 	-$(RM) $(ROOTBINPROG)
 	-$(LN) $(ISAEXEC) $(ROOTBINPROG)
 	-$(INSTALL_$(PTOOL_TYPE))
 
+$(ROOTBINLN):
+	-$(RM) $@
+	-$(LN) $(ISAEXEC) $@
+
+$(ROOTISALN): $(ROOTISAPROG)
+	-$(RM) $@
+	-$(LN) $(ROOTISAPROG) $@
+
+$(LN_$(PROG)): $(PROG)
+	-$(RM) $@
+	-$(LN) $(PROG) $@
+
 clean:
 	$(RM) $(OBJS)
 
usr/src/cmd/ptools/common/ptools_common.c
usr/src/cmd/ptools/common/ptools_common.h
usr/src/cmd/ptools/pargs/pargs.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pargs/pargs.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pargs/pargs.c	Wed Oct 14 16:03:01 2015
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2013, Joyent, Inc.  All rights reserved.
+ * Copyright 2015, Joyent, Inc.  All rights reserved.
  */
 
 /*
@@ -73,7 +73,14 @@
 #include <wctype.h>
 #include <widec.h>
 #include <elfcap.h>
+#include <libgen.h>
 
+typedef enum pargs_cmd {
+	PARGS_ARGV,
+	PARGS_ENV,
+	PARGS_AUXV
+} pargs_cmd_t;
+
 typedef struct pargs_data {
 	struct ps_prochandle *pd_proc;	/* target proc handle */
 	psinfo_t *pd_psinfo;		/* target psinfo */
@@ -791,6 +798,7 @@
 	{ AT_BASE,		"AT_BASE",		at_null	},
 	{ AT_FLAGS,		"AT_FLAGS",		at_null	},
 	{ AT_ENTRY,		"AT_ENTRY",		at_null	},
+	{ AT_RANDOM,		"AT_RANDOM",		at_null	},
 	{ AT_SUN_UID,		"AT_SUN_UID",		at_uid	},
 	{ AT_SUN_RUID,		"AT_SUN_RUID",		at_uid	},
 	{ AT_SUN_GID,		"AT_SUN_GID",		at_gid	},
@@ -810,9 +818,11 @@
 	{ AT_SUN_AUXFLAGS,	"AT_SUN_AUXFLAGS",	at_flags },
 	{ AT_SUN_EMULATOR,	"AT_SUN_EMULATOR",	at_str	},
 	{ AT_SUN_BRANDNAME,	"AT_SUN_BRANDNAME",	at_str	},
+	{ AT_SUN_BRAND_NROOT,	"AT_SUN_BRAND_NROOT",	at_str	},
 	{ AT_SUN_BRAND_AUX1,	"AT_SUN_BRAND_AUX1",	at_null	},
 	{ AT_SUN_BRAND_AUX2,	"AT_SUN_BRAND_AUX2",	at_null	},
-	{ AT_SUN_BRAND_AUX3,	"AT_SUN_BRAND_AUX3",	at_null	}
+	{ AT_SUN_BRAND_AUX3,	"AT_SUN_BRAND_AUX3",	at_null	},
+	{ AT_SUN_BRAND_AUX4,	"AT_SUN_BRAND_AUX4",	at_null	}
 };
 
 #define	N_AT_ENTS (sizeof (aux_arr) / sizeof (struct aux_id))
@@ -1273,19 +1283,24 @@
 	int opt;
 	int error = 1;
 	core_content_t content = 0;
+	pargs_cmd_t cmd = PARGS_ARGV;
 
 	(void) setlocale(LC_ALL, "");
 
-	if ((command = strrchr(argv[0], '/')) != NULL)
-		command++;
-	else
-		command = argv[0];
+	command = basename(argv[0]);
 
+	if (strcmp(command, "penv") == 0)
+		cmd = PARGS_ENV;
+	else if (strcmp(command, "pauxv") == 0)
+		cmd = PARGS_AUXV;
+
 	while ((opt = getopt(argc, argv, "acelxF")) != EOF) {
 		switch (opt) {
 		case 'a':		/* show process arguments */
 			content |= CC_CONTENT_STACK;
 			aflag++;
+			if (cmd != PARGS_ARGV)
+				errflg++;
 			break;
 		case 'c':		/* force 7-bit ascii */
 			cflag++;
@@ -1293,13 +1308,19 @@
 		case 'e':		/* show environment variables */
 			content |= CC_CONTENT_STACK;
 			eflag++;
+			if (cmd != PARGS_ARGV)
+				errflg++;
 			break;
 		case 'l':
 			lflag++;
 			aflag++;	/* -l implies -a */
+			if (cmd != PARGS_ARGV)
+				errflg++;
 			break;
 		case 'x':		/* show aux vector entries */
 			xflag++;
+			if (cmd != PARGS_ARGV)
+				errflg++;
 			break;
 		case 'F':
 			/*
@@ -1316,8 +1337,19 @@
 
 	/* -a is the default if no options are specified */
 	if ((aflag + eflag + xflag + lflag) == 0) {
-		aflag++;
-		content |= CC_CONTENT_STACK;
+		switch (cmd) {
+		case PARGS_ARGV:
+			aflag++;
+			content |= CC_CONTENT_STACK;
+			break;
+		case PARGS_ENV:
+			content |= CC_CONTENT_STACK;
+			eflag++;
+			break;
+		case PARGS_AUXV:
+			xflag++;
+			break;
+		}
 	}
 
 	/* -l cannot be used with the -x or -e flags */
usr/src/cmd/ptools/pfiles/pfiles.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pfiles/pfiles.c	Thu Nov  5 11:10:04 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pfiles/pfiles.c	Mon Dec 14 10:47:45 2015
@@ -24,7 +24,7 @@
  * Copyright 2012 DEY Storage Systems, Inc.  All rights reserved.
  */
 /*
- * Copyright (c) 2013 Joyent, Inc.  All Rights reserved.
+ * Copyright (c) 2014 Joyent, Inc.  All Rights reserved.
  */
 
 #include <stdio.h>
@@ -557,6 +557,7 @@
 	case AF_IPX:		p = "AF_IPX";		break;
 	case AF_ROUTE:		p = "AF_ROUTE";		break;
 	case AF_LINK:		p = "AF_LINK";		break;
+	case AF_LX_NETLINK:	p = "AF_LX_NETLINK";	break;
 	}
 
 	(void) printf("\t%s: %s\n", str, p);
usr/src/cmd/ptools/pflags/pflags.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pflags/pflags.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pflags/pflags.c	Wed Jun 17 17:43:38 2015
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <stdio.h>
@@ -469,6 +469,9 @@
 	case PR_SUSPENDED:
 		str = "PR_SUSPENDED";
 		break;
+	case PR_BRAND:
+		str = "PR_BRAND";
+		break;
 	default:
 		str = buf;
 		(void) sprintf(str, "%d", why);
usr/src/cmd/ptools/pmap/pmap.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pmap/pmap.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pmap/pmap.c	Wed Jun 17 17:43:38 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
  */
 
 #include <stdio.h>
@@ -42,6 +43,7 @@
 #include <sys/mman.h>
 #include <sys/lgrp_user.h>
 #include <libproc.h>
+#include "ptools_common.h"
 
 #include "pmap_common.h"
 
@@ -199,7 +201,7 @@
 	const char *bar;
 	struct rlimit rlim;
 	struct stat64 statbuf;
-	char buf[128];
+	char buf[PATH_MAX];
 	int mapfd;
 	int prg_gflags = PGRAB_RDONLY;
 	int prr_flags = 0;
@@ -358,7 +360,7 @@
 		proc_unctrl_psinfo(&psinfo);
 
 		if (Pstate(Pr) != PS_DEAD) {
-			(void) snprintf(buf, sizeof (buf),
+			(void) proc_snprintf(buf, sizeof (buf),
 			    "/proc/%d/map", (int)psinfo.pr_pid);
 			if ((mapfd = open(buf, O_RDONLY)) < 0) {
 				(void) fprintf(stderr, "%s: cannot "
@@ -590,7 +592,7 @@
 	prmap_t *prmapp, *pmp;
 	ssize_t n;
 
-	(void) snprintf(mapname, sizeof (mapname),
+	(void) proc_snprintf(mapname, sizeof (mapname),
 	    "/proc/%d/rmap", (int)Pstatus(Pr)->pr_pid);
 
 	if ((mapfd = open(mapname, O_RDONLY)) < 0 || fstat(mapfd, &st) != 0) {
@@ -631,7 +633,7 @@
 	prxmap_t *prmapp, *pmp;
 	ssize_t n;
 
-	(void) snprintf(mapname, sizeof (mapname),
+	(void) proc_snprintf(mapname, sizeof (mapname),
 	    "/proc/%d/xmap", (int)Pstatus(Pr)->pr_pid);
 
 	if ((mapfd = open(mapname, O_RDONLY)) < 0 || fstat(mapfd, &st) != 0) {
usr/src/cmd/ptools/pmap/pmap_common.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pmap/pmap_common.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pmap/pmap_common.c	Wed Jun 17 17:43:38 2015
@@ -37,6 +37,7 @@
 #include <sys/types.h>
 
 #include "pmap_common.h"
+#include "ptools_common.h"
 
 /*
  * We compare the high memory addresses since stacks are faulted in from
@@ -88,7 +89,7 @@
 		return (NULL);
 
 	/* first see if we can find a path via /proc */
-	(void) snprintf(path, sizeof (path), "/proc/%d/path/%s",
+	(void) proc_snprintf(path, sizeof (path), "/proc/%d/path/%s",
 	    (int)Psp->pr_pid, mapname);
 	len = readlink(path, buf, bufsz - 1);
 	if (len >= 0) {
@@ -97,7 +98,7 @@
 	}
 
 	/* fall back to object information reported by /proc */
-	(void) snprintf(path, sizeof (path),
+	(void) proc_snprintf(path, sizeof (path),
 	    "/proc/%d/object/%s", (int)Psp->pr_pid, mapname);
 	if (stat(path, &statb) == 0) {
 		dev_t dev = statb.st_dev;
usr/src/cmd/ptools/preap/preap.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/preap/preap.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/preap/preap.c	Wed Jun 17 17:43:38 2015
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -37,6 +35,8 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <libproc.h>
+#include <limits.h>
+#include "ptools_common.h"
 
 #define	NOREAP_TIME 60		/* wait 60 seconds before allow a reap */
 
@@ -53,11 +53,11 @@
 static int
 open_usage(pid_t pid, int *perr)
 {
-	char path[64];
+	char path[PATH_MAX];
 	struct stat64 st;
 	int fd;
 
-	(void) snprintf(path, sizeof (path), "/proc/%d/usage", (int)pid);
+	(void) proc_snprintf(path, sizeof (path), "/proc/%d/usage", (int)pid);
 
 	/*
 	 * Attempt to open the usage file, and return the fd if we can
usr/src/cmd/ptools/psig/psig.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/psig/psig.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/psig/psig.c	Wed Jun 17 17:43:38 2015
@@ -21,10 +21,9 @@
 /*
  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <stdio_ext.h>
 #include <stdlib.h>
@@ -37,6 +36,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <libproc.h>
+#include "ptools_common.h"
 
 /* evil knowledge of libc internals */
 #include "../../../lib/libc/inc/thr_uberdata.h"
@@ -172,7 +172,7 @@
 static int
 look(char *arg)
 {
-	char pathname[100];
+	char pathname[PATH_MAX];
 	struct stat statb;
 	int fd = -1;
 	int sig, gcode;
@@ -199,7 +199,8 @@
 	(void) memcpy(&psinfo, psinfop, sizeof (psinfo_t));
 	proc_unctrl_psinfo(&psinfo);
 
-	(void) sprintf(pathname, "/proc/%d/sigact", (int)psinfo.pr_pid);
+	(void) proc_snprintf(pathname, sizeof (pathname), "/proc/%d/sigact",
+	    (int)psinfo.pr_pid);
 	if ((fd = open(pathname, O_RDONLY)) < 0) {
 		perr("open sigact");
 		goto look_error;
@@ -213,8 +214,8 @@
 	action = malloc(maxsig * sizeof (struct sigaction));
 	if (action == NULL) {
 		(void) fprintf(stderr,
-		"%s: cannot malloc() space for %d sigaction structures\n",
-			command, maxsig);
+		    "%s: cannot malloc() space for %d sigaction structures\n",
+		    command, maxsig);
 		goto look_error;
 	}
 	if (read(fd, (char *)action, maxsig * sizeof (struct sigaction)) !=
@@ -239,7 +240,7 @@
 		if (psinfo.pr_dmodel != PR_MODEL_NATIVE) {
 			caddr32_t addr;
 			aharraddr = uberaddr +
-				offsetof(uberdata32_t, siguaction);
+			    offsetof(uberdata32_t, siguaction);
 			aharrlen = sizeof (siguaction32_t) * NSIG;
 			(void) Pread(Pr, &addr, sizeof (addr),
 			    uberaddr + offsetof(uberdata32_t, sigacthandler));
@@ -248,7 +249,7 @@
 #endif
 		{
 			aharraddr = uberaddr +
-				offsetof(uberdata_t, siguaction);
+			    offsetof(uberdata_t, siguaction);
 			aharrlen = sizeof (siguaction_t) * NSIG;
 			(void) Pread(Pr, &intfnaddr, sizeof (intfnaddr),
 			    uberaddr + offsetof(uberdata_t, sigacthandler));
@@ -323,7 +324,7 @@
 					(void) printf("\t%-8s", hname);
 				else
 					(void) printf("\t0x%-8lx",
-						(ulong_t)haddr);
+					    (ulong_t)haddr);
 
 				s = sigflags(sig, sp->sa_flags);
 				(void) printf("%s", (*s != '\0')? s : "\t0");
@@ -334,7 +335,7 @@
 			}
 		} else if (sig == SIGCLD) {
 			s = sigflags(sig,
-				sp->sa_flags & (SA_NOCLDWAIT|SA_NOCLDSTOP));
+			    sp->sa_flags & (SA_NOCLDWAIT|SA_NOCLDSTOP));
 			if (*s != '\0')
 				(void) printf("\t\t%s", s);
 		}
@@ -371,7 +372,7 @@
 	static char code_buf[100];
 	char *str = code_buf;
 	int flagmask =
-		(SA_ONSTACK|SA_RESETHAND|SA_RESTART|SA_SIGINFO|SA_NODEFER);
+	    (SA_ONSTACK|SA_RESETHAND|SA_RESTART|SA_SIGINFO|SA_NODEFER);
 
 	if (sig == SIGCLD)
 		flagmask |= (SA_NOCLDSTOP|SA_NOCLDWAIT);
@@ -414,19 +415,19 @@
 #ifdef _LP64
 	if (psinfo->pr_dmodel != PR_MODEL_NATIVE) {
 		struct sigaction32 *sa32 = (struct sigaction32 *)
-			((uintptr_t)aharr + sig * sizeof (siguaction32_t) +
-			offsetof(siguaction32_t, sig_uaction));
+		    ((uintptr_t)aharr + sig * sizeof (siguaction32_t) +
+		    offsetof(siguaction32_t, sig_uaction));
 
 		sp->sa_flags = sa32->sa_flags;
 		sp->sa_handler = (void (*)())(uintptr_t)sa32->sa_handler;
 		(void) memcpy(&sp->sa_mask, &sa32->sa_mask,
-			sizeof (sp->sa_mask));
+		    sizeof (sp->sa_mask));
 	} else
 #endif
 	{
 		struct sigaction *sa = (struct sigaction *)
-			((uintptr_t)aharr + sig * sizeof (siguaction_t) +
-			offsetof(siguaction_t, sig_uaction));
+		    ((uintptr_t)aharr + sig * sizeof (siguaction_t) +
+		    offsetof(siguaction_t, sig_uaction));
 
 		sp->sa_flags = sa->sa_flags;
 		sp->sa_handler = sa->sa_handler;
usr/src/cmd/ptools/ptime/ptime.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/ptime/ptime.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/ptime/ptime.c	Wed Jun 17 17:43:38 2015
@@ -24,6 +24,9 @@
  *
  * Portions Copyright 2008 Chad Mynhier
  */
+/*
+ * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -38,6 +41,8 @@
 #include <sys/time.h>
 #include <signal.h>
 #include <libproc.h>
+#include <limits.h>
+#include "ptools_common.h"
 
 static	int	look(pid_t);
 static	void	hr_min_sec(char *, long);
@@ -55,16 +60,39 @@
 static	int	Fflag;
 static	int	mflag;
 static	int	errflg;
+static	int	pflag;
 
+static int
+ptime_pid(const char *pidstr)
+{
+	struct ps_prochandle *Pr;
+	pid_t pid;
+	int gret;
+
+	if ((Pr = proc_arg_grab(pidstr, PR_ARG_PIDS,
+	    Fflag | PGRAB_RDONLY, &gret)) == NULL) {
+		(void) fprintf(stderr, "%s: cannot examine %s: %s\n",
+		    command, pidstr, Pgrab_error(gret));
+		return (1);
+	}
+
+	pid = Pstatus(Pr)->pr_pid;
+	(void) sprintf(procname, "%d", (int)pid);	/* for perr() */
+	(void) look(pid);
+	Prelease(Pr, 0);
+	return (0);
+}
+
 int
 main(int argc, char **argv)
 {
-	int opt;
+	int opt, exit;
 	pid_t pid;
 	struct siginfo info;
 	int status;
 	int gret;
 	struct ps_prochandle *Pr;
+	char *pp, *np;
 
 	if ((command = strrchr(argv[0], '/')) != NULL)
 		command++;
@@ -80,6 +108,7 @@
 			mflag = 1;
 			break;
 		case 'p':
+			pflag = 1;
 			pidarg = optarg;
 			break;
 		default:
@@ -93,7 +122,7 @@
 
 	if (((pidarg != NULL) ^ (argc < 1)) || errflg) {
 		(void) fprintf(stderr,
-		    "usage:\t%s [-mh] [-p pid | command [ args ... ]]\n",
+		    "usage:\t%s [-mh] [-p pidlist | command [ args ... ]]\n",
 		    command);
 		(void) fprintf(stderr,
 		    "  (time a command using microstate accounting)\n");
@@ -100,62 +129,69 @@
 		return (1);
 	}
 
-	if (pidarg != NULL) {
-		if ((Pr = proc_arg_grab(pidarg, PR_ARG_PIDS,
-		    Fflag | PGRAB_RDONLY, &gret)) == NULL) {
-			(void) fprintf(stderr, "%s: cannot examine %s: %s\n",
-			    command, pidarg, Pgrab_error(gret));
-			return (1);
+	if (pflag) {
+		exit = 0;
+		(void) signal(SIGINT, SIG_IGN);
+		(void) signal(SIGQUIT, SIG_IGN);
+		pp = pidarg;
+		if ((np = strchr(pp, ' ')) != NULL ||
+		    (np = strchr(pp, ',')) != NULL)
+			pflag++;
+		while (np != NULL) {
+			*np = '\0';
+			exit |= ptime_pid(pp);
+			pp = np + 1;
+			np = strchr(pp, ' ');
+			if (np == NULL)
+				np = strchr(pp, ',');
 		}
-	} else {
-		if ((Pr = Pcreate(argv[0], &argv[0], &gret, NULL, 0)) == NULL) {
-			(void) fprintf(stderr, "%s: failed to exec %s: %s\n",
-			    command, argv[0], Pcreate_error(gret));
-			return (1);
-		}
-		if (Psetrun(Pr, 0, 0) == -1) {
-			(void) fprintf(stderr, "%s: failed to set running %s: "
-			    "%s\n", command, argv[0], strerror(errno));
-			return (1);
-		}
+		exit |= ptime_pid(pp);
+		return (exit);
 	}
 
+
+	if ((Pr = Pcreate(argv[0], &argv[0], &gret, NULL, 0)) == NULL) {
+		(void) fprintf(stderr, "%s: failed to exec %s: %s\n",
+		    command, argv[0], Pcreate_error(gret));
+		return (1);
+	}
+	if (Psetrun(Pr, 0, 0) == -1) {
+		(void) fprintf(stderr, "%s: failed to set running %s: "
+		    "%s\n", command, argv[0], strerror(errno));
+		return (1);
+	}
+
 	pid = Pstatus(Pr)->pr_pid;
+
 	(void) sprintf(procname, "%d", (int)pid);	/* for perr() */
 	(void) signal(SIGINT, SIG_IGN);
 	(void) signal(SIGQUIT, SIG_IGN);
 
-	if (pidarg == NULL)
-		(void) waitid(P_PID, pid, &info, WEXITED | WNOWAIT);
+	(void) waitid(P_PID, pid, &info, WEXITED | WNOWAIT);
 
 	(void) look(pid);
 
-	if (pidarg != NULL) {
-		Prelease(Pr, 0);
-		return (0);
-	} else {
-		(void) waitpid(pid, &status, 0);
+	(void) waitpid(pid, &status, 0);
 
-		if (WIFEXITED(status))
-			return (WEXITSTATUS(status));
+	if (WIFEXITED(status))
+		return (WEXITSTATUS(status));
 
-		if (WIFSIGNALED(status)) {
-			int sig = WTERMSIG(status);
-			char name[SIG2STR_MAX];
+	if (WIFSIGNALED(status)) {
+		int sig = WTERMSIG(status);
+		char name[SIG2STR_MAX];
 
-			(void) fprintf(stderr, "%s: command terminated "
-			    "abnormally by %s\n", command,
-			    proc_signame(sig, name, sizeof (name)));
-		}
-
-		return (status | WCOREFLG); /* see time(1) */
+		(void) fprintf(stderr, "%s: command terminated "
+		    "abnormally by %s\n", command,
+		    proc_signame(sig, name, sizeof (name)));
 	}
+
+	return (status | WCOREFLG); /* see time(1) */
 }
 
 static int
 look(pid_t pid)
 {
-	char pathname[100];
+	char pathname[PATH_MAX];
 	int rval = 0;
 	int fd;
 	psinfo_t psinfo;
@@ -167,7 +203,8 @@
 	if (proc_get_psinfo(pid, &psinfo) < 0)
 		return (perr("read psinfo"));
 
-	(void) sprintf(pathname, "/proc/%d/usage", (int)pid);
+	(void) proc_snprintf(pathname, sizeof (pathname), "/proc/%d/usage",
+	    (int)pid);
 	if ((fd = open(pathname, O_RDONLY)) < 0)
 		return (perr("open usage"));
 
@@ -187,6 +224,9 @@
 			tsadd(&sys, &sys, &pup->pr_ttime);
 
 		(void) fprintf(stderr, "\n");
+		if (pflag > 1)
+			(void) fprintf(stderr, "%d:\t%.70s\n",
+			    (int)psinfo.pr_pid, psinfo.pr_psargs);
 		prtime("real", &real);
 		prtime("user", &user);
 		prtime("sys", &sys);
usr/src/cmd/ptools/ptree/ptree.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/ptree/ptree.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/ptree/ptree.c	Wed Jun 17 17:43:38 2015
@@ -21,6 +21,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
  */
 
 /*
@@ -27,8 +28,6 @@
  * ptree -- print family tree of processes
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <assert.h>
 #include <stdio.h>
 #include <string.h>
@@ -48,6 +47,7 @@
 #include <sys/ctfs.h>
 #include <libcontract_priv.h>
 #include <sys/stat.h>
+#include "ptools_common.h"
 
 #define	FAKEDPID0(p)	(p->pid == 0 && p->psargs[0] == '\0')
 
@@ -103,10 +103,11 @@
 	char *s;
 	int n;
 	int retc = 0;
+	char ppath[PATH_MAX];
 
 	DIR *dirp;
 	struct dirent *dentp;
-	char	pname[100];
+	char	pname[PATH_MAX];
 	int	pdlen;
 
 	ps_t *p;
@@ -169,16 +170,18 @@
 	psize = 0;
 	ps = NULL;
 
+	(void) proc_snprintf(ppath, sizeof (ppath), "/proc");
+
 	/*
 	 * Search the /proc directory for all processes.
 	 */
-	if ((dirp = opendir("/proc")) == NULL) {
-		(void) fprintf(stderr, "%s: cannot open /proc directory\n",
-		    command);
+	if ((dirp = opendir(ppath)) == NULL) {
+		(void) fprintf(stderr, "%s: cannot open %s directory\n",
+		    command, ppath);
 		return (1);
 	}
 
-	(void) strcpy(pname, "/proc");
+	(void) strcpy(pname, ppath);
 	pdlen = strlen(pname);
 	pname[pdlen++] = '/';
 
usr/src/cmd/ptools/pwait/pwait.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pwait/pwait.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pwait/pwait.c	Wed Jun 17 17:43:38 2015
@@ -23,8 +23,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <stdio_ext.h>
 #include <ctype.h>
@@ -39,6 +37,8 @@
 #include <poll.h>
 #include <procfs.h>
 #include <sys/resource.h>
+#include <limits.h>
+#include "ptools_common.h"
 
 static int count_my_files();
 static char *command;
@@ -49,6 +49,7 @@
 int
 main(int argc, char **argv)
 {
+	char buf[PATH_MAX];
 	unsigned long remain = 0;
 	struct pollfd *pollfd;
 	struct pollfd *pfd;
@@ -75,10 +76,12 @@
 		(void) fprintf(stderr, "usage:\t%s [-v] pid ...\n", command);
 		(void) fprintf(stderr, "  (wait for processes to terminate)\n");
 		(void) fprintf(stderr,
-			"  -v: verbose; report terminations to standard out\n");
+		    "  -v: verbose; report terminations to standard out\n");
 		return (2);
 	}
 
+	(void) proc_snprintf(buf, sizeof (buf), "/proc/");
+
 	/* make sure we have enough file descriptors */
 	if (getrlimit(RLIMIT_NOFILE, &rlim) == 0) {
 		int nfiles = count_my_files();
@@ -87,8 +90,8 @@
 			rlim.rlim_cur = argc + nfiles + SLOP;
 			if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
 				(void) fprintf(stderr,
-					"%s: insufficient file descriptors\n",
-					command);
+				    "%s: insufficient file descriptors\n",
+				    command);
 				return (2);
 			}
 		}
@@ -108,11 +111,11 @@
 		if (strchr(arg, '/') != NULL)
 			(void) strncpy(psinfofile, arg, sizeof (psinfofile));
 		else {
-			(void) strcpy(psinfofile, "/proc/");
+			(void) strcpy(psinfofile, buf);
 			(void) strncat(psinfofile, arg, sizeof (psinfofile)-6);
 		}
 		(void) strncat(psinfofile, "/psinfo",
-			sizeof (psinfofile)-strlen(psinfofile));
+		    sizeof (psinfofile)-strlen(psinfofile));
 
 		pfd = &pollfd[i];
 		if ((pfd->fd = open(psinfofile, O_RDONLY)) >= 0) {
@@ -126,7 +129,7 @@
 			pfd->revents = 0;
 		} else if (errno == ENOENT) {
 			(void) fprintf(stderr, "%s: no such process: %s\n",
-				command, arg);
+			    command, arg);
 		} else {
 			perror(arg);
 		}
@@ -160,9 +163,9 @@
 					if (pread(pfd->fd, &psinfo,
 					    sizeof (psinfo), (off_t)0)
 					    == sizeof (psinfo)) {
-						(void) printf(
-					"%s: terminated, wait status 0x%.4x\n",
-							arg, psinfo.pr_wstat);
+						(void) printf("%s: terminated, "
+						    "wait status 0x%.4x\n",
+						    arg, psinfo.pr_wstat);
 					} else {
 						(void) printf(
 						    "%s: terminated\n", arg);
@@ -170,10 +173,10 @@
 				}
 				if (pfd->revents & POLLNVAL)
 					(void) printf("%s: system process\n",
-						arg);
+					    arg);
 				if (pfd->revents & ~(POLLPRI|POLLHUP|POLLNVAL))
 					(void) printf("%s: unknown error\n",
-						arg);
+					    arg);
 			}
 
 			(void) close(pfd->fd);
usr/src/cmd/ptools/pwdx/pwdx.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/ptools/pwdx/pwdx.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/ptools/pwdx/pwdx.c	Wed Jun 17 17:43:38 2015
@@ -22,10 +22,9 @@
 /*
  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdio.h>
 #include <unistd.h>
 #include <string.h>
@@ -33,6 +32,8 @@
 #include <libproc.h>
 #include <sys/param.h>
 
+#include "ptools_common.h"
+
 static char *command;
 
 static int
@@ -49,7 +50,7 @@
 		return (1);
 	}
 
-	(void) snprintf(proc, sizeof (proc), "/proc/%d/path/cwd",
+	(void) proc_snprintf(proc, sizeof (proc), "/proc/%d/path/cwd",
 	    (int)p.pr_pid);
 
 	if ((ret = readlink(proc, cwd, sizeof (cwd) - 1)) <= 0) {
usr/src/cmd/sgs/libconv/common/corenote.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/sgs/libconv/common/corenote.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/sgs/libconv/common/corenote.c	Wed Jun 17 17:43:38 2015
@@ -25,7 +25,7 @@
  */
 /*
  * Copyright 2012 DEY Storage Systems, Inc.  All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
  */
 
 /*
@@ -76,7 +76,7 @@
 conv_cnote_auxv_type(Word type, Conv_fmt_flags_t fmt_flags,
     Conv_inv_buf_t *inv_buf)
 {
-	static const Msg	types_0_22[] = {
+	static const Msg	types_0_25[] = {
 		MSG_AUXV_AT_NULL,		MSG_AUXV_AT_IGNORE,
 		MSG_AUXV_AT_EXECFD,		MSG_AUXV_AT_PHDR,
 		MSG_AUXV_AT_PHENT,		MSG_AUXV_AT_PHNUM,
@@ -88,10 +88,11 @@
 		MSG_AUXV_AT_HWCAP,		MSG_AUXV_AT_CLKTCK,
 		MSG_AUXV_AT_FPUCW,		MSG_AUXV_AT_DCACHEBSIZE,
 		MSG_AUXV_AT_ICACHEBSIZE,	MSG_AUXV_AT_UCACHEBSIZE,
-		MSG_AUXV_AT_IGNOREPPC
+		MSG_AUXV_AT_IGNOREPPC,		MSG_AUXV_AT_SECURE,
+		MSG_AUXV_AT_BASE_PLATFORM,	MSG_AUXV_AT_RANDOM
 	};
-	static const conv_ds_msg_t ds_types_0_22 = {
-	    CONV_DS_MSG_INIT(0, types_0_22) };
+	static const conv_ds_msg_t ds_types_0_25 = {
+	    CONV_DS_MSG_INIT(0, types_0_25) };
 
 	static const Msg	types_2000_2011[] = {
 		MSG_AUXV_AT_SUN_UID,		MSG_AUXV_AT_SUN_RUID,
@@ -104,19 +105,20 @@
 	static const conv_ds_msg_t ds_types_2000_2011 = {
 	    CONV_DS_MSG_INIT(2000, types_2000_2011) };
 
-	static const Msg	types_2014_2023[] = {
+	static const Msg	types_2014_2024[] = {
 		MSG_AUXV_AT_SUN_EXECNAME,	MSG_AUXV_AT_SUN_MMU,
 		MSG_AUXV_AT_SUN_LDDATA,		MSG_AUXV_AT_SUN_AUXFLAGS,
 		MSG_AUXV_AT_SUN_EMULATOR,	MSG_AUXV_AT_SUN_BRANDNAME,
 		MSG_AUXV_AT_SUN_BRAND_AUX1,	MSG_AUXV_AT_SUN_BRAND_AUX2,
-		MSG_AUXV_AT_SUN_BRAND_AUX3,	MSG_AUXV_AT_SUN_HWCAP2
+		MSG_AUXV_AT_SUN_BRAND_AUX3,	MSG_AUXV_AT_SUN_HWCAP2,
+		MSG_AUXV_AT_SUN_BRAND_NROOT
 	};
-	static const conv_ds_msg_t ds_types_2014_2023 = {
-	    CONV_DS_MSG_INIT(2014, types_2014_2023) };
+	static const conv_ds_msg_t ds_types_2014_2024 = {
+	    CONV_DS_MSG_INIT(2014, types_2014_2024) };
 
 	static const conv_ds_t	*ds[] = {
-		CONV_DS_ADDR(ds_types_0_22), CONV_DS_ADDR(ds_types_2000_2011),
-		CONV_DS_ADDR(ds_types_2014_2023), NULL };
+		CONV_DS_ADDR(ds_types_0_25), CONV_DS_ADDR(ds_types_2000_2011),
+		CONV_DS_ADDR(ds_types_2014_2024), NULL };
 
 	return (conv_map_ds(ELFOSABI_NONE, EM_NONE, type, ds, fmt_flags,
 	    inv_buf));
usr/src/cmd/sgs/libconv/common/corenote.msg
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/sgs/libconv/common/corenote.msg	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/sgs/libconv/common/corenote.msg	Mon Dec 28 16:27:39 2015
@@ -24,7 +24,7 @@
 # Use is subject to license terms.
 #
 # Copyright 2012 DEY Storage Systems, Inc.  All rights reserved.
-# Copyright (c) 2013, Joyent, Inc. All rights reserved.
+# Copyright (c) 2014, Joyent, Inc. All rights reserved.
 #
 
 @ MSG_NT_PRSTATUS		"[ NT_PRSTATUS ]"
@@ -78,6 +78,9 @@
 @ MSG_AUXV_AT_ICACHEBSIZE		"ICACHEBSIZE"
 @ MSG_AUXV_AT_UCACHEBSIZE		"UCACHEBSIZE"
 @ MSG_AUXV_AT_IGNOREPPC			"IGNOREPPC"
+@ MSG_AUXV_AT_SECURE			"SECURE"
+@ MSG_AUXV_AT_BASE_PLATFORM		"BASE_PLATFORM"
+@ MSG_AUXV_AT_RANDOM			"RANDOM"
 @ MSG_AUXV_AT_SUN_UID			"SUN_UID"
 @ MSG_AUXV_AT_SUN_RUID			"SUN_RUID"
 @ MSG_AUXV_AT_SUN_GID			"SUN_GID"
@@ -100,6 +103,7 @@
 @ MSG_AUXV_AT_SUN_BRAND_AUX2		"SUN_BRAND_AUX2"
 @ MSG_AUXV_AT_SUN_BRAND_AUX3		"SUN_BRAND_AUX3"
 @ MSG_AUXV_AT_SUN_HWCAP2		"SUN_HWCAP2"
+@ MSG_AUXV_AT_SUN_BRAND_NROOT		"SUN_BRAND_NROOT"
 
 
 @ MSG_CC_CONTENT_STACK		"STACK"
@@ -415,7 +419,7 @@
 @ MSG_SS_DISABLE		"SS_DISABLE"
 
 
-@ MSG_SI_NOINFO			"[ SI_DTRACE ]"
+@ MSG_SI_NOINFO			"[ SI_NOINFO ]"
 @ MSG_SI_DTRACE			"[ SI_DTRACE ]"
 @ MSG_SI_RCTL			"[ SI_RCTL ]"
 @ MSG_SI_USER			"[ SI_USER ]"
usr/src/cmd/truss/print.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/truss/print.c	Wed Sep 16 08:01:39 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/truss/print.c	Wed Oct 14 16:03:01 2015
@@ -845,6 +845,7 @@
 		case MADV_ACCESS_DEFAULT: s = "MADV_ACCESS_DEFAULT";	break;
 		case MADV_ACCESS_LWP:	s = "MADV_ACCESS_LWP";	break;
 		case MADV_ACCESS_MANY:	s = "MADV_ACCESS_MANY";	break;
+		case MADV_PURGE:	s = "MADV_PURGE";	break;
 		}
 	}
 
@@ -872,7 +873,9 @@
 			return;
 
 		case MC_SYNC:
-			if ((val & ~(MS_SYNC|MS_ASYNC|MS_INVALIDATE)) == 0) {
+			if ((val &
+			    ~(MS_SYNC|MS_ASYNC|MS_INVALIDATE|MS_INVALCURPROC))
+			    == 0) {
 				*(s = pri->code_buf) = '\0';
 				if (val & MS_SYNC)
 					(void) strlcat(s, "|MS_SYNC", CBSIZE);
@@ -881,6 +884,9 @@
 				if (val & MS_INVALIDATE)
 					(void) strlcat(s, "|MS_INVALIDATE",
 					    CBSIZE);
+				if (val & MS_INVALCURPROC)
+					(void) strlcat(s, "|MS_INVALCURPROC",
+					    CBSIZE);
 			}
 			break;
 
@@ -1997,6 +2003,8 @@
 	case UDP_EXCLBIND:		return ("UDP_EXCLBIND");
 	case UDP_RCVHDR:		return ("UDP_RCVHDR");
 	case UDP_NAT_T_ENDPOINT:	return ("UDP_NAT_T_ENDPOINT");
+	case UDP_SRCPORT_HASH:		return ("UDP_SRCPORT_HASH");
+	case UDP_SND_TO_CONNECTED:	return ("UDP_SND_TO_CONNECTED");
 
 	default:			(void) snprintf(pri->code_buf,
 					    sizeof (pri->code_buf), "0x%lx",
@@ -2445,7 +2453,10 @@
 		case ZONE_ATTR_BOOTARGS:	s = "ZONE_ATTR_BOOTARGS"; break;
 		case ZONE_ATTR_BRAND:	s = "ZONE_ATTR_BRAND"; break;
 		case ZONE_ATTR_FLAGS:	s = "ZONE_ATTR_FLAGS"; break;
-		case ZONE_ATTR_PHYS_MCAP: s = "ZONE_ATTR_PHYS_MCAP"; break;
+		case ZONE_ATTR_DID:	s = "ZONE_ATTR_DID"; break;
+		case ZONE_ATTR_PMCAP_NOVER: s = "ZONE_ATTR_PMCAP_NOVER"; break;
+		case ZONE_ATTR_PMCAP_PAGEOUT: s = "ZONE_ATTR_PMCAP_PAGEOUT";
+					break;
 		}
 	}
 
usr/src/cmd/truss/systable.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/truss/systable.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/truss/systable.c	Wed Jun 17 17:43:38 2015
@@ -29,6 +29,9 @@
 
 /* Copyright (c) 2013, OmniTI Computer Consulting, Inc. All rights reserved. */
 
+/*
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ */
 #include <stdio.h>
 #include <stdlib.h>
 #include <fcntl.h>
@@ -1716,9 +1719,10 @@
 	"POLICY",	/* 29 */
 	"RDS",		/* 30 */
 	"TRILL",	/* 31 */
-	"PACKET"	/* 32 */
+	"PACKET",	/* 32 */
+	"LX_NETLINK"	/* 33 */
 };
-#if MAX_AFCODES != 33
+#if MAX_AFCODES != 34
 #error Need to update address-family table
 #endif
 
usr/src/cmd/zlogin/zlogin.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/zlogin/zlogin.c	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/zlogin/zlogin.c	Mon Dec 14 10:47:45 2015
@@ -22,11 +22,12 @@
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2013 DEY Storage Systems, Inc.
  * Copyright (c) 2014 Gary Mills
+ * Copyright 2015 Joyent, Inc. All rights reserved.
  * Copyright 2015 Nexenta Systems, Inc. All rights reserved.
  */
 
 /*
- * zlogin provides three types of login which allow users in the global
+ * zlogin provides five types of login which allow users in the global
  * zone to access non-global zones.
  *
  * - "interactive login" is similar to rlogin(1); for example, the user could
@@ -42,6 +43,13 @@
  *   In this mode, zlogin sets up pipes as the communication channel, and
  *   'su' is used to do the login setup work.
  *
+ * - "interactive command" is a combination of the above two modes where
+ *   a command is provide like the non-interactive case, but the -i option is
+ *   also provided to make things interactive. For example, the user could
+ *   issue 'zlogin -i my-zone /bin/sh'. In this mode neither 'login -c' nor
+ *   'su root -c' is prepended to the command invocation. Because of this
+ *   there will be no wtmpx login record within the zone.
+ *
  * - "console login" is the equivalent to accessing the tip line for a
  *   zone.  For example, the user can issue 'zlogin -C my-zone'.
  *   In this mode, zlogin contacts the zoneadmd process via unix domain
@@ -48,6 +56,9 @@
  *   socket.  If zoneadmd is not running, it starts it.  This allows the
  *   console to be available anytime the zone is installed, regardless of
  *   whether it is running.
+ *
+ * - "standalone-processs interactive" is specified with -I and connects to
+ *   the zone's stdin, stdout and stderr zfd(7D) devices.
  */
 
 #include <sys/socket.h>
@@ -92,7 +103,8 @@
 #include <auth_attr.h>
 #include <secdb.h>
 
-static int masterfd;
+static int masterfd = -1;
+static int ctlfd = -1;
 static struct termios save_termios;
 static struct termios effective_termios;
 static int save_fd;
@@ -101,12 +113,13 @@
 static volatile pid_t child_pid = -1;
 static int interactive = 0;
 static priv_set_t *dropprivs;
+static unsigned int connect_flags = 0;
 
 static int nocmdchar = 0;
 static int failsafe = 0;
-static int disconnect = 0;
 static char cmdchar = '~';
 static int quiet = 0;
+static char zonebrand[MAXNAMELEN];
 
 static int pollerr = 0;
 
@@ -123,10 +136,12 @@
 #define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it wasn't */
 #endif
 
-#define	SUPATH	"/usr/bin/su"
+#define	SUPATH1	"/usr/bin/su"
+#define	SUPATH2	"/bin/su"
 #define	FAILSAFESHELL	"/sbin/sh"
 #define	DEFAULTSHELL	"/sbin/sh"
 #define	DEF_PATH	"/usr/sbin:/usr/bin"
+#define	LX_DEF_PATH	"/bin:/usr/sbin:/usr/bin"
 
 #define	CLUSTER_BRAND_NAME	"cluster"
 
@@ -153,7 +168,7 @@
 static void
 usage(void)
 {
-	(void) fprintf(stderr, gettext("usage: %s [ -dnQCES ] [ -e cmdchar ] "
+	(void) fprintf(stderr, gettext("usage: %s [-dinCEINQS] [-e cmdchar] "
 	    "[-l user] zonename [command [args ...] ]\n"), pname);
 	exit(2);
 }
@@ -248,19 +263,11 @@
 	}
 }
 
-/*
- * Create the unix domain socket and call the zoneadmd server; handshake
- * with it to determine whether it will allow us to connect.
- */
 static int
-get_console_master(const char *zname)
+connect_zone_sock(const char *zname, const char *suffix)
 {
 	int sockfd = -1;
 	struct sockaddr_un servaddr;
-	char clientid[MAXPATHLEN];
-	char handshake[MAXPATHLEN], c;
-	int msglen;
-	int i = 0, err = 0;
 
 	if ((sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
 		zperror(gettext("could not create socket"));
@@ -270,35 +277,44 @@
 	bzero(&servaddr, sizeof (servaddr));
 	servaddr.sun_family = AF_UNIX;
 	(void) snprintf(servaddr.sun_path, sizeof (servaddr.sun_path),
-	    "%s/%s.console_sock", ZONES_TMPDIR, zname);
-
+	    "%s/%s.%s", ZONES_TMPDIR, zname, suffix);
 	if (connect(sockfd, (struct sockaddr *)&servaddr,
 	    sizeof (servaddr)) == -1) {
-		zperror(gettext("Could not connect to zone console"));
-		goto bad;
+		zperror(gettext("Could not connect to zone"));
+		close(sockfd);
+		return (-1);
 	}
-	masterfd = sockfd;
+	return (sockfd);
+}
 
-	msglen = snprintf(clientid, sizeof (clientid), "IDENT %lu %s %d\n",
-	    getpid(), setlocale(LC_MESSAGES, NULL), disconnect);
 
+static int
+handshake_zone_sock(int sockfd, unsigned int flags)
+{
+	char clientid[MAXPATHLEN];
+	char handshake[MAXPATHLEN], c;
+	int msglen;
+	int i = 0, err = 0;
+
+	msglen = snprintf(clientid, sizeof (clientid), "IDENT %s %u\n",
+	    setlocale(LC_MESSAGES, NULL), flags);
+
 	if (msglen >= sizeof (clientid) || msglen < 0) {
 		zerror("protocol error");
-		goto bad;
+		return (-1);
 	}
 
-	if (write(masterfd, clientid, msglen) != msglen) {
+	if (write(sockfd, clientid, msglen) != msglen) {
 		zerror("protocol error");
-		goto bad;
+		return (-1);
 	}
 
-	bzero(handshake, sizeof (handshake));
-
 	/*
 	 * Take care not to accumulate more than our fill, and leave room for
 	 * the NUL at the end.
 	 */
-	while ((err = read(masterfd, &c, 1)) == 1) {
+	bzero(handshake, sizeof (handshake));
+	while ((err = read(sockfd, &c, 1)) == 1) {
 		if (i >= (sizeof (handshake) - 1))
 			break;
 		if (c == '\n')
@@ -308,26 +324,48 @@
 	}
 
 	/*
-	 * If something went wrong during the handshake we bail; perhaps
-	 * the server died off.
+	 * If something went wrong during the handshake we bail.
+	 * Perhaps the server died off.
 	 */
 	if (err == -1) {
-		zperror(gettext("Could not connect to zone console"));
-		goto bad;
+		zperror(gettext("Could not connect to zone"));
+		return (-1);
 	}
 
-	if (strncmp(handshake, "OK", sizeof (handshake)) == 0)
-		return (0);
+	if (strncmp(handshake, "OK", sizeof (handshake)) != 0) {
+		zerror(gettext("Zone is already in use by process ID %s."),
+		    handshake);
+		return (-1);
+	}
 
-	zerror(gettext("Console is already in use by process ID %s."),
-	    handshake);
-bad:
-	(void) close(sockfd);
-	masterfd = -1;
-	return (-1);
+	return (0);
 }
 
-
+static int
+send_ctl_sock(const char *buf, size_t len)
+{
+	char rbuf[BUFSIZ];
+	int i;
+	if (ctlfd == -1) {
+		return (-1);
+	}
+	if (write(ctlfd, buf, len) != len) {
+		return (-1);
+	}
+	/* read the response */
+	for (i = 0; i < (BUFSIZ - 1); i++) {
+		char c;
+		if (read(ctlfd, &c, 1) != 1 || c == '\n' || c == '\0') {
+			break;
+		}
+		rbuf[i] = c;
+	}
+	rbuf[i+1] = '\0';
+	if (strncmp("OK", rbuf, BUFSIZ) != 0) {
+		return (-1);
+	}
+	return (0);
+}
 /*
  * Routines to handle pty creation upon zone entry and to shuttle I/O back
  * and forth between the two terminals.  We also compute and store the
@@ -516,10 +554,34 @@
 {
 	struct winsize ws;
 
-	if (ioctl(0, TIOCGWINSZ, &ws) == 0)
-		(void) ioctl(masterfd, TIOCSWINSZ, &ws);
+	if (ioctl(0, TIOCGWINSZ, &ws) == 0) {
+		if (ctlfd != -1) {
+			char buf[BUFSIZ];
+			snprintf(buf, sizeof (buf), "TIOCSWINSZ %hu %hu\n",
+			    ws.ws_row, ws.ws_col);
+			(void) send_ctl_sock(buf, strlen(buf));
+		} else {
+			(void) ioctl(masterfd, TIOCSWINSZ, &ws);
+		}
+	}
 }
 
+/*
+ * Toggle zfd EOF mode and notify zoneadmd
+ */
+/*ARGSUSED*/
+static void
+sigusr1(int s)
+{
+	connect_flags ^= ZLOGIN_ZFD_EOF;
+	if (ctlfd != -1) {
+		char buf[BUFSIZ];
+		snprintf(buf, sizeof (buf), "SETFLAGS %u\n",
+		    connect_flags);
+		(void) send_ctl_sock(buf, strlen(buf));
+	}
+}
+
 static volatile int close_on_sig = -1;
 
 static void
@@ -862,28 +924,28 @@
 			break;
 		}
 
-		/* event from master side stdout */
-		if (pollfds[0].revents) {
-			if (pollfds[0].revents &
+		/* event from master side stderr */
+		if (pollfds[1].revents) {
+			if (pollfds[1].revents &
 			    (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) {
-				if (process_output(stdout_fd, STDOUT_FILENO)
+				if (process_output(stderr_fd, STDERR_FILENO)
 				    != 0)
 					break;
 			} else {
-				pollerr = pollfds[0].revents;
+				pollerr = pollfds[1].revents;
 				break;
 			}
 		}
 
-		/* event from master side stderr */
-		if (pollfds[1].revents) {
-			if (pollfds[1].revents &
+		/* event from master side stdout */
+		if (pollfds[0].revents) {
+			if (pollfds[0].revents &
 			    (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) {
-				if (process_output(stderr_fd, STDERR_FILENO)
+				if (process_output(stdout_fd, STDOUT_FILENO)
 				    != 0)
 					break;
 			} else {
-				pollerr = pollfds[1].revents;
+				pollerr = pollfds[0].revents;
 				break;
 			}
 		}
@@ -1053,7 +1115,7 @@
 	 * but we're going to be very simplistic about it and break stuff
 	 * up based on spaces.  We're not even going to support any kind
 	 * of quoting or escape characters.  It's truly amazing that
-	 * there is no library function in OpenSolaris to do this for us.
+	 * there is no library function in Illumos to do this for us.
 	 */
 
 	/*
@@ -1099,7 +1161,7 @@
  * checks).
  */
 static char **
-prep_args(brand_handle_t bh, const char *login, char **argv)
+prep_args(brand_handle_t bh, char *zonename, const char *login, char **argv)
 {
 	int argc = 0, a = 0, i, n = -1;
 	char **new_argv;
@@ -1112,35 +1174,105 @@
 			argc++;
 
 		for (i = 0; i < argc; i++) {
-			subshell_len += strlen(argv[i]) + 1;
+			/*
+			 * Allocate enough space for the delimiter and 2
+			 * quotes which might be needed.
+			 */
+			subshell_len += strlen(argv[i]) + 3;
 		}
 		if ((subshell = calloc(1, subshell_len)) == NULL)
 			return (NULL);
 
+		/*
+		 * The handling of quotes in the following block may seem
+		 * unusual, but it is done this way for backward compatibility.
+		 * When running a command, zlogin is documented as:
+		 *    zlogin zonename command args
+		 * However, some code has come to depend on the following usage:
+		 *    zlogin zonename 'command args'
+		 * This relied on the fact that the single argument would be
+		 * re-parsed within the zone and excuted as a command with an
+		 * argument. To remain compatible with this (incorrect) usage,
+		 * if there is only a single argument, it is not quoted, even
+		 * if it has embedded spaces.
+		 *
+		 * Here are two examples which both need to work:
+		 * 1) zlogin foo 'echo hello'
+		 *    This has a single argv member with a space in it but will
+		 *    not be quoted on the command passed into the zone.
+		 * 2) zlogin foo bash -c 'echo hello'
+		 *    This has 3 argv members. The 3rd arg has a space and must
+		 *    be quoted on the command passed into the zone.
+		 */
 		for (i = 0; i < argc; i++) {
-			(void) strcat(subshell, argv[i]);
-			(void) strcat(subshell, " ");
+			if (i > 0)
+				(void) strcat(subshell, " ");
+
+			if (argc > 1 && (strchr(argv[i], ' ') != NULL ||
+			    strchr(argv[i], '\t') != NULL)) {
+				(void) strcat(subshell, "'");
+				(void) strcat(subshell, argv[i]);
+				(void) strcat(subshell, "'");
+			} else {
+				(void) strcat(subshell, argv[i]);
+			}
 		}
 
 		if (failsafe) {
 			n = 4;
-			if ((new_argv = malloc(sizeof (char *) * n)) == NULL)
-				return (NULL);
+		} else {
+			n = 6;
+		}
 
+		if ((new_argv = malloc(sizeof (char *) * n)) == NULL)
+			return (NULL);
+
+		if (failsafe) {
 			new_argv[a++] = FAILSAFESHELL;
+			new_argv[a++] = "-c";
 		} else {
-			n = 5;
-			if ((new_argv = malloc(sizeof (char *) * n)) == NULL)
+			struct stat sb;
+			char zonepath[MAXPATHLEN];
+			char supath[MAXPATHLEN];
+
+			/*
+			 * We allocated an extra slot in case our login below
+			 * is not 'root' but normally we don't take that code
+			 * path.
+			 */
+			n--;
+
+			if (zone_get_zonepath(zonename, zonepath,
+			    sizeof (zonepath)) != Z_OK) {
+				zerror(gettext("unable to determine zone "
+				    "path"));
 				return (NULL);
+			}
 
-			new_argv[a++] = SUPATH;
+			(void) snprintf(supath, sizeof (supath), "%s/root/%s",
+			    zonepath, SUPATH1);
+			if (stat(supath, &sb) == 0) {
+				new_argv[a++] = SUPATH1;
+			} else {
+				(void) snprintf(supath, sizeof (supath),
+				    "%s/root/%s", zonepath, SUPATH2);
+				if (stat(supath, &sb) == 0) {
+					new_argv[a++] = SUPATH2;
+				} else {
+					zerror(gettext("unable to find 'su' "
+					    "command"));
+					return (NULL);
+				}
+			}
+
 			if (strcmp(login, "root") != 0) {
 				new_argv[a++] = "-";
 				n++;
 			}
 			new_argv[a++] = (char *)login;
+			new_argv[a++] = "-c";
 		}
-		new_argv[a++] = "-c";
+
 		new_argv[a++] = subshell;
 		new_argv[a++] = NULL;
 		assert(a == n);
@@ -1185,6 +1317,7 @@
 	int e = 0, size = 1;
 	char **new_env, *estr;
 	char *term = getenv("TERM");
+	char *path;
 
 	size++;	/* for $PATH */
 	if (term != NULL)
@@ -1201,7 +1334,12 @@
 	if ((new_env = malloc(sizeof (char *) * size)) == NULL)
 		return (NULL);
 
-	if ((estr = add_env("PATH", DEF_PATH)) == NULL)
+	if (strcmp(zonebrand, "lx") == 0)
+		path = LX_DEF_PATH;
+	else
+		path = DEF_PATH;
+
+	if ((estr = add_env("PATH", path)) == NULL)
 		return (NULL);
 	new_env[e++] = estr;
 
@@ -1723,13 +1861,48 @@
 	return (nptr->pw_name);
 }
 
+static boolean_t
+zlog_mode_logging(char *zonename)
+{
+	boolean_t lm = B_FALSE;
+	zone_dochandle_t handle;
+	struct zone_attrtab attr;
+
+	if ((handle = zonecfg_init_handle()) == NULL)
+		return (lm);
+
+	if (zonecfg_get_handle(zonename, handle) != Z_OK)
+		goto done;
+
+	if (zonecfg_setattrent(handle) != Z_OK)
+		goto done;
+	while (zonecfg_getattrent(handle, &attr) == Z_OK) {
+		if (strcmp("zlog-mode", attr.zone_attr_name) == 0) {
+			int len = strlen(attr.zone_attr_value);
+
+			if (strncmp("log", attr.zone_attr_value, 3) == 0 ||
+			    strncmp("nolog", attr.zone_attr_value, 5) == 0 ||
+			    (len >= 3 && attr.zone_attr_value[len - 2] == '-'))
+				lm = B_TRUE;
+			break;
+		}
+	}
+	(void) zonecfg_endattrent(handle);
+
+done:
+	zonecfg_fini_handle(handle);
+	return (lm);
+}
+
 int
 main(int argc, char **argv)
 {
-	int arg, console = 0;
+	int arg, console = 0, imode = 0;
+	int estatus = 0;
 	zoneid_t zoneid;
 	zone_state_t st;
 	char *login = "root";
+	int iflag = 0;
 	int lflag = 0;
 	int nflag = 0;
 	char *zonename = NULL;
@@ -1736,11 +1909,11 @@
 	char **proc_args = NULL;
 	char **new_args, **new_env;
 	sigset_t block_cld;
+	siginfo_t si;
 	char devroot[MAXPATHLEN];
 	char *slavename, slaveshortname[MAXPATHLEN];
 	priv_set_t *privset;
 	int tmpl_fd;
-	char zonebrand[MAXNAMELEN];
 	char default_brand[MAXNAMELEN];
 	struct stat sb;
 	char kernzone[ZONENAME_MAX];
@@ -1754,7 +1927,7 @@
 	(void) getpname(argv[0]);
 	username = get_username();
 
-	while ((arg = getopt(argc, argv, "dnECR:Se:l:Q")) != EOF) {
+	while ((arg = getopt(argc, argv, "diNnECIR:Se:l:Q")) != EOF) {
 		switch (arg) {
 		case 'C':
 			console = 1;
@@ -1762,6 +1935,16 @@
 		case 'E':
 			nocmdchar = 1;
 			break;
+		case 'I':
+			/*
+			 * interactive mode is just a slight variation on the
+			 * console mode.
+			 */
+			console = 1;
+			imode = 1;
+			/* The default is HUP, disconnect on EOF */
+			connect_flags ^= ZLOGIN_ZFD_EOF;
+			break;
 		case 'R':	/* undocumented */
 			if (*optarg != '/') {
 				zerror(gettext("root path must be absolute."));
@@ -1781,15 +1964,22 @@
 			failsafe = 1;
 			break;
 		case 'd':
-			disconnect = 1;
+			connect_flags |= ZLOGIN_DISCONNECT;
 			break;
 		case 'e':
 			set_cmdchar(optarg);
 			break;
+		case 'i':
+			iflag = 1;
+			break;
 		case 'l':
 			login = optarg;
 			lflag = 1;
 			break;
+		case 'N':
+			/* NOHUP - do not send EOF */
+			connect_flags ^= ZLOGIN_ZFD_EOF;
+			break;
 		case 'n':
 			nflag = 1;
 			break;
@@ -1800,6 +1990,12 @@
 
 	if (console != 0) {
 
+		/*
+		 * The only connect option in console mode is ZLOGIN_DISCONNECT
+		 */
+		if (imode == 0)
+			connect_flags &= ZLOGIN_DISCONNECT;
+
 		if (lflag != 0) {
 			zerror(gettext(
 			    "-l may not be specified for console login"));
@@ -1826,17 +2022,27 @@
 
 	}
 
+	if (iflag != 0 && nflag != 0) {
+		zerror(gettext("-i and -n flags are incompatible"));
+		usage();
+	}
+
 	if (failsafe != 0 && lflag != 0) {
 		zerror(gettext("-l may not be specified for failsafe login"));
 		usage();
 	}
 
-	if (!console && disconnect != 0) {
+	if (!console && (connect_flags & ZLOGIN_DISCONNECT) != 0) {
 		zerror(gettext(
 		    "-d may only be specified with console login"));
 		usage();
 	}
 
+	if (imode == 0 && (connect_flags & ZLOGIN_ZFD_EOF) != 0) {
+		zerror(gettext("-N may only be specified with -I"));
+		usage();
+	}
+
 	if (optind == (argc - 1)) {
 		/*
 		 * zone name, no process name; this should be an interactive
@@ -1859,7 +2065,8 @@
 		/* zone name and process name, and possibly some args */
 		zonename = argv[optind];
 		proc_args = &argv[optind + 1];
-		interactive = 0;
+		if (iflag && isatty(STDIN_FILENO))
+			interactive = 1;
 	} else {
 		usage();
 	}
@@ -1945,10 +2152,16 @@
 	}
 
 	/*
-	 * The console is a separate case from the rest of the code; handle
-	 * it first.
+	 * The console (or standalong interactive mode) is a separate case from
+	 * the rest of the code; handle it first.
 	 */
 	if (console) {
+		int gz_stderr_fd = -1;
+		boolean_t set_raw = B_TRUE;
+
+		if (imode && zlog_mode_logging(zonename))
+			set_raw = B_FALSE;
+
 		/*
 		 * Ensure that zoneadmd for this zone is running.
 		 */
@@ -1958,15 +2171,49 @@
 		/*
 		 * Make contact with zoneadmd.
 		 */
-		if (get_console_master(zonename) == -1)
-			return (1);
+		if (!imode) {
+			masterfd = connect_zone_sock(zonename, "console_sock");
+			if (masterfd == -1) {
+				return (1);
+			}
+			if (handshake_zone_sock(masterfd,
+			    connect_flags) != 0) {
+				(void) close(masterfd);
+				return (1);
+			}
+		} else {
+			/* handshake with the control socket first */
+			ctlfd = connect_zone_sock(zonename, "server_ctl");
+			if (ctlfd == -1) {
+				return (1);
+			}
+			if (handshake_zone_sock(ctlfd,
+			    connect_flags) != 0) {
+				(void) close(ctlfd);
+				return (1);
+			}
+			/* then open the io-related sockets */
+			masterfd = connect_zone_sock(zonename, "server_out");
+			gz_stderr_fd = connect_zone_sock(zonename,
+			    "server_err");
+			if (masterfd == -1 || gz_stderr_fd == -1) {
+				(void) close(ctlfd);
+				(void) close(masterfd);
+				(void) close(gz_stderr_fd);
+				return (1);
+			}
+		}
 
-		if (!quiet)
-			(void) printf(
-			    gettext("[Connected to zone '%s' console]\n"),
-			    zonename);
+		if (!quiet) {
+			if (imode)
+				(void) printf(gettext("[Connected to zone '%s' "
+				    "interactively]\n"), zonename);
+			else
+				(void) printf(gettext("[Connected to zone '%s' "
+				    "console]\n"), zonename);
+		}
 
-		if (set_tty_rawmode(STDIN_FILENO) == -1) {
+		if (set_raw && set_tty_rawmode(STDIN_FILENO) == -1) {
 			reset_tty();
 			zperror(gettext("failed to set stdin pty to raw mode"));
 			return (1);
@@ -1975,15 +2222,25 @@
 		(void) sigset(SIGWINCH, sigwinch);
 		(void) sigwinch(0);
 
+		if (imode) {
+			/* Allow EOF mode toggling via SIGUSR1 */
+			(void) sigset(SIGUSR1, sigusr1);
+		}
+
 		/*
 		 * Run the I/O loop until we get disconnected.
 		 */
-		doio(masterfd, -1, masterfd, -1, -1, B_FALSE);
+		doio(masterfd, -1, masterfd, gz_stderr_fd, -1, B_FALSE);
 		reset_tty();
-		if (!quiet)
-			(void) printf(
-			    gettext("\n[Connection to zone '%s' console "
-			    "closed]\n"), zonename);
+		if (!quiet) {
+			if (imode)
+				(void) printf(gettext("\n[Interactive "
+				    "connection to zone '%s' closed]\n"),
+				    zonename);
+			else
+				(void) printf(gettext("\n[Connection to zone "
+				    "'%s' console closed]\n"), zonename);
+		}
 
 		return (0);
 	}
@@ -2051,11 +2308,23 @@
 		return (1);
 	}
 
-	if ((new_args = prep_args(bh, login, proc_args)) == NULL) {
-		zperror(gettext("could not assemble new arguments"));
-		brand_close(bh);
-		return (1);
+	/*
+	 * The 'interactive' parameter (-i option) indicates that we're running
+	 * a command interactively. In this case we skip prep_args so that we
+	 * don't prepend the 'su root -c' preamble to the command invocation
+	 * since the 'su' command typically will execute a setpgrp which will
+	 * disassociate the actual command from the controlling terminal that
+	 * we (zlogin) setup.
+	 */
+	if (!iflag) {
+		if ((new_args = prep_args(bh, zonename, login, proc_args))
+		    == NULL) {
+			zperror(gettext("could not assemble new arguments"));
+			brand_close(bh);
+			return (1);
+		}
 	}
+
 	/*
 	 * Get the brand specific user_cmd.  This command is used to get
 	 * a passwd(4) entry for login.
@@ -2201,6 +2470,8 @@
 			return (1);
 		}
 
+		/* Note: we're now inside the zone, can't use gettext anymore */
+
 		if (slavefd != STDERR_FILENO)
 			(void) close(STDERR_FILENO);
 
@@ -2242,8 +2513,18 @@
 		/*
 		 * In failsafe mode, we don't use login(1), so don't try
 		 * setting up a utmpx entry.
+		 *
+		 * A branded zone may have very different utmpx semantics.
+		 * At the moment, we only have two brand types:
+		 * Illumos-like (native, sn1) and Linux.  In the Illumos
+		 * case, we know exactly how to do the necessary utmpx
+		 * setup.  Fortunately for us, the Linux /bin/login is
+		 * prepared to deal with a non-initialized utmpx entry, so
+		 * we can simply skip it.  If future brands don't fall into
+		 * either category, we'll have to add a per-brand utmpx
+		 * setup hook.
 		 */
-		if (!failsafe)
+		if (!failsafe && (strcmp(zonebrand, "lx") != 0))
 			if (setup_utmpx(slaveshortname) == -1)
 				return (1);
 
@@ -2252,13 +2533,17 @@
 		 * execute the brand's login program.
 		 */
 		if (setuid(0) == -1) {
-			zperror(gettext("insufficient privilege"));
+			zperror("insufficient privilege");
 			return (1);
 		}
 
-		(void) execve(new_args[0], new_args, new_env);
-		zperror(gettext("exec failure"));
-		return (1);
+		if (iflag) {
+			(void) execve(proc_args[0], proc_args, new_env);
+		} else {
+			(void) execve(new_args[0], new_args, new_env);
+		}
+		zperror("exec failure");
+		return (ENOEXEC);
 	}
 
 	(void) ct_tmpl_clear(tmpl_fd);
@@ -2283,8 +2568,19 @@
 	if (pollerr != 0) {
 		(void) fprintf(stderr, gettext("Error: connection closed due "
 		    "to unexpected pollevents=0x%x.\n"), pollerr);
-		return (1);
+		return (EPIPE);
 	}
 
-	return (0);
+	/* reap child and get its status */
+	if (waitid(P_PID, child_pid, &si, WEXITED | WNOHANG) == -1) {
+		estatus = errno;
+	} else if (si.si_pid == 0) {
+		estatus = ECHILD;
+	} else if (si.si_code == CLD_EXITED) {
+		estatus = si.si_status;
+	} else {
+		estatus = ECONNABORTED;
+	}
+
+	return (estatus);
 }
usr/src/cmd/zoneadm/svc-zones
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/zoneadm/svc-zones	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/zoneadm/svc-zones	Wed Jun 17 17:43:38 2015
@@ -32,7 +32,7 @@
 shutdown_zones()
 {
 	zoneadm list -p | nawk -F: '{
-		if ($2 != "global") {
+		if (($5 != "lx") && ($2 != "global")) {
 			print $2
 		}
 	}'
usr/src/cmd/zoneadm/zoneadm.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/zoneadm/zoneadm.c	Mon Oct 19 10:48:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/zoneadm/zoneadm.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2015, Joyent Inc. All rights reserved.
  * Copyright (c) 2015 by Delphix. All rights reserved.
  */
 
@@ -101,13 +102,11 @@
 	char		zroot[MAXPATHLEN];
 	char		zuuid[UUID_PRINTABLE_STRING_LENGTH];
 	zone_iptype_t	ziptype;
+	zoneid_t	zdid;
 } zone_entry_t;
 
 #define	CLUSTER_BRAND_NAME	"cluster"
 
-static zone_entry_t *zents;
-static size_t nzents;
-
 #define	LOOPBACK_IF	"lo0"
 #define	SOCKET_AF(af)	(((af) == AF_UNSPEC) ? AF_INET : (af))
 
@@ -406,19 +405,6 @@
 	va_end(alist);
 }
 
-static void *
-safe_calloc(size_t nelem, size_t elsize)
-{
-	void *r = calloc(nelem, elsize);
-
-	if (r == NULL) {
-		zerror(gettext("failed to allocate %lu bytes: %s"),
-		    (ulong_t)nelem * elsize, strerror(errno));
-		exit(Z_ERR);
-	}
-	return (r);
-}
-
 static void
 zone_print(zone_entry_t *zent, boolean_t verbose, boolean_t parsable)
 {
@@ -443,6 +429,7 @@
 	}
 	if (!verbose) {
 		char *cp, *clim;
+		char zdid[80];
 
 		if (!parsable) {
 			(void) printf("%s\n", zent->zname);
@@ -458,8 +445,12 @@
 			(void) printf("%.*s\\:", clim - cp, cp);
 			cp = clim + 1;
 		}
-		(void) printf("%s:%s:%s:%s\n", cp, zent->zuuid, zent->zbrand,
-		    ip_type_str);
+		if (zent->zdid == -1)
+			zdid[0] = '\0';
+		else
+			(void) snprintf(zdid, sizeof (zdid), "%d", zent->zdid);
+		(void) printf("%s:%s:%s:%s:%s\n", cp, zent->zuuid, zent->zbrand,
+		    ip_type_str, zdid);
 		return;
 	}
 	if (zent->zstate_str != NULL) {
@@ -485,6 +476,9 @@
 	(void) strlcpy(zent->zbrand, "???", sizeof (zent->zbrand));
 	zent->zstate_str = "???";
 
+	if (strcmp(zone_name, GLOBAL_ZONENAME) == 0)
+		zid = zent->zdid = GLOBAL_ZONEID;
+
 	zent->zid = zid;
 
 	if (zonecfg_get_uuid(zone_name, uuid) == Z_OK &&
@@ -529,8 +523,8 @@
 	zent->zstate_str = zone_state_str(zent->zstate_num);
 
 	/*
-	 * A zone's brand is only available in the .xml file describing it,
-	 * which is only visible to the global zone.  This causes
+	 * A zone's brand might only be available in the .xml file describing
+	 * it, which is only visible to the global zone.  This causes
 	 * zone_get_brand() to fail when called from within a non-global
 	 * zone.  Fortunately we only do this on labeled systems, where we
 	 * know all zones are native.
@@ -554,6 +548,22 @@
 		return (Z_OK);
 	}
 
+	if ((handle = zonecfg_init_handle()) == NULL) {
+		zperror2(zent->zname, gettext("could not init handle"));
+		return (Z_ERR);
+	}
+	if ((err = zonecfg_get_handle(zent->zname, handle)) != Z_OK) {
+		zperror2(zent->zname, gettext("could not get handle"));
+		zonecfg_fini_handle(handle);
+		return (Z_ERR);
+	}
+
+	if ((err = zonecfg_get_iptype(handle, &zent->ziptype)) != Z_OK) {
+		zperror2(zent->zname, gettext("could not get ip-type"));
+		zonecfg_fini_handle(handle);
+		return (Z_ERR);
+	}
+
 	/*
 	 * There is a race condition where the zone could boot while
 	 * we're walking the index file.  In this case the zone state
@@ -574,189 +584,73 @@
 				zent->ziptype = ZS_EXCLUSIVE;
 			else
 				zent->ziptype = ZS_SHARED;
-			return (Z_OK);
 		}
 	}
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zperror2(zent->zname, gettext("could not init handle"));
-		return (Z_ERR);
-	}
-	if ((err = zonecfg_get_handle(zent->zname, handle)) != Z_OK) {
-		zperror2(zent->zname, gettext("could not get handle"));
-		zonecfg_fini_handle(handle);
-		return (Z_ERR);
-	}
+	zent->zdid = zonecfg_get_did(handle);
 
-	if ((err = zonecfg_get_iptype(handle, &zent->ziptype)) != Z_OK) {
-		zperror2(zent->zname, gettext("could not get ip-type"));
-		zonecfg_fini_handle(handle);
-		return (Z_ERR);
-	}
 	zonecfg_fini_handle(handle);
 
 	return (Z_OK);
 }
 
-/*
- * fetch_zents() calls zone_list(2) to find out how many zones are running
- * (which is stored in the global nzents), then calls zone_list(2) again
- * to fetch the list of running zones (stored in the global zents).  This
- * function may be called multiple times, so if zents is already set, we
- * return immediately to save work.
- *
- * Note that the data about running zones can change while this function
- * is running, so its possible that the list of zones will have empty slots
- * at the end.
- */
-
 static int
-fetch_zents(void)
+zone_print_list(zone_state_t min_state, boolean_t verbose, boolean_t parsable)
 {
-	zoneid_t *zids = NULL;
-	uint_t nzents_saved;
-	int i, retv;
-	FILE *fp;
-	boolean_t inaltroot;
-	zone_entry_t *zentp;
-	const char *altroot;
+	zone_entry_t zent;
+	FILE *cookie;
+	struct zoneent *ze;
 
-	if (nzents > 0)
-		return (Z_OK);
+	/*
+	 * Get the full list of zones from the configuration.
+	 */
+	cookie = setzoneent();
+	while ((ze = getzoneent_private(cookie)) != NULL) {
+		char *name = ze->zone_name;
+		zoneid_t zid;
 
-	if (zone_list(NULL, &nzents) != 0) {
-		zperror(gettext("failed to get zoneid list"), B_FALSE);
-		return (Z_ERR);
-	}
+		zid = getzoneidbyname(name);
 
-again:
-	if (nzents == 0)
-		return (Z_OK);
-
-	zids = safe_calloc(nzents, sizeof (zoneid_t));
-	nzents_saved = nzents;
-
-	if (zone_list(zids, &nzents) != 0) {
-		zperror(gettext("failed to get zone list"), B_FALSE);
-		free(zids);
-		return (Z_ERR);
-	}
-	if (nzents != nzents_saved) {
-		/* list changed, try again */
-		free(zids);
-		goto again;
-	}
-
-	zents = safe_calloc(nzents, sizeof (zone_entry_t));
-
-	inaltroot = zonecfg_in_alt_root();
-	if (inaltroot) {
-		fp = zonecfg_open_scratch("", B_FALSE);
-		altroot = zonecfg_get_root();
-	} else {
-		fp = NULL;
-	}
-	zentp = zents;
-	retv = Z_OK;
-	for (i = 0; i < nzents; i++) {
-		char name[ZONENAME_MAX];
-		char altname[ZONENAME_MAX];
-		char rev_altroot[MAXPATHLEN];
-
-		if (getzonenamebyid(zids[i], name, sizeof (name)) < 0) {
-			/*
-			 * There is a race condition where the zone may have
-			 * shutdown since we retrieved the number of running
-			 * zones above.  This is not an error, there will be
-			 * an empty slot at the end of the list.
-			 */
-			continue;
-		}
-		if (zonecfg_is_scratch(name)) {
-			/* Ignore scratch zones by default */
-			if (!inaltroot)
+		if (ze->zone_brand[0] == '\0') {
+			/* old, incomplete index entry */
+			if (lookup_zone_info(name, zid, &zent) != Z_OK) {
+				free(ze);
 				continue;
-			if (fp == NULL ||
-			    zonecfg_reverse_scratch(fp, name, altname,
-			    sizeof (altname), rev_altroot,
-			    sizeof (rev_altroot)) == -1) {
-				zerror(gettext("could not resolve scratch "
-				    "zone %s"), name);
-				retv = Z_ERR;
-				continue;
 			}
-			/* Ignore zones in other alternate roots */
-			if (strcmp(rev_altroot, altroot) != 0)
-				continue;
-			(void) strcpy(name, altname);
 		} else {
-			/* Ignore non-scratch when in an alternate root */
-			if (inaltroot && strcmp(name, GLOBAL_ZONENAME) != 0)
-				continue;
-		}
-		if (lookup_zone_info(name, zids[i], zentp) != Z_OK) {
-			/*
-			 * There is a race condition where the zone may have
-			 * shutdown since we retrieved the number of running
-			 * zones above.  This is not an error, there will be
-			 * an empty slot at the end of the list.
-			 */
-			continue;
-		}
-		zentp++;
-	}
-	nzents = zentp - zents;
-	if (fp != NULL)
-		zonecfg_close_scratch(fp);
+			/* new, full index entry */
+			(void) strlcpy(zent.zname, name, sizeof (zent.zname));
+			(void) strlcpy(zent.zroot, ze->zone_path,
+			    sizeof (zent.zroot));
+			uuid_unparse(ze->zone_uuid, zent.zuuid);
+			(void) strlcpy(zent.zbrand, ze->zone_brand,
+			    sizeof (zent.zbrand));
+			zent.ziptype = ze->zone_iptype;
+			zent.zdid = ze->zone_did;
+			zent.zid = zid;
 
-	free(zids);
-	return (retv);
-}
+			if (zid != -1) {
+				int err;
 
-static int
-zone_print_list(zone_state_t min_state, boolean_t verbose, boolean_t parsable)
-{
-	int i;
-	zone_entry_t zent;
-	FILE *cookie;
-	char *name;
+				err = zone_get_state(name,
+				    (zone_state_t *)&ze->zone_state);
+				if (err != Z_OK) {
+					errno = err;
+					zperror2(name, gettext("could not get "
+					    "state"));
+					free(ze);
+					continue;
+				}
+			}
 
-	/*
-	 * First get the list of running zones from the kernel and print them.
-	 * If that is all we need, then return.
-	 */
-	if ((i = fetch_zents()) != Z_OK) {
-		/*
-		 * No need for error messages; fetch_zents() has already taken
-		 * care of this.
-		 */
-		return (i);
-	}
-	for (i = 0; i < nzents; i++)
-		zone_print(&zents[i], verbose, parsable);
-	if (min_state >= ZONE_STATE_RUNNING)
-		return (Z_OK);
-	/*
-	 * Next, get the full list of zones from the configuration, skipping
-	 * any we have already printed.
-	 */
-	cookie = setzoneent();
-	while ((name = getzoneent(cookie)) != NULL) {
-		for (i = 0; i < nzents; i++) {
-			if (strcmp(zents[i].zname, name) == 0)
-				break;
+			zent.zstate_num = ze->zone_state;
+			zent.zstate_str = zone_state_str(zent.zstate_num);
 		}
-		if (i < nzents) {
-			free(name);
-			continue;
-		}
-		if (lookup_zone_info(name, ZONE_ID_UNDEFINED, &zent) != Z_OK) {
-			free(name);
-			continue;
-		}
-		free(name);
+
 		if (zent.zstate_num >= min_state)
 			zone_print(&zent, verbose, parsable);
+
+		free(ze);
 	}
 	endzoneent(cookie);
 	return (Z_OK);
@@ -766,18 +660,22 @@
  * Retrieve a zone entry by name.  Returns NULL if no such zone exists.
  */
 static zone_entry_t *
-lookup_running_zone(const char *str)
+lookup_running_zone(const char *name)
 {
-	int i;
+	zoneid_t zid;
+	zone_entry_t *zent;
 
-	if (fetch_zents() != Z_OK)
+	if ((zid = getzoneidbyname(name)) == -1)
 		return (NULL);
 
-	for (i = 0; i < nzents; i++) {
-		if (strcmp(str, zents[i].zname) == 0)
-			return (&zents[i]);
+	if ((zent = malloc(sizeof (zone_entry_t))) == NULL)
+		return (NULL);
+
+	if (lookup_zone_info(name, zid, zent) != Z_OK) {
+		free(zent);
+		return (NULL);
 	}
-	return (NULL);
+	return (zent);
 }
 
 /*
@@ -1013,8 +911,12 @@
 		(void) printf(gettext("WARNING: %s is on a temporary "
 		    "file system.\n"), rpath);
 	}
-	if (crosscheck_zonepaths(rpath) != Z_OK)
-		return (Z_ERR);
+	if (cmd_num != CMD_BOOT && cmd_num != CMD_REBOOT &&
+	    cmd_num != CMD_READY) {
+		/* we checked when we installed, no need to check each boot */
+		if (crosscheck_zonepaths(rpath) != Z_OK)
+			return (Z_ERR);
+	}
 	/*
 	 * Try to collect and report as many minor errors as possible
 	 * before returning, so the user can learn everything that needs
@@ -1201,6 +1103,7 @@
 ready_func(int argc, char *argv[])
 {
 	zone_cmd_arg_t zarg;
+	boolean_t debug = B_FALSE;
 	int arg;
 
 	if (zonecfg_in_alt_root()) {
@@ -1209,11 +1112,14 @@
 	}
 
 	optind = 0;
-	if ((arg = getopt(argc, argv, "?")) != EOF) {
+	if ((arg = getopt(argc, argv, "?X")) != EOF) {
 		switch (arg) {
 		case '?':
 			sub_usage(SHELP_READY, CMD_READY);
 			return (optopt == '?' ? Z_OK : Z_USAGE);
+		case 'X':
+			debug = B_TRUE;
+			break;
 		default:
 			sub_usage(SHELP_READY, CMD_READY);
 			return (Z_USAGE);
@@ -1230,6 +1136,7 @@
 		return (Z_ERR);
 
 	zarg.cmd = Z_READY;
+	zarg.debug = debug;
 	if (zonecfg_call_zoneadmd(target_zone, &zarg, locale, B_TRUE) != 0) {
 		zerror(gettext("call to %s failed"), "zoneadmd");
 		return (Z_ERR);
@@ -1242,6 +1149,7 @@
 {
 	zone_cmd_arg_t zarg;
 	boolean_t force = B_FALSE;
+	boolean_t debug = B_FALSE;
 	int arg;
 
 	if (zonecfg_in_alt_root()) {
@@ -1268,7 +1176,7 @@
 	 *	zoneadm -z myzone boot -- -s -v -m verbose.
 	 */
 	optind = 0;
-	while ((arg = getopt(argc, argv, "?fs")) != EOF) {
+	while ((arg = getopt(argc, argv, "?fsX")) != EOF) {
 		switch (arg) {
 		case '?':
 			sub_usage(SHELP_BOOT, CMD_BOOT);
@@ -1280,6 +1188,9 @@
 		case 'f':
 			force = B_TRUE;
 			break;
+		case 'X':
+			debug = B_TRUE;
+			break;
 		default:
 			sub_usage(SHELP_BOOT, CMD_BOOT);
 			return (Z_USAGE);
@@ -1305,6 +1216,7 @@
 	if (verify_details(CMD_BOOT, argv) != Z_OK)
 		return (Z_ERR);
 	zarg.cmd = force ? Z_FORCEBOOT : Z_BOOT;
+	zarg.debug = debug;
 	if (zonecfg_call_zoneadmd(target_zone, &zarg, locale, B_TRUE) != 0) {
 		zerror(gettext("call to %s failed"), "zoneadmd");
 		return (Z_ERR);
@@ -1614,10 +1526,10 @@
  *     not already running (or ready).
  */
 static int
-sanity_check(char *zone, int cmd_num, boolean_t running,
+sanity_check(char *zone, int cmd_num, boolean_t need_running,
     boolean_t unsafe_when_running, boolean_t force)
 {
-	zone_entry_t *zent;
+	boolean_t is_running = B_FALSE;
 	priv_set_t *privset;
 	zone_state_t state, min_state;
 	char kernzone[ZONENAME_MAX];
@@ -1688,15 +1600,15 @@
 	}
 
 	if (!zonecfg_in_alt_root()) {
-		zent = lookup_running_zone(zone);
-	} else if ((fp = zonecfg_open_scratch("", B_FALSE)) == NULL) {
-		zent = NULL;
-	} else {
-		if (zonecfg_find_scratch(fp, zone, zonecfg_get_root(),
-		    kernzone, sizeof (kernzone)) == 0)
-			zent = lookup_running_zone(kernzone);
-		else
-			zent = NULL;
+		/* Avoid the xml read overhead of lookup_running_zone */
+		if (getzoneidbyname(zone) != -1)
+			is_running = B_TRUE;
+
+	} else if ((fp = zonecfg_open_scratch("", B_FALSE)) != NULL) {
+		if (zonecfg_find_scratch(fp, zone, zonecfg_get_root(), kernzone,
+		    sizeof (kernzone)) == 0 && getzoneidbyname(kernzone) != -1)
+			is_running = B_TRUE;
+
 		zonecfg_close_scratch(fp);
 	}
 
@@ -1703,8 +1615,8 @@
 	/*
 	 * Look up from the kernel for 'running' zones.
 	 */
-	if (running && !force) {
-		if (zent == NULL) {
+	if (need_running && !force) {
+		if (!is_running) {
 			zerror(gettext("not running"));
 			return (Z_ERR);
 		}
@@ -1711,28 +1623,31 @@
 	} else {
 		int err;
 
-		if (unsafe_when_running && zent != NULL) {
+		err = zone_get_state(zone, &state);
+
+		if (unsafe_when_running && is_running) {
 			/* check whether the zone is ready or running */
-			if ((err = zone_get_state(zent->zname,
-			    &zent->zstate_num)) != Z_OK) {
+			char *zstate_str;
+
+			if (err != Z_OK) {
 				errno = err;
-				zperror2(zent->zname,
-				    gettext("could not get state"));
+				zperror2(zone, gettext("could not get state"));
 				/* can't tell, so hedge */
-				zent->zstate_str = "ready/running";
+				zstate_str = "ready/running";
 			} else {
-				zent->zstate_str =
-				    zone_state_str(zent->zstate_num);
+				zstate_str = zone_state_str(state);
 			}
 			zerror(gettext("%s operation is invalid for %s zones."),
-			    cmd_to_str(cmd_num), zent->zstate_str);
+			    cmd_to_str(cmd_num), zstate_str);
 			return (Z_ERR);
 		}
-		if ((err = zone_get_state(zone, &state)) != Z_OK) {
+
+		if (err != Z_OK) {
 			errno = err;
 			zperror2(zone, gettext("could not get state"));
 			return (Z_ERR);
 		}
+
 		switch (cmd_num) {
 		case CMD_UNINSTALL:
 			if (state == ZONE_STATE_CONFIGURED) {
@@ -1820,6 +1735,7 @@
 halt_func(int argc, char *argv[])
 {
 	zone_cmd_arg_t zarg;
+	boolean_t debug = B_FALSE;
 	int arg;
 
 	if (zonecfg_in_alt_root()) {
@@ -1828,11 +1744,14 @@
 	}
 
 	optind = 0;
-	if ((arg = getopt(argc, argv, "?")) != EOF) {
+	if ((arg = getopt(argc, argv, "?X")) != EOF) {
 		switch (arg) {
 		case '?':
 			sub_usage(SHELP_HALT, CMD_HALT);
 			return (optopt == '?' ? Z_OK : Z_USAGE);
+		case 'X':
+			debug = B_TRUE;
+			break;
 		default:
 			sub_usage(SHELP_HALT, CMD_HALT);
 			return (Z_USAGE);
@@ -1858,6 +1777,7 @@
 		return (Z_ERR);
 
 	zarg.cmd = Z_HALT;
+	zarg.debug = debug;
 	return ((zonecfg_call_zoneadmd(target_zone, &zarg, locale,
 	    B_TRUE) == 0) ?  Z_OK : Z_ERR);
 }
@@ -1935,6 +1855,7 @@
 reboot_func(int argc, char *argv[])
 {
 	zone_cmd_arg_t zarg;
+	boolean_t debug = B_FALSE;
 	int arg;
 
 	if (zonecfg_in_alt_root()) {
@@ -1943,11 +1864,14 @@
 	}
 
 	optind = 0;
-	if ((arg = getopt(argc, argv, "?")) != EOF) {
+	if ((arg = getopt(argc, argv, "?X")) != EOF) {
 		switch (arg) {
 		case '?':
 			sub_usage(SHELP_REBOOT, CMD_REBOOT);
 			return (optopt == '?' ? Z_OK : Z_USAGE);
+		case 'X':
+			debug = B_TRUE;
+			break;
 		default:
 			sub_usage(SHELP_REBOOT, CMD_REBOOT);
 			return (Z_USAGE);
@@ -1982,6 +1906,7 @@
 		return (Z_ERR);
 
 	zarg.cmd = Z_REBOOT;
+	zarg.debug = debug;
 	return ((zonecfg_call_zoneadmd(target_zone, &zarg, locale, B_TRUE) == 0)
 	    ? Z_OK : Z_ERR);
 }
@@ -2209,6 +2134,10 @@
 	if (strcmp(fstab->zone_fs_type, MNTTYPE_ZFS) == 0)
 		return (verify_fs_zfs(fstab));
 
+	if (strcmp(fstab->zone_fs_type, MNTTYPE_HYPRLOFS) == 0 &&
+	    strcmp(fstab->zone_fs_special, "swap") == 0)
+			return (Z_OK);
+
 	if (stat64(fstab->zone_fs_special, &st) != 0) {
 		(void) fprintf(stderr, gettext("could not verify fs "
 		    "%s: could not access %s: %s\n"), fstab->zone_fs_dir,
@@ -2612,7 +2541,6 @@
 	dladm_handle_t dh;
 	dladm_status_t status;
 	datalink_id_t linkid;
-	char errmsg[DLADM_STRSIZE];
 
 	in_alt_root = zonecfg_in_alt_root();
 	if (in_alt_root)
@@ -2695,11 +2623,6 @@
 				dladm_close(dh);
 			}
 			if (status != DLADM_STATUS_OK) {
-				(void) fprintf(stderr,
-				    gettext("WARNING: skipping network "
-				    "interface '%s': %s\n"),
-				    nwiftab.zone_nwif_physical,
-				    dladm_status2str(status, errmsg));
 				break;
 			}
 			dl_owner_zid = ALL_ZONES;
@@ -2783,6 +2706,74 @@
 	return (return_code);
 }
 
+/*
+ * Called when readying or booting a zone.  We double check that the zone's
+ * debug ID is set and is unique.  This covers the case of pre-existing zones
+ * with no ID.  Also, its possible that a zone was migrated to this host
+ * and as a result it has a duplicate ID.  In this case we preserve the ID
+ * of the first zone we match on in the index file (since it was there before
+ * the current zone) and we assign a new unique ID to the current zone.
+ * Return true if we assigned a new ID, indicating that the zone configuration
+ * needs to be saved.
+ */
+static boolean_t
+verify_fix_did(zone_dochandle_t handle)
+{
+	zoneid_t mydid;
+	struct zoneent *ze;
+	FILE *cookie;
+	boolean_t fix = B_FALSE;
+
+	mydid = zonecfg_get_did(handle);
+	if (mydid == -1) {
+		zonecfg_set_did(handle);
+		return (B_TRUE);
+	}
+
+	/* Get the full list of zones from the configuration. */
+	cookie = setzoneent();
+	while ((ze = getzoneent_private(cookie)) != NULL) {
+		char *name;
+		zoneid_t did;
+
+		name = ze->zone_name;
+		if (strcmp(name, GLOBAL_ZONENAME) == 0 ||
+		    strcmp(name, target_zone) == 0) {
+			free(ze);
+			continue;
+		}
+
+		if (ze->zone_brand[0] == '\0') {
+			/* old, incomplete index entry */
+			zone_entry_t zent;
+
+			if (lookup_zone_info(name, ZONE_ID_UNDEFINED,
+			    &zent) != Z_OK) {
+				free(ze);
+				continue;
+			}
+			did = zent.zdid;
+		} else {
+			/* new, full index entry */
+			did = ze->zone_did;
+		}
+		free(ze);
+
+		if (did == mydid) {
+			fix = B_TRUE;
+			break;
+		}
+	}
+	endzoneent(cookie);
+
+	if (fix) {
+		zonecfg_set_did(handle);
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
 static int
 verify_details(int cmd_num, char *argv[])
 {
@@ -2842,6 +2833,18 @@
 	if (verify_handle(cmd_num, handle, argv) != Z_OK)
 		return_code = Z_ERR;
 
+	if (cmd_num == CMD_READY || cmd_num == CMD_BOOT) {
+		int vcommit = 0, obscommit = 0;
+
+		vcommit = verify_fix_did(handle);
+		obscommit = zonecfg_fix_obsolete(handle);
+
+		if (vcommit || obscommit)
+			if (zonecfg_save(handle) != Z_OK)
+				(void) fprintf(stderr, gettext("Could not save "
+				    "updated configuration.\n"));
+	}
+
 	zonecfg_fini_handle(handle);
 	if (return_code == Z_ERR)
 		(void) fprintf(stderr,
@@ -2927,6 +2930,7 @@
 	int status;
 	boolean_t do_postinstall = B_FALSE;
 	boolean_t brand_help = B_FALSE;
+	boolean_t do_dataset = B_TRUE;
 	char opts[128];
 
 	if (target_zone == NULL) {
@@ -3002,6 +3006,12 @@
 			}
 			/* Ignore unknown options - may be brand specific. */
 			break;
+		case 'x':
+			if (strcmp(optarg, "nodataset") == 0) {
+				do_dataset = B_FALSE;
+				continue; /* internal arg, don't pass thru */
+			}
+			break;
 		default:
 			/* Ignore unknown options - may be brand specific. */
 			break;
@@ -3054,7 +3064,8 @@
 			goto done;
 		}
 
-		create_zfs_zonepath(zonepath);
+		if (do_dataset)
+			create_zfs_zonepath(zonepath);
 	}
 
 	status = do_subproc(cmdbuf);
@@ -3865,10 +3876,10 @@
 			 * exist if the zone was force-attached after a
 			 * migration.
 			 */
-	char		*std_entries[] = {"dev", "lu", "root",
-			    "SUNWattached.xml", NULL};
-			/* (MAXPATHLEN * 3) is for the 3 std_entries dirs */
-	char		cmdbuf[sizeof (RMCOMMAND) + (MAXPATHLEN * 3) + 64];
+	char		*std_entries[] = {"dev", "lastexited", "logs", "lu",
+			    "root", "SUNWattached.xml", NULL};
+			/* (MAXPATHLEN * 5) is for the 5 std_entries dirs */
+	char		cmdbuf[sizeof (RMCOMMAND) + (MAXPATHLEN * 5) + 64];
 
 	/*
 	 * We shouldn't need these checks but lets be paranoid since we
@@ -5018,6 +5029,7 @@
 		if (zonecfg_ping_zoneadmd(target_zone) == Z_OK) {
 			zone_cmd_arg_t zarg;
 			zarg.cmd = Z_NOTE_UNINSTALLING;
+			zarg.debug = B_FALSE;
 			/* we don't care too much if this fails, just plow on */
 			(void) zonecfg_call_zoneadmd(target_zone, &zarg, locale,
 			    B_TRUE);
@@ -5133,6 +5145,7 @@
 		return (Z_ERR);
 
 	zarg.cmd = force ? Z_FORCEMOUNT : Z_MOUNT;
+	zarg.debug = B_FALSE;
 	zarg.bootbuf[0] = '\0';
 	if (zonecfg_call_zoneadmd(target_zone, &zarg, locale, B_TRUE) != 0) {
 		zerror(gettext("call to %s failed"), "zoneadmd");
@@ -5154,6 +5167,7 @@
 		return (Z_ERR);
 
 	zarg.cmd = Z_UNMOUNT;
+	zarg.debug = B_FALSE;
 	if (zonecfg_call_zoneadmd(target_zone, &zarg, locale, B_TRUE) != 0) {
 		zerror(gettext("call to %s failed"), "zoneadmd");
 		return (Z_ERR);
@@ -5375,7 +5389,7 @@
 	priv_set_t *privset;
 	zoneid_t zoneid;
 	zone_dochandle_t handle;
-	struct zone_mcaptab mcap;
+	uint64_t mcap;
 	char pool_err[128];
 
 	zoneid = getzoneid();
@@ -5466,19 +5480,12 @@
 	}
 
 	/*
-	 * If a memory cap is configured, set the cap in the kernel using
-	 * zone_setattr() and make sure the rcapd SMF service is enabled.
+	 * If a memory cap is configured, make sure the rcapd SMF service is
+	 * enabled.
 	 */
-	if (zonecfg_getmcapent(handle, &mcap) == Z_OK) {
-		uint64_t num;
+	if (zonecfg_get_aliased_rctl(handle, ALIAS_MAXPHYSMEM, &mcap) == Z_OK) {
 		char smf_err[128];
 
-		num = (uint64_t)strtoll(mcap.zone_physmem_cap, NULL, 10);
-		if (zone_setattr(zoneid, ZONE_ATTR_PHYS_MCAP, &num, 0) == -1) {
-			zerror(gettext("could not set zone memory cap"));
-			res = Z_ERR;
-		}
-
 		if (zonecfg_enable_rcapd(smf_err, sizeof (smf_err)) != Z_OK) {
 			zerror(gettext("enabling system/rcap service failed: "
 			    "%s"), smf_err);
usr/src/cmd/zoneadmd/Makefile.com
usr/src/cmd/zoneadmd/mcap.c
usr/src/cmd/zoneadmd/vplat.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/zoneadmd/vplat.c	Mon Oct 19 10:48:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/zoneadmd/vplat.c	Mon Dec 14 10:47:45 2015
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2013, Joyent Inc. All rights reserved.
+ * Copyright 2015, Joyent Inc. All rights reserved.
  * Copyright (c) 2015 by Delphix. All rights reserved.
  */
 
@@ -138,6 +138,9 @@
 
 #define	ALT_MOUNT(mount_cmd) 	((mount_cmd) != Z_MNT_BOOT)
 
+/* Number of times to retry unmounting if it fails */
+#define	UMOUNT_RETRIES	30
+
 /* a reasonable estimate for the number of lwps per process */
 #define	LWPS_PER_PROCESS	10
 
@@ -161,11 +164,25 @@
 
 static const char *DFLT_FS_ALLOWED = "hsfs,smbfs,nfs,nfs3,nfs4,nfsdyn";
 
+typedef struct zone_proj_rctl_map {
+	char *zpr_zone_rctl;
+	char *zpr_project_rctl;
+} zone_proj_rctl_map_t;
+
+static zone_proj_rctl_map_t zone_proj_rctl_map[] = {
+	{"zone.max-msg-ids",	"project.max-msg-ids"},
+	{"zone.max-sem-ids",	"project.max-sem-ids"},
+	{"zone.max-shm-ids",	"project.max-shm-ids"},
+	{"zone.max-shm-memory",	"project.max-shm-memory"},
+	{NULL,			NULL}
+};
+
 /* from libsocket, not in any header file */
 extern int getnetmaskbyaddr(struct in_addr, struct in_addr *);
 
 /* from zoneadmd */
 extern char query_hook[];
+extern char post_statechg_hook[];
 
 /*
  * For each "net" resource configured in zonecfg, we track a zone_addr_list_t
@@ -202,7 +219,7 @@
 	/*
 	 * Ask autofs to unmount all trigger nodes in the given zone.
 	 */
-	return (_autofssys(AUTOFS_UNMOUNTALL, (void *)zoneid));
+	return (_autofssys(AUTOFS_UNMOUNTALL, (void *)((uintptr_t)zoneid)));
 }
 
 static void
@@ -593,6 +610,24 @@
 }
 
 /*
+ * Perform brand-specific cleanup if we are unable to unmount a FS.
+ */
+static void
+brand_umount_cleanup(zlog_t *zlogp, char *path)
+{
+	char cmdbuf[2 * MAXPATHLEN];
+
+	if (post_statechg_hook[0] == '\0')
+		return;
+
+	if (snprintf(cmdbuf, sizeof (cmdbuf), "%s %d %d %s", post_statechg_hook,
+	    ZONE_STATE_DOWN, Z_UNMOUNT, path) > sizeof (cmdbuf))
+		return;
+
+	(void) do_subproc(zlogp, cmdbuf, NULL, B_FALSE);
+}
+
+/*
  * The general strategy for unmounting filesystems is as follows:
  *
  * - Remote filesystems may be dead, and attempting to contact them as
@@ -625,6 +660,7 @@
 unmount_filesystems(zlog_t *zlogp, zoneid_t zoneid, boolean_t unmount_cmd)
 {
 	int error = 0;
+	int fail = 0;
 	FILE *mnttab;
 	struct mnttab *mnts;
 	uint_t nmnt;
@@ -712,18 +748,39 @@
 				if (umount2(path, MS_FORCE) == 0) {
 					unmounted = B_TRUE;
 					stuck = B_FALSE;
+					fail = 0;
 				} else {
 					/*
-					 * The first failure indicates a
-					 * mount we won't be able to get
-					 * rid of automatically, so we
-					 * bail.
+					 * We may hit a failure here if there
+					 * is an app in the GZ with an open
+					 * pipe into the zone (commonly into
+					 * the zone's /var/run).  This type
+					 * of app will notice the closed
+					 * connection and cleanup, but it may
+					 * take a while and we have no easy
+					 * way to notice that.  To deal with
+					 * this case, we will wait and retry
+					 * a few times before we give up.
 					 */
-					error++;
-					zerror(zlogp, B_FALSE,
-					    "unable to unmount '%s'", path);
-					free_mnttable(mnts, nmnt);
-					goto out;
+					fail++;
+					if (fail < (UMOUNT_RETRIES - 1)) {
+						zerror(zlogp, B_FALSE,
+						    "unable to unmount '%s', "
+						    "retrying in 2 seconds",
+						    path);
+						(void) sleep(2);
+					} else if (fail > UMOUNT_RETRIES) {
+						error++;
+						zerror(zlogp, B_FALSE,
+						    "unmount of '%s' failed",
+						    path);
+						free_mnttable(mnts, nmnt);
+						goto out;
+					} else {
+						/* Try the hook 2 times */
+						brand_umount_cleanup(zlogp,
+						    path);
+					}
 				}
 			}
 			/*
@@ -1061,23 +1118,10 @@
 int
 vplat_get_iptype(zlog_t *zlogp, zone_iptype_t *iptypep)
 {
-	zone_dochandle_t handle;
-
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-	if (zonecfg_get_iptype(handle, iptypep) != Z_OK) {
+	if (zonecfg_get_iptype(snap_hndl, iptypep) != Z_OK) {
 		zerror(zlogp, B_FALSE, "invalid ip-type configuration");
-		zonecfg_fini_handle(handle);
 		return (-1);
 	}
-	zonecfg_fini_handle(handle);
 	return (0);
 }
 
@@ -1090,7 +1134,6 @@
 mount_one_dev(zlog_t *zlogp, char *devpath, zone_mnt_t mount_cmd)
 {
 	char			brand[MAXNAMELEN];
-	zone_dochandle_t	handle = NULL;
 	brand_handle_t		bh = NULL;
 	struct zone_devtab	ztab;
 	di_prof_t		prof = NULL;
@@ -1097,7 +1140,7 @@
 	int			err;
 	int			retval = -1;
 	zone_iptype_t		iptype;
-	const char 		*curr_iptype;
+	const char 		*curr_iptype = NULL;
 
 	if (di_prof_init(devpath, &prof)) {
 		zerror(zlogp, B_TRUE, "failed to initialize profile");
@@ -1132,6 +1175,8 @@
 		curr_iptype = "exclusive";
 		break;
 	}
+	if (curr_iptype == NULL)
+		abort();
 
 	if (brand_platform_iter_devices(bh, zone_name,
 	    mount_one_dev_device_cb, prof, curr_iptype) != 0) {
@@ -1146,21 +1191,12 @@
 	}
 
 	/* Add user-specified devices and directories */
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_FALSE, "can't initialize zone handle");
-		goto cleanup;
-	}
-	if (err = zonecfg_get_handle(zone_name, handle)) {
-		zerror(zlogp, B_FALSE, "can't get handle for zone "
-		    "%s: %s", zone_name, zonecfg_strerror(err));
-		goto cleanup;
-	}
-	if (err = zonecfg_setdevent(handle)) {
+	if ((err = zonecfg_setdevent(snap_hndl)) != 0) {
 		zerror(zlogp, B_FALSE, "%s: %s", zone_name,
 		    zonecfg_strerror(err));
 		goto cleanup;
 	}
-	while (zonecfg_getdevent(handle, &ztab) == Z_OK) {
+	while (zonecfg_getdevent(snap_hndl, &ztab) == Z_OK) {
 		if (di_prof_add_dev(prof, ztab.zone_dev_match)) {
 			zerror(zlogp, B_TRUE, "failed to add "
 			    "user-specified device");
@@ -1167,7 +1203,7 @@
 			goto cleanup;
 		}
 	}
-	(void) zonecfg_enddevent(handle);
+	(void) zonecfg_enddevent(snap_hndl);
 
 	/* Send profile to kernel */
 	if (di_prof_commit(prof)) {
@@ -1180,8 +1216,6 @@
 cleanup:
 	if (bh != NULL)
 		brand_close(bh);
-	if (handle != NULL)
-		zonecfg_fini_handle(handle);
 	if (prof)
 		di_prof_fini(prof);
 	return (retval);
@@ -1671,12 +1705,10 @@
 mount_filesystems(zlog_t *zlogp, zone_mnt_t mount_cmd)
 {
 	char rootpath[MAXPATHLEN];
-	char zonepath[MAXPATHLEN];
 	char brand[MAXNAMELEN];
 	char luroot[MAXPATHLEN];
 	int i, num_fs = 0;
 	struct zone_fstab *fs_ptr = NULL;
-	zone_dochandle_t handle = NULL;
 	zone_state_t zstate;
 	brand_handle_t bh;
 	plat_gmount_cb_data_t cb;
@@ -1690,22 +1722,12 @@
 		goto bad;
 	}
 
-	if (zone_get_zonepath(zone_name, zonepath, sizeof (zonepath)) != Z_OK) {
-		zerror(zlogp, B_TRUE, "unable to determine zone path");
-		goto bad;
-	}
-
 	if (zone_get_rootpath(zone_name, rootpath, sizeof (rootpath)) != Z_OK) {
 		zerror(zlogp, B_TRUE, "unable to determine zone root");
 		goto bad;
 	}
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		goto bad;
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK ||
-	    zonecfg_setfsent(handle) != Z_OK) {
+	if (zonecfg_setfsent(snap_hndl) != Z_OK) {
 		zerror(zlogp, B_FALSE, "invalid configuration");
 		goto bad;
 	}
@@ -1723,7 +1745,6 @@
 	/* Get a handle to the brand info for this zone */
 	if ((bh = brand_open(brand)) == NULL) {
 		zerror(zlogp, B_FALSE, "unable to determine zone brand");
-		zonecfg_fini_handle(handle);
 		return (-1);
 	}
 
@@ -1734,11 +1755,10 @@
 	cb.pgcd_zlogp = zlogp;
 	cb.pgcd_fs_tab = &fs_ptr;
 	cb.pgcd_num_fs = &num_fs;
-	if (brand_platform_iter_gmounts(bh, zonepath,
+	if (brand_platform_iter_gmounts(bh, zone_name, zonepath,
 	    plat_gmount_cb, &cb) != 0) {
 		zerror(zlogp, B_FALSE, "unable to mount filesystems");
 		brand_close(bh);
-		zonecfg_fini_handle(handle);
 		return (-1);
 	}
 	brand_close(bh);
@@ -1749,13 +1769,10 @@
 	 * higher level directories (e.g., /usr) get mounted before
 	 * any beneath them (e.g., /usr/local).
 	 */
-	if (mount_filesystems_fsent(handle, zlogp, &fs_ptr, &num_fs,
+	if (mount_filesystems_fsent(snap_hndl, zlogp, &fs_ptr, &num_fs,
 	    mount_cmd) != 0)
 		goto bad;
 
-	zonecfg_fini_handle(handle);
-	handle = NULL;
-
 	/*
 	 * Normally when we mount a zone all the zone filesystems
 	 * get mounted relative to rootpath, which is usually
@@ -1834,8 +1851,6 @@
 	return (0);
 
 bad:
-	if (handle != NULL)
-		zonecfg_fini_handle(handle);
 	free_fs_data(fs_ptr, num_fs);
 	return (-1);
 }
@@ -2191,13 +2206,7 @@
 	if (ioctl(s, SIOCLIFADDIF, (caddr_t)&lifr) < 0) {
 		/*
 		 * Here, we know that the interface can't be brought up.
-		 * A similar warning message was already printed out to
-		 * the console by zoneadm(1M) so instead we log the
-		 * message to syslog and continue.
 		 */
-		zerror(&logsys, B_TRUE, "WARNING: skipping network interface "
-		    "'%s' which may not be present/plumbed in the "
-		    "global zone.", lifr.lifr_name);
 		(void) close(s);
 		return (Z_OK);
 	}
@@ -2410,7 +2419,6 @@
 static int
 configure_shared_network_interfaces(zlog_t *zlogp)
 {
-	zone_dochandle_t handle;
 	struct zone_nwiftab nwiftab, loopback_iftab;
 	zoneid_t zoneid;
 
@@ -2419,29 +2427,19 @@
 		return (-1);
 	}
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-	if (zonecfg_setnwifent(handle) == Z_OK) {
+	if (zonecfg_setnwifent(snap_hndl) == Z_OK) {
 		for (;;) {
-			if (zonecfg_getnwifent(handle, &nwiftab) != Z_OK)
+			if (zonecfg_getnwifent(snap_hndl, &nwiftab) != Z_OK)
 				break;
+			nwifent_free_attrs(&nwiftab);
 			if (configure_one_interface(zlogp, zoneid, &nwiftab) !=
 			    Z_OK) {
-				(void) zonecfg_endnwifent(handle);
-				zonecfg_fini_handle(handle);
+				(void) zonecfg_endnwifent(snap_hndl);
 				return (-1);
 			}
 		}
-		(void) zonecfg_endnwifent(handle);
+		(void) zonecfg_endnwifent(snap_hndl);
 	}
-	zonecfg_fini_handle(handle);
 	if (is_system_labeled()) {
 		/*
 		 * Labeled zones share the loopback interface
@@ -2895,7 +2893,6 @@
 static int
 configure_exclusive_network_interfaces(zlog_t *zlogp, zoneid_t zoneid)
 {
-	zone_dochandle_t handle;
 	struct zone_nwiftab nwiftab;
 	char rootpath[MAXPATHLEN];
 	char path[MAXPATHLEN];
@@ -2904,30 +2901,18 @@
 	boolean_t added = B_FALSE;
 	zone_addr_list_t *zalist = NULL, *new;
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-
-	if (zonecfg_setnwifent(handle) != Z_OK) {
-		zonecfg_fini_handle(handle);
+	if (zonecfg_setnwifent(snap_hndl) != Z_OK)
 		return (0);
-	}
 
 	for (;;) {
-		if (zonecfg_getnwifent(handle, &nwiftab) != Z_OK)
+		if (zonecfg_getnwifent(snap_hndl, &nwiftab) != Z_OK)
 			break;
 
+		nwifent_free_attrs(&nwiftab);
 		if (prof == NULL) {
 			if (zone_get_devroot(zone_name, rootpath,
 			    sizeof (rootpath)) != Z_OK) {
-				(void) zonecfg_endnwifent(handle);
-				zonecfg_fini_handle(handle);
+				(void) zonecfg_endnwifent(snap_hndl);
 				zerror(zlogp, B_TRUE,
 				    "unable to determine dev root");
 				return (-1);
@@ -2935,8 +2920,7 @@
 			(void) snprintf(path, sizeof (path), "%s%s", rootpath,
 			    "/dev");
 			if (di_prof_init(path, &prof) != 0) {
-				(void) zonecfg_endnwifent(handle);
-				zonecfg_fini_handle(handle);
+				(void) zonecfg_endnwifent(snap_hndl);
 				zerror(zlogp, B_TRUE,
 				    "failed to initialize profile");
 				return (-1);
@@ -2960,10 +2944,11 @@
 		    nwiftab.zone_nwif_physical) == 0) {
 			added = B_TRUE;
 		} else {
-			(void) zonecfg_endnwifent(handle);
-			zonecfg_fini_handle(handle);
-			zerror(zlogp, B_TRUE, "failed to add network device");
-			return (-1);
+			/*
+			 * Failed to add network device, but the brand hook
+			 * might be doing this for us, so keep silent.
+			 */
+			continue;
 		}
 		/* set up the new IP interface, and add them all later */
 		new = malloc(sizeof (*new));
@@ -2970,7 +2955,6 @@
 		if (new == NULL) {
 			zerror(zlogp, B_TRUE, "no memory for %s",
 			    nwiftab.zone_nwif_physical);
-			zonecfg_fini_handle(handle);
 			free_ip_interface(zalist);
 		}
 		bzero(new, sizeof (*new));
@@ -2980,8 +2964,7 @@
 	}
 	if (zalist != NULL) {
 		if ((errno = add_net(zlogp, zoneid, zalist)) != 0) {
-			(void) zonecfg_endnwifent(handle);
-			zonecfg_fini_handle(handle);
+			(void) zonecfg_endnwifent(snap_hndl);
 			zerror(zlogp, B_TRUE, "failed to add address");
 			free_ip_interface(zalist);
 			return (-1);
@@ -2988,8 +2971,7 @@
 		}
 		free_ip_interface(zalist);
 	}
-	(void) zonecfg_endnwifent(handle);
-	zonecfg_fini_handle(handle);
+	(void) zonecfg_endnwifent(snap_hndl);
 
 	if (prof != NULL && added) {
 		if (di_prof_commit(prof) != 0) {
@@ -3125,20 +3107,17 @@
 			/* datalink does not belong to the GZ */
 			continue;
 		}
-		if (dlstatus != DLADM_STATUS_OK) {
+		if (dlstatus != DLADM_STATUS_OK)
 			zerror(zlogp, B_FALSE,
+			    "clear 'protection' link property: %s",
 			    dladm_status2str(dlstatus, dlerr));
-			free(dllinks);
-			return (-1);
-		}
+
 		dlstatus = dladm_set_linkprop(dld_handle, *dllink,
 		    "allowed-ips", NULL, 0, DLADM_OPT_ACTIVE);
-		if (dlstatus != DLADM_STATUS_OK) {
+		if (dlstatus != DLADM_STATUS_OK)
 			zerror(zlogp, B_FALSE,
+			    "clear 'allowed-ips' link property: %s",
 			    dladm_status2str(dlstatus, dlerr));
-			free(dllinks);
-			return (-1);
-		}
 	}
 	free(dllinks);
 	return (0);
@@ -3145,28 +3124,6 @@
 }
 
 static int
-unconfigure_exclusive_network_interfaces(zlog_t *zlogp, zoneid_t zoneid)
-{
-	int dlnum = 0;
-
-	/*
-	 * The kernel shutdown callback for the dls module should have removed
-	 * all datalinks from this zone.  If any remain, then there's a
-	 * problem.
-	 */
-	if (zone_list_datalink(zoneid, &dlnum, NULL) != 0) {
-		zerror(zlogp, B_TRUE, "unable to list network interfaces");
-		return (-1);
-	}
-	if (dlnum != 0) {
-		zerror(zlogp, B_FALSE,
-		    "datalinks remain in zone after shutdown");
-		return (-1);
-	}
-	return (0);
-}
-
-static int
 tcp_abort_conn(zlog_t *zlogp, zoneid_t zoneid,
     const struct sockaddr_storage *local, const struct sockaddr_storage *remote)
 {
@@ -3248,26 +3205,14 @@
 get_privset(zlog_t *zlogp, priv_set_t *privs, zone_mnt_t mount_cmd)
 {
 	int error = -1;
-	zone_dochandle_t handle;
 	char *privname = NULL;
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-
 	if (ALT_MOUNT(mount_cmd)) {
 		zone_iptype_t	iptype;
-		const char	*curr_iptype;
+		const char	*curr_iptype = NULL;
 
-		if (zonecfg_get_iptype(handle, &iptype) != Z_OK) {
+		if (zonecfg_get_iptype(snap_hndl, &iptype) != Z_OK) {
 			zerror(zlogp, B_TRUE, "unable to determine ip-type");
-			zonecfg_fini_handle(handle);
 			return (-1);
 		}
 
@@ -3280,17 +3225,15 @@
 			break;
 		}
 
-		if (zonecfg_default_privset(privs, curr_iptype) == Z_OK) {
-			zonecfg_fini_handle(handle);
+		if (zonecfg_default_privset(privs, curr_iptype) == Z_OK)
 			return (0);
-		}
+
 		zerror(zlogp, B_FALSE,
 		    "failed to determine the zone's default privilege set");
-		zonecfg_fini_handle(handle);
 		return (-1);
 	}
 
-	switch (zonecfg_get_privset(handle, privs, &privname)) {
+	switch (zonecfg_get_privset(snap_hndl, privs, &privname)) {
 	case Z_OK:
 		error = 0;
 		break;
@@ -3313,10 +3256,22 @@
 	}
 
 	free(privname);
-	zonecfg_fini_handle(handle);
 	return (error);
 }
 
+static char *
+zone_proj_rctl(const char *name)
+{
+	int i;
+
+	for (i = 0; zone_proj_rctl_map[i].zpr_zone_rctl != NULL; i++) {
+		if (strcmp(name, zone_proj_rctl_map[i].zpr_zone_rctl) == 0) {
+			return (zone_proj_rctl_map[i].zpr_project_rctl);
+		}
+	}
+	return (NULL);
+}
+
 static int
 get_rctls(zlog_t *zlogp, char **bufp, size_t *bufsizep)
 {
@@ -3326,7 +3281,6 @@
 	nvlist_t **nvlv = NULL;
 	int rctlcount = 0;
 	int error = -1;
-	zone_dochandle_t handle;
 	struct zone_rctltab rctltab;
 	rctlblk_t *rctlblk = NULL;
 	uint64_t maxlwps;
@@ -3335,16 +3289,6 @@
 	*bufp = NULL;
 	*bufsizep = 0;
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-
 	rctltab.zone_rctl_valptr = NULL;
 	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0) {
 		zerror(zlogp, B_TRUE, "%s failed", "nvlist_alloc");
@@ -3357,11 +3301,11 @@
 	 * max-processes property.  If only the max-processes property is set,
 	 * we add a max-lwps property with a limit derived from max-processes.
 	 */
-	if (zonecfg_get_aliased_rctl(handle, ALIAS_MAXPROCS, &maxprocs)
+	if (zonecfg_get_aliased_rctl(snap_hndl, ALIAS_MAXPROCS, &maxprocs)
 	    == Z_OK &&
-	    zonecfg_get_aliased_rctl(handle, ALIAS_MAXLWPS, &maxlwps)
+	    zonecfg_get_aliased_rctl(snap_hndl, ALIAS_MAXLWPS, &maxlwps)
 	    == Z_NO_ENTRY) {
-		if (zonecfg_set_aliased_rctl(handle, ALIAS_MAXLWPS,
+		if (zonecfg_set_aliased_rctl(snap_hndl, ALIAS_MAXLWPS,
 		    maxprocs * LWPS_PER_PROCESS) != Z_OK) {
 			zerror(zlogp, B_FALSE, "unable to set max-lwps alias");
 			goto out;
@@ -3368,7 +3312,7 @@
 		}
 	}
 
-	if (zonecfg_setrctlent(handle) != Z_OK) {
+	if (zonecfg_setrctlent(snap_hndl) != Z_OK) {
 		zerror(zlogp, B_FALSE, "%s failed", "zonecfg_setrctlent");
 		goto out;
 	}
@@ -3377,10 +3321,11 @@
 		zerror(zlogp, B_TRUE, "memory allocation failed");
 		goto out;
 	}
-	while (zonecfg_getrctlent(handle, &rctltab) == Z_OK) {
+	while (zonecfg_getrctlent(snap_hndl, &rctltab) == Z_OK) {
 		struct zone_rctlvaltab *rctlval;
 		uint_t i, count;
 		const char *name = rctltab.zone_rctl_name;
+		char *proj_nm;
 
 		/* zoneadm should have already warned about unknown rctls. */
 		if (!zonecfg_is_rctl(name)) {
@@ -3447,6 +3392,26 @@
 		}
 		zonecfg_free_rctl_value_list(rctltab.zone_rctl_valptr);
 		rctltab.zone_rctl_valptr = NULL;
+
+		/*
+		 * With no action on our part we will start zsched with the
+		 * project rctl values for our (zoneadmd) current project. For
+		 * brands running a variant of Illumos, that's not a problem
+		 * since they will setup their own projects, but for a
+		 * non-native brand like lx, where there are no projects, we
+		 * want to start things up with the same project rctls as the
+		 * corresponding zone rctls, since nothing within the zone will
+		 * ever change the project rctls.
+		 */
+		if ((proj_nm = zone_proj_rctl(name)) != NULL) {
+			if (nvlist_add_nvlist_array(nvl, proj_nm, nvlv, count)
+			    != 0) {
+				zerror(zlogp, B_FALSE,
+				    "nvlist_add_nvlist_arrays failed");
+				goto out;
+			}
+		}
+
 		if (nvlist_add_nvlist_array(nvl, (char *)name, nvlv, count)
 		    != 0) {
 			zerror(zlogp, B_FALSE, "%s failed",
@@ -3459,7 +3424,7 @@
 		nvlv = NULL;
 		rctlcount++;
 	}
-	(void) zonecfg_endrctlent(handle);
+	(void) zonecfg_endrctlent(snap_hndl);
 
 	if (rctlcount == 0) {
 		error = 0;
@@ -3484,8 +3449,6 @@
 		nvlist_free(nvl);
 	if (nvlv != NULL)
 		free(nvlv);
-	if (handle != NULL)
-		zonecfg_fini_handle(handle);
 	return (error);
 }
 
@@ -3501,7 +3464,7 @@
 	    > sizeof (cmdbuf))
 		return (-1);
 
-	if (do_subproc(zlogp, cmdbuf, retstr) != 0)
+	if (do_subproc(zlogp, cmdbuf, retstr, B_FALSE) != 0)
 		return (-1);
 
 	return (0);
@@ -3510,7 +3473,6 @@
 static int
 get_datasets(zlog_t *zlogp, char **bufp, size_t *bufsizep)
 {
-	zone_dochandle_t handle;
 	struct zone_dstab dstab;
 	size_t total, offset, len;
 	int error = -1;
@@ -3521,30 +3483,20 @@
 	*bufp = NULL;
 	*bufsizep = 0;
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-
 	if (get_implicit_datasets(zlogp, &implicit_datasets) != 0) {
 		zerror(zlogp, B_FALSE, "getting implicit datasets failed");
 		goto out;
 	}
 
-	if (zonecfg_setdsent(handle) != Z_OK) {
+	if (zonecfg_setdsent(snap_hndl) != Z_OK) {
 		zerror(zlogp, B_FALSE, "%s failed", "zonecfg_setdsent");
 		goto out;
 	}
 
 	total = 0;
-	while (zonecfg_getdsent(handle, &dstab) == Z_OK)
+	while (zonecfg_getdsent(snap_hndl, &dstab) == Z_OK)
 		total += strlen(dstab.zone_dataset_name) + 1;
-	(void) zonecfg_enddsent(handle);
+	(void) zonecfg_enddsent(snap_hndl);
 
 	if (implicit_datasets != NULL)
 		implicit_len = strlen(implicit_datasets);
@@ -3561,12 +3513,12 @@
 		goto out;
 	}
 
-	if (zonecfg_setdsent(handle) != Z_OK) {
+	if (zonecfg_setdsent(snap_hndl) != Z_OK) {
 		zerror(zlogp, B_FALSE, "%s failed", "zonecfg_setdsent");
 		goto out;
 	}
 	offset = 0;
-	while (zonecfg_getdsent(handle, &dstab) == Z_OK) {
+	while (zonecfg_getdsent(snap_hndl, &dstab) == Z_OK) {
 		len = strlen(dstab.zone_dataset_name);
 		(void) strlcpy(str + offset, dstab.zone_dataset_name,
 		    total - offset);
@@ -3574,7 +3526,7 @@
 		if (offset < total - 1)
 			str[offset++] = ',';
 	}
-	(void) zonecfg_enddsent(handle);
+	(void) zonecfg_enddsent(snap_hndl);
 
 	if (implicit_len > 0)
 		(void) strlcpy(str + offset, implicit_datasets, total - offset);
@@ -3586,8 +3538,6 @@
 out:
 	if (error != 0 && str != NULL)
 		free(str);
-	if (handle != NULL)
-		zonecfg_fini_handle(handle);
 	if (implicit_datasets != NULL)
 		free(implicit_datasets);
 
@@ -3597,40 +3547,26 @@
 static int
 validate_datasets(zlog_t *zlogp)
 {
-	zone_dochandle_t handle;
 	struct zone_dstab dstab;
 	zfs_handle_t *zhp;
 	libzfs_handle_t *hdl;
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (-1);
-	}
-	if (zonecfg_get_snapshot_handle(zone_name, handle) != Z_OK) {
+	if (zonecfg_setdsent(snap_hndl) != Z_OK) {
 		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
 		return (-1);
 	}
 
-	if (zonecfg_setdsent(handle) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (-1);
-	}
-
 	if ((hdl = libzfs_init()) == NULL) {
 		zerror(zlogp, B_FALSE, "opening ZFS library");
-		zonecfg_fini_handle(handle);
 		return (-1);
 	}
 
-	while (zonecfg_getdsent(handle, &dstab) == Z_OK) {
+	while (zonecfg_getdsent(snap_hndl, &dstab) == Z_OK) {
 
 		if ((zhp = zfs_open(hdl, dstab.zone_dataset_name,
 		    ZFS_TYPE_FILESYSTEM)) == NULL) {
 			zerror(zlogp, B_FALSE, "cannot open ZFS dataset '%s'",
 			    dstab.zone_dataset_name);
-			zonecfg_fini_handle(handle);
 			libzfs_fini(hdl);
 			return (-1);
 		}
@@ -3645,7 +3581,6 @@
 			zerror(zlogp, B_FALSE, "cannot set 'zoned' "
 			    "property for ZFS dataset '%s'\n",
 			    dstab.zone_dataset_name);
-			zonecfg_fini_handle(handle);
 			zfs_close(zhp);
 			libzfs_fini(hdl);
 			return (-1);
@@ -3653,9 +3588,8 @@
 
 		zfs_close(zhp);
 	}
-	(void) zonecfg_enddsent(handle);
+	(void) zonecfg_enddsent(snap_hndl);
 
-	zonecfg_fini_handle(handle);
 	libzfs_fini(hdl);
 
 	return (0);
@@ -3709,17 +3643,11 @@
 	zfs_handle_t	*zhp;
 	libzfs_handle_t	*hdl;
 	m_label_t	ds_sl;
-	char		zonepath[MAXPATHLEN];
 	char		ds_hexsl[MAXNAMELEN];
 
 	if (!is_system_labeled())
 		return (0);
 
-	if (zone_get_zonepath(zone_name, zonepath, sizeof (zonepath)) != Z_OK) {
-		zerror(zlogp, B_TRUE, "unable to determine zone path");
-		return (-1);
-	}
-
 	if (!is_zonepath_zfs(zonepath))
 		return (0);
 
@@ -4390,8 +4318,7 @@
 }
 
 /*
- * Set memory cap and pool info for the zone's resource management
- * configuration.
+ * Set pool info for the zone's resource management configuration.
  */
 static int
 setup_zone_rm(zlog_t *zlogp, char *zone_name, zoneid_t zoneid)
@@ -4398,47 +4325,11 @@
 {
 	int res;
 	uint64_t tmp;
-	struct zone_mcaptab mcap;
 	char sched[MAXNAMELEN];
-	zone_dochandle_t handle = NULL;
 	char pool_err[128];
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (Z_BAD_HANDLE);
-	}
-
-	if ((res = zonecfg_get_snapshot_handle(zone_name, handle)) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
-		zonecfg_fini_handle(handle);
-		return (res);
-	}
-
-	/*
-	 * If a memory cap is configured, set the cap in the kernel using
-	 * zone_setattr() and make sure the rcapd SMF service is enabled.
-	 */
-	if (zonecfg_getmcapent(handle, &mcap) == Z_OK) {
-		uint64_t num;
-		char smf_err[128];
-
-		num = (uint64_t)strtoull(mcap.zone_physmem_cap, NULL, 10);
-		if (zone_setattr(zoneid, ZONE_ATTR_PHYS_MCAP, &num, 0) == -1) {
-			zerror(zlogp, B_TRUE, "could not set zone memory cap");
-			zonecfg_fini_handle(handle);
-			return (Z_INVAL);
-		}
-
-		if (zonecfg_enable_rcapd(smf_err, sizeof (smf_err)) != Z_OK) {
-			zerror(zlogp, B_FALSE, "enabling system/rcap service "
-			    "failed: %s", smf_err);
-			zonecfg_fini_handle(handle);
-			return (Z_INVAL);
-		}
-	}
-
 	/* Get the scheduling class set in the zone configuration. */
-	if (zonecfg_get_sched_class(handle, sched, sizeof (sched)) == Z_OK &&
+	if (zonecfg_get_sched_class(snap_hndl, sched, sizeof (sched)) == Z_OK &&
 	    strlen(sched) > 0) {
 		if (zone_setattr(zoneid, ZONE_ATTR_SCHED_CLASS, sched,
 		    strlen(sched)) == -1)
@@ -4445,7 +4336,34 @@
 			zerror(zlogp, B_TRUE, "WARNING: unable to set the "
 			    "default scheduling class");
 
-	} else if (zonecfg_get_aliased_rctl(handle, ALIAS_SHARES, &tmp)
+		if (strcmp(sched, "FX") == 0) {
+			/*
+			 * When FX is specified then by default all processes
+			 * will start at the lowest priority level (0) and
+			 * stay there. We support an optional attr which
+			 * indicates that all the processes should be "high
+			 * priority". We set this on the zone so that starting
+			 * init will set the priority high.
+			 */
+			struct zone_attrtab a;
+
+			bzero(&a, sizeof (a));
+			(void) strlcpy(a.zone_attr_name, "fixed-hi-prio",
+			    sizeof (a.zone_attr_name));
+
+			if (zonecfg_lookup_attr(snap_hndl, &a) == Z_OK &&
+			    strcmp(a.zone_attr_value, "true") == 0) {
+				boolean_t hi = B_TRUE;
+
+				if (zone_setattr(zoneid,
+				    ZONE_ATTR_SCHED_FIXEDHI, (void *)hi,
+				    sizeof (hi)) == -1)
+					zerror(zlogp, B_TRUE, "WARNING: unable "
+					    "to set high priority");
+			}
+		}
+
+	} else if (zonecfg_get_aliased_rctl(snap_hndl, ALIAS_SHARES, &tmp)
 	    == Z_OK) {
 		/*
 		 * If the zone has the zone.cpu-shares rctl set then we want to
@@ -4456,7 +4374,7 @@
 		 */
 		char class_name[PC_CLNMSZ];
 
-		if (zonecfg_get_dflt_sched_class(handle, class_name,
+		if (zonecfg_get_dflt_sched_class(snap_hndl, class_name,
 		    sizeof (class_name)) != Z_OK) {
 			zerror(zlogp, B_FALSE, "WARNING: unable to determine "
 			    "the zone's scheduling class");
@@ -4489,7 +4407,7 @@
 	 * right thing in all cases (reuse or create) based on the current
 	 * zonecfg.
 	 */
-	if ((res = zonecfg_bind_tmp_pool(handle, zoneid, pool_err,
+	if ((res = zonecfg_bind_tmp_pool(snap_hndl, zoneid, pool_err,
 	    sizeof (pool_err))) != Z_OK) {
 		if (res == Z_POOL || res == Z_POOL_CREATE || res == Z_POOL_BIND)
 			zerror(zlogp, B_FALSE, "%s: %s\ndedicated-cpu setting "
@@ -4498,7 +4416,6 @@
 		else
 			zerror(zlogp, B_FALSE, "could not bind zone to "
 			    "temporary pool: %s", zonecfg_strerror(res));
-		zonecfg_fini_handle(handle);
 		return (Z_POOL_BIND);
 	}
 
@@ -4505,7 +4422,7 @@
 	/*
 	 * Check if we need to warn about poold not being enabled.
 	 */
-	if (zonecfg_warn_poold(handle)) {
+	if (zonecfg_warn_poold(snap_hndl)) {
 		zerror(zlogp, B_FALSE, "WARNING: A range of dedicated-cpus has "
 		    "been specified\nbut the dynamic pool service is not "
 		    "enabled.\nThe system will not dynamically adjust the\n"
@@ -4515,7 +4432,7 @@
 	}
 
 	/* The following is a warning, not an error. */
-	if ((res = zonecfg_bind_pool(handle, zoneid, pool_err,
+	if ((res = zonecfg_bind_pool(snap_hndl, zoneid, pool_err,
 	    sizeof (pool_err))) != Z_OK) {
 		if (res == Z_POOL_BIND)
 			zerror(zlogp, B_FALSE, "WARNING: unable to bind to "
@@ -4529,10 +4446,9 @@
 	}
 
 	/* Update saved pool name in case it has changed */
-	(void) zonecfg_get_poolname(handle, zone_name, pool_name,
+	(void) zonecfg_get_poolname(snap_hndl, zone_name, pool_name,
 	    sizeof (pool_name));
 
-	zonecfg_fini_handle(handle);
 	return (Z_OK);
 }
 
@@ -4633,33 +4549,28 @@
 }
 
 static int
-setup_zone_attrs(zlog_t *zlogp, char *zone_namep, zoneid_t zoneid)
+setup_zone_attrs(zlog_t *zlogp, zoneid_t zoneid)
 {
-	zone_dochandle_t handle;
 	int res = Z_OK;
 
-	if ((handle = zonecfg_init_handle()) == NULL) {
-		zerror(zlogp, B_TRUE, "getting zone configuration handle");
-		return (Z_BAD_HANDLE);
-	}
-	if ((res = zonecfg_get_snapshot_handle(zone_namep, handle)) != Z_OK) {
-		zerror(zlogp, B_FALSE, "invalid configuration");
+	if ((res = setup_zone_hostid(snap_hndl, zlogp, zoneid)) != Z_OK)
 		goto out;
-	}
 
-	if ((res = setup_zone_hostid(handle, zlogp, zoneid)) != Z_OK)
+	if ((res = setup_zone_fs_allowed(snap_hndl, zlogp, zoneid)) != Z_OK)
 		goto out;
 
-	if ((res = setup_zone_fs_allowed(handle, zlogp, zoneid)) != Z_OK)
-		goto out;
-
 out:
-	zonecfg_fini_handle(handle);
 	return (res);
 }
 
+/*
+ * The zone_did is a persistent debug ID.  Each zone should have a unique ID
+ * in the kernel.  This is used for things like DTrace which want to monitor
+ * zones across reboots.  They can't use the zoneid since that changes on
+ * each boot.
+ */
 zoneid_t
-vplat_create(zlog_t *zlogp, zone_mnt_t mount_cmd)
+vplat_create(zlog_t *zlogp, zone_mnt_t mount_cmd, zoneid_t zone_did)
 {
 	zoneid_t rval = -1;
 	priv_set_t *privs;
@@ -4675,7 +4586,7 @@
 	tsol_zcent_t *zcent = NULL;
 	int match = 0;
 	int doi = 0;
-	int flags;
+	int flags = -1;
 	zone_iptype_t iptype;
 
 	if (zone_get_rootpath(zone_name, rootpath, sizeof (rootpath)) != Z_OK) {
@@ -4697,6 +4608,8 @@
 		flags = ZCF_NET_EXCL;
 		break;
 	}
+	if (flags == -1)
+		abort();
 
 	if ((privs = priv_allocset()) == NULL) {
 		zerror(zlogp, B_TRUE, "%s failed", "priv_allocset");
@@ -4800,7 +4713,7 @@
 	xerr = 0;
 	if ((zoneid = zone_create(kzone, rootpath, privs, rctlbuf,
 	    rctlbufsz, zfsbuf, zfsbufsz, &xerr, match, doi, zlabel,
-	    flags)) == -1) {
+	    flags, zone_did)) == -1) {
 		if (xerr == ZE_AREMOUNTS) {
 			if (zonecfg_find_mounts(rootpath, NULL, NULL) < 1) {
 				zerror(zlogp, B_FALSE,
@@ -4846,7 +4759,7 @@
 		struct brand_attr attr;
 		char modname[MAXPATHLEN];
 
-		if (setup_zone_attrs(zlogp, zone_name, zoneid) != Z_OK)
+		if (setup_zone_attrs(zlogp, zoneid) != Z_OK)
 			goto error;
 
 		if ((bh = brand_open(brand_name)) == NULL) {
@@ -4904,6 +4817,8 @@
 	}
 	if (rctlbuf != NULL)
 		free(rctlbuf);
+	if (zfsbuf != NULL)
+		free(zfsbuf);
 	priv_freeset(privs);
 	if (fp != NULL)
 		zonecfg_close_scratch(fp);
@@ -4992,7 +4907,7 @@
 int
 vplat_bringup(zlog_t *zlogp, zone_mnt_t mount_cmd, zoneid_t zoneid)
 {
-	char zonepath[MAXPATHLEN];
+	char zpath[MAXPATHLEN];
 
 	if (mount_cmd == Z_MNT_BOOT && validate_datasets(zlogp) != 0) {
 		lofs_discard_mnttab();
@@ -5003,15 +4918,11 @@
 	 * Before we try to mount filesystems we need to create the
 	 * attribute backing store for /dev
 	 */
-	if (zone_get_zonepath(zone_name, zonepath, sizeof (zonepath)) != Z_OK) {
-		lofs_discard_mnttab();
-		return (-1);
-	}
-	resolve_lofs(zlogp, zonepath, sizeof (zonepath));
+	(void) strlcpy(zpath, zonepath, sizeof (zpath));
+	resolve_lofs(zlogp, zpath, sizeof (zpath));
 
 	/* Make /dev directory owned by root, grouped sys */
-	if (make_one_dir(zlogp, zonepath, "/dev", DEFAULT_DIR_MODE,
-	    0, 3) != 0) {
+	if (make_one_dir(zlogp, zpath, "/dev", DEFAULT_DIR_MODE, 0, 3) != 0) {
 		lofs_discard_mnttab();
 		return (-1);
 	}
@@ -5046,6 +4957,8 @@
 				return (-1);
 			}
 			break;
+		default:
+			abort();
 		}
 	}
 
@@ -5121,13 +5034,13 @@
 }
 
 int
-vplat_teardown(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting)
+vplat_teardown(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting,
+    boolean_t debug)
 {
 	char *kzone;
 	zoneid_t zoneid;
 	int res;
 	char pool_err[128];
-	char zpath[MAXPATHLEN];
 	char cmdbuf[MAXPATHLEN];
 	brand_handle_t bh = NULL;
 	dladm_status_t status;
@@ -5160,16 +5073,12 @@
 		goto error;
 	}
 
-	if (remove_datalink_pool(zlogp, zoneid) != 0) {
+	if (remove_datalink_pool(zlogp, zoneid) != 0)
 		zerror(zlogp, B_FALSE, "unable clear datalink pool property");
-		goto error;
-	}
 
-	if (remove_datalink_protect(zlogp, zoneid) != 0) {
+	if (remove_datalink_protect(zlogp, zoneid) != 0)
 		zerror(zlogp, B_FALSE,
 		    "unable clear datalink protect property");
-		goto error;
-	}
 
 	/*
 	 * The datalinks assigned to the zone will be removed from the NGZ as
@@ -5183,12 +5092,6 @@
 		goto error;
 	}
 
-	/* Get the zonepath of this zone */
-	if (zone_get_zonepath(zone_name, zpath, sizeof (zpath)) != Z_OK) {
-		zerror(zlogp, B_FALSE, "unable to determine zone path");
-		goto error;
-	}
-
 	/* Get a handle to the brand info for this zone */
 	if ((bh = brand_open(brand_name)) == NULL) {
 		zerror(zlogp, B_FALSE, "unable to determine zone brand");
@@ -5199,7 +5102,7 @@
 	 * brand a chance to cleanup any custom configuration.
 	 */
 	(void) strcpy(cmdbuf, EXEC_PREFIX);
-	if (brand_get_halt(bh, zone_name, zpath, cmdbuf + EXEC_LEN,
+	if (brand_get_halt(bh, zone_name, zonepath, cmdbuf + EXEC_LEN,
 	    sizeof (cmdbuf) - EXEC_LEN) < 0) {
 		brand_close(bh);
 		zerror(zlogp, B_FALSE, "unable to determine branded zone's "
@@ -5209,7 +5112,7 @@
 	brand_close(bh);
 
 	if ((strlen(cmdbuf) > EXEC_LEN) &&
-	    (do_subproc(zlogp, cmdbuf, NULL) != Z_OK)) {
+	    (do_subproc(zlogp, cmdbuf, NULL, debug) != Z_OK)) {
 		zerror(zlogp, B_FALSE, "%s failed", cmdbuf);
 		goto error;
 	}
@@ -5241,12 +5144,6 @@
 			}
 			break;
 		case ZS_EXCLUSIVE:
-			if (unconfigure_exclusive_network_interfaces(zlogp,
-			    zoneid) != 0) {
-				zerror(zlogp, B_FALSE, "unable to unconfigure "
-				    "network interfaces in zone");
-				goto error;
-			}
 			status = dladm_zone_halt(dld_handle, zoneid);
 			if (status != DLADM_STATUS_OK) {
 				zerror(zlogp, B_FALSE, "unable to notify "
@@ -5283,14 +5180,9 @@
 
 		if (rebooting) {
 			struct zone_psettab pset_tab;
-			zone_dochandle_t handle;
 
-			if ((handle = zonecfg_init_handle()) != NULL &&
-			    zonecfg_get_handle(zone_name, handle) == Z_OK &&
-			    zonecfg_lookup_pset(handle, &pset_tab) == Z_OK)
+			if (zonecfg_lookup_pset(snap_hndl, &pset_tab) == Z_OK)
 				destroy_tmp_pool = B_FALSE;
-
-			zonecfg_fini_handle(handle);
 		}
 
 		if (destroy_tmp_pool) {
usr/src/cmd/zoneadmd/zfd.c
usr/src/cmd/zoneadmd/zoneadmd.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/zoneadmd/zoneadmd.c	Sun Oct 25 21:22:56 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/zoneadmd/zoneadmd.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc. All rights reserved.
  */
 
 /*
@@ -68,6 +69,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/sysmacros.h>
+#include <sys/time.h>
 
 #include <bsm/adt.h>
 #include <bsm/adt_event.h>
@@ -108,6 +110,8 @@
 
 static char *progname;
 char *zone_name;	/* zone which we are managing */
+zone_dochandle_t snap_hndl;	/* handle for snapshot created when ready */
+char zonepath[MAXNAMELEN];
 char pool_name[MAXNAMELEN];
 char default_brand[MAXNAMELEN];
 char brand_name[MAXNAMELEN];
@@ -116,10 +120,11 @@
 boolean_t zone_islabeled;
 boolean_t shutdown_in_progress;
 static zoneid_t zone_id;
+static zoneid_t zone_did = 0;
 dladm_handle_t dld_handle = NULL;
 
-static char pre_statechg_hook[2 * MAXPATHLEN];
-static char post_statechg_hook[2 * MAXPATHLEN];
+char pre_statechg_hook[2 * MAXPATHLEN];
+char post_statechg_hook[2 * MAXPATHLEN];
 char query_hook[2 * MAXPATHLEN];
 
 zlog_t logsys;
@@ -141,6 +146,9 @@
 
 #define	DEFAULT_LOCALE	"C"
 
+#define	RSRC_NET	"net"
+#define	RSRC_DEV	"device"
+
 static const char *
 z_cmd_name(zone_cmd_t zcmd)
 {
@@ -257,10 +265,10 @@
 }
 
 /*
- * Emit a warning for any boot arguments which are unrecognized.  Since
- * Solaris boot arguments are getopt(3c) compatible (see kernel(1m)), we
+ * Since Solaris boot arguments are getopt(3c) compatible (see kernel(1m)), we
  * put the arguments into an argv style array, use getopt to process them,
- * and put the resultant argument string back into outargs.
+ * and put the resultant argument string back into outargs. Non-Solaris brands
+ * may support alternate forms of boot arguments so we must handle that as well.
  *
  * During the filtering, we pull out any arguments which are truly "boot"
  * arguments, leaving only those which are to be passed intact to the
@@ -267,17 +275,15 @@
  * progenitor process.  The one we support at the moment is -i, which
  * indicates to the kernel which program should be launched as 'init'.
  *
- * A return of Z_INVAL indicates specifically that the arguments are
- * not valid; this is a non-fatal error.  Except for Z_OK, all other return
- * values are treated as fatal.
+ * Except for Z_OK, all other return values are treated as fatal.
  */
 static int
 filter_bootargs(zlog_t *zlogp, const char *inargs, char *outargs,
-    char *init_file, char *badarg)
+    char *init_file)
 {
 	int argc = 0, argc_save;
 	int i;
-	int err;
+	int err = Z_OK;
 	char *arg, *lasts, **argv = NULL, **argv_save;
 	char zonecfg_args[BOOTARGS_MAX];
 	char scratchargs[BOOTARGS_MAX], *sargs;
@@ -284,7 +290,6 @@
 	char c;
 
 	bzero(outargs, BOOTARGS_MAX);
-	bzero(badarg, BOOTARGS_MAX);
 
 	/*
 	 * If the user didn't specify transient boot arguments, check
@@ -292,25 +297,10 @@
 	 * and use them if applicable.
 	 */
 	if (inargs == NULL || inargs[0] == '\0')  {
-		zone_dochandle_t handle;
-		if ((handle = zonecfg_init_handle()) == NULL) {
-			zerror(zlogp, B_TRUE,
-			    "getting zone configuration handle");
-			return (Z_BAD_HANDLE);
-		}
-		err = zonecfg_get_snapshot_handle(zone_name, handle);
-		if (err != Z_OK) {
-			zerror(zlogp, B_FALSE,
-			    "invalid configuration snapshot");
-			zonecfg_fini_handle(handle);
-			return (Z_BAD_HANDLE);
-		}
-
 		bzero(zonecfg_args, sizeof (zonecfg_args));
-		(void) zonecfg_get_bootargs(handle, zonecfg_args,
+		(void) zonecfg_get_bootargs(snap_hndl, zonecfg_args,
 		    sizeof (zonecfg_args));
 		inargs = zonecfg_args;
-		zonecfg_fini_handle(handle);
 	}
 
 	if (strlen(inargs) >= BOOTARGS_MAX) {
@@ -347,14 +337,22 @@
 	}
 
 	/*
-	 * We preserve compatibility with the Solaris system boot behavior,
+	 * We preserve compatibility with the illumos system boot behavior,
 	 * which allows:
 	 *
 	 * 	# reboot kernel/unix -s -m verbose
 	 *
-	 * In this example, kernel/unix tells the booter what file to
-	 * boot.  We don't want reboot in a zone to be gratuitously different,
-	 * so we silently ignore the boot file, if necessary.
+	 * In this example, kernel/unix tells the booter what file to boot. The
+	 * original intent of this was that we didn't want reboot in a zone to
+	 * be gratuitously different, so we would silently ignore the boot
+	 * file, if necessary. However, this usage is archaic and has never
+	 * been common, since it is impossible to boot a zone onto a different
+	 * kernel. Ignoring the first argument breaks for non-native brands
+	 * which pass boot arguments in a different style. e.g.
+	 *	systemd.log_level=debug
+	 * Thus, for backward compatibility we only ignore the first argument
+	 * if it appears to be in the illumos form and attempting to specify a
+	 * kernel.
 	 */
 	if (argv[0] == NULL)
 		goto done;
@@ -362,7 +360,7 @@
 	assert(argv[0][0] != ' ');
 	assert(argv[0][0] != '\t');
 
-	if (argv[0][0] != '-' && argv[0][0] != '\0') {
+	if (strncmp(argv[0], "kernel/", 7) == 0) {
 		argv = &argv[1];
 		argc--;
 	}
@@ -390,36 +388,29 @@
 			break;
 		case '?':
 			/*
-			 * We warn about unknown arguments but pass them
-			 * along anyway-- if someone wants to develop their
-			 * own init replacement, they can pass it whatever
-			 * args they want.
+			 * If a brand has its own init, we need to pass along
+			 * whatever the user provides. We use the entire
+			 * unknown string here so that we correctly handle
+			 * unknown long options (e.g. --debug).
 			 */
-			err = Z_INVAL;
 			(void) snprintf(outargs, BOOTARGS_MAX,
-			    "%s -%c", outargs, optopt);
-			(void) snprintf(badarg, BOOTARGS_MAX,
-			    "%s -%c", badarg, optopt);
+			    "%s %s", outargs, argv[optind - 1]);
 			break;
 		}
 	}
 
 	/*
-	 * For Solaris Zones we warn about and discard non-option arguments.
-	 * Hence 'boot foo bar baz gub' --> 'boot'.  However, to be similar
-	 * to the kernel, we concat up all the other remaining boot args.
-	 * and warn on them as a group.
+	 * We need to pass along everything else since we don't know what
+	 * the brand's init is expecting. For example, an argument list like:
+	 *   --confdir /foo --debug
+	 * will cause the getopt parsing to stop at '/foo' but we need to pass
+	 * that on, along with the '--debug'. This does mean that we require
+	 * any of our known options (-ifms) to preceed the brand-specific ones.
 	 */
-	if (optind < argc) {
-		err = Z_INVAL;
-		while (optind < argc) {
-			(void) snprintf(badarg, BOOTARGS_MAX, "%s%s%s",
-			    badarg, strlen(badarg) > 0 ? " " : "",
-			    argv[optind]);
-			optind++;
-		}
-		zerror(zlogp, B_FALSE, "WARNING: Unused or invalid boot "
-		    "arguments `%s'.", badarg);
+	while (optind < argc) {
+		(void) snprintf(outargs, BOOTARGS_MAX, "%s %s", outargs,
+		    argv[optind]);
+		optind++;
 	}
 
 done:
@@ -458,7 +449,7 @@
  * Run the brand's pre-state change callback, if it exists.
  */
 static int
-brand_prestatechg(zlog_t *zlogp, int state, int cmd)
+brand_prestatechg(zlog_t *zlogp, int state, int cmd, boolean_t debug)
 {
 	char cmdbuf[2 * MAXPATHLEN];
 	const char *altroot;
@@ -471,7 +462,7 @@
 	    state, cmd, altroot) > sizeof (cmdbuf))
 		return (-1);
 
-	if (do_subproc(zlogp, cmdbuf, NULL) != 0)
+	if (do_subproc(zlogp, cmdbuf, NULL, debug) != 0)
 		return (-1);
 
 	return (0);
@@ -481,7 +472,7 @@
  * Run the brand's post-state change callback, if it exists.
  */
 static int
-brand_poststatechg(zlog_t *zlogp, int state, int cmd)
+brand_poststatechg(zlog_t *zlogp, int state, int cmd, boolean_t debug)
 {
 	char cmdbuf[2 * MAXPATHLEN];
 	const char *altroot;
@@ -494,7 +485,7 @@
 	    state, cmd, altroot) > sizeof (cmdbuf))
 		return (-1);
 
-	if (do_subproc(zlogp, cmdbuf, NULL) != 0)
+	if (do_subproc(zlogp, cmdbuf, NULL, debug) != 0)
 		return (-1);
 
 	return (0);
@@ -533,35 +524,44 @@
  * subcommand.
  */
 static int
-zone_ready(zlog_t *zlogp, zone_mnt_t mount_cmd, int zstate)
+zone_ready(zlog_t *zlogp, zone_mnt_t mount_cmd, int zstate, boolean_t debug)
 {
 	int err;
+	boolean_t snapped = B_FALSE;
 
-	if (brand_prestatechg(zlogp, zstate, Z_READY) != 0)
-		return (-1);
-
+	if ((snap_hndl = zonecfg_init_handle()) == NULL) {
+		zerror(zlogp, B_TRUE, "getting zone configuration handle");
+		goto bad;
+	}
 	if ((err = zonecfg_create_snapshot(zone_name)) != Z_OK) {
 		zerror(zlogp, B_FALSE, "unable to create snapshot: %s",
 		    zonecfg_strerror(err));
 		goto bad;
 	}
+	snapped = B_TRUE;
 
-	if ((zone_id = vplat_create(zlogp, mount_cmd)) == -1) {
-		if ((err = zonecfg_destroy_snapshot(zone_name)) != Z_OK)
-			zerror(zlogp, B_FALSE, "destroying snapshot: %s",
-			    zonecfg_strerror(err));
+	if (zonecfg_get_snapshot_handle(zone_name, snap_hndl) != Z_OK) {
+		zerror(zlogp, B_FALSE, "invalid configuration snapshot");
 		goto bad;
 	}
+
+	if (zone_did == 0)
+		zone_did = zone_get_did(zone_name);
+
+	if (brand_prestatechg(zlogp, zstate, Z_READY, debug) != 0)
+		goto bad;
+
+	if ((zone_id = vplat_create(zlogp, mount_cmd, zone_did)) == -1)
+		goto bad;
+
 	if (vplat_bringup(zlogp, mount_cmd, zone_id) != 0) {
 		bringup_failure_recovery = B_TRUE;
-		(void) vplat_teardown(NULL, (mount_cmd != Z_MNT_BOOT), B_FALSE);
-		if ((err = zonecfg_destroy_snapshot(zone_name)) != Z_OK)
-			zerror(zlogp, B_FALSE, "destroying snapshot: %s",
-			    zonecfg_strerror(err));
+		(void) vplat_teardown(NULL, (mount_cmd != Z_MNT_BOOT), B_FALSE,
+		    debug);
 		goto bad;
 	}
 
-	if (brand_poststatechg(zlogp, zstate, Z_READY) != 0)
+	if (brand_poststatechg(zlogp, zstate, Z_READY, debug) != 0)
 		goto bad;
 
 	return (0);
@@ -571,7 +571,13 @@
 	 * If something goes wrong, we up the zones's state to the target
 	 * state, READY, and then invoke the hook as if we're halting.
 	 */
-	(void) brand_poststatechg(zlogp, ZONE_STATE_READY, Z_HALT);
+	(void) brand_poststatechg(zlogp, ZONE_STATE_READY, Z_HALT, debug);
+	if (snapped)
+		if ((err = zonecfg_destroy_snapshot(zone_name)) != Z_OK)
+			zerror(zlogp, B_FALSE, "destroying snapshot: %s",
+			    zonecfg_strerror(err));
+	zonecfg_fini_handle(snap_hndl);
+	snap_hndl = NULL;
 	return (-1);
 }
 
@@ -623,15 +629,8 @@
 
 	/* determine the zone rootpath */
 	if (mount_cmd) {
-		char zonepath[MAXPATHLEN];
 		char luroot[MAXPATHLEN];
 
-		if (zone_get_zonepath(zone_name,
-		    zonepath, sizeof (zonepath)) != Z_OK) {
-			zerror(zlogp, B_FALSE, "unable to determine zone path");
-			return (-1);
-		}
-
 		(void) snprintf(luroot, sizeof (luroot), "%s/lu", zonepath);
 		resolve_lofs(zlogp, luroot, sizeof (luroot));
 		(void) strlcpy(rootpath, luroot, sizeof (rootpath));
@@ -686,6 +685,8 @@
 		char opt_buf[MAX_MNTOPT_STR];
 		int optlen = 0;
 		int mflag = MS_DATA;
+		int i;
+		int ret;
 
 		(void) ct_tmpl_clear(tmpl_fd);
 		/*
@@ -713,9 +714,26 @@
 			optlen = MAX_MNTOPT_STR;
 			mflag = MS_OPTIONSTR;
 		}
-		if (mount(spec, dir, mflag, fstype, NULL, 0, opt, optlen) != 0)
-			_exit(errno);
-		_exit(0);
+
+		/*
+		 * There is an obscure race condition which can cause mount
+		 * to return EBUSY. This happens for example on the mount
+		 * of the zone's /etc/svc/volatile file system if there is
+		 * a GZ process running svcs -Z, which will touch the
+		 * mountpoint, just as we're trying to do the mount. To cope
+		 * with this, we retry up to 3 times to let this transient
+		 * process get out of the way.
+		 */
+		for (i = 0; i < 3; i++) {
+			ret = 0;
+			if (mount(spec, dir, mflag, fstype, NULL, 0, opt,
+			    optlen) != 0)
+				ret = errno;
+			if (ret != EBUSY)
+				break;
+			(void) sleep(1);
+		}
+		_exit(ret);
 	}
 
 	/* parent */
@@ -739,12 +757,150 @@
 }
 
 /*
+ * env variable name format
+ *	_ZONECFG_{resource name}_{identifying attr. name}_{property name}
+ * Any dashes (-) in the property names are replaced with underscore (_).
+ */
+static void
+set_zonecfg_env(char *rsrc, char *attr, char *name, char *val)
+{
+	char *p;
+	char nm[MAXNAMELEN];
+
+	if (attr == NULL)
+		(void) snprintf(nm, sizeof (nm), "_ZONECFG_%s_%s", rsrc,
+		    name);
+	else
+		(void) snprintf(nm, sizeof (nm), "_ZONECFG_%s_%s_%s", rsrc,
+		    attr, name);
+
+	p = nm;
+	while ((p = strchr(p, '-')) != NULL)
+		*p++ = '_';
+
+	(void) setenv(nm, val, 1);
+}
+
+/*
+ * Export zonecfg network and device properties into environment for the boot
+ * and state change hooks.
+ * If debug is true, export the brand hook debug env. variable as well.
+ *
+ * We could export more of the config in the future, as necessary.
+ */
+static int
+setup_subproc_env(boolean_t debug)
+{
+	int res;
+	struct zone_nwiftab ntab;
+	struct zone_devtab dtab;
+	struct zone_attrtab atab;
+	char net_resources[MAXNAMELEN * 2];
+	char dev_resources[MAXNAMELEN * 2];
+
+	/* snap_hndl is null when called through the set_brand_env code path */
+	if (snap_hndl == NULL)
+		return (Z_OK);
+
+	net_resources[0] = '\0';
+	if ((res = zonecfg_setnwifent(snap_hndl)) != Z_OK)
+		goto done;
+
+	while (zonecfg_getnwifent(snap_hndl, &ntab) == Z_OK) {
+		struct zone_res_attrtab *rap;
+		char *phys;
+
+		phys = ntab.zone_nwif_physical;
+
+		(void) strlcat(net_resources, phys, sizeof (net_resources));
+		(void) strlcat(net_resources, " ", sizeof (net_resources));
+
+		set_zonecfg_env(RSRC_NET, phys, "physical", phys);
+
+		set_zonecfg_env(RSRC_NET, phys, "address",
+		    ntab.zone_nwif_address);
+		set_zonecfg_env(RSRC_NET, phys, "allowed-address",
+		    ntab.zone_nwif_allowed_address);
+		set_zonecfg_env(RSRC_NET, phys, "defrouter",
+		    ntab.zone_nwif_defrouter);
+		set_zonecfg_env(RSRC_NET, phys, "global-nic",
+		    ntab.zone_nwif_gnic);
+		set_zonecfg_env(RSRC_NET, phys, "mac-addr", ntab.zone_nwif_mac);
+		set_zonecfg_env(RSRC_NET, phys, "vlan-id",
+		    ntab.zone_nwif_vlan_id);
+
+		for (rap = ntab.zone_nwif_attrp; rap != NULL;
+		    rap = rap->zone_res_attr_next)
+			set_zonecfg_env(RSRC_NET, phys, rap->zone_res_attr_name,
+			    rap->zone_res_attr_value);
+		nwifent_free_attrs(&ntab);
+	}
+
+	(void) setenv("_ZONECFG_net_resources", net_resources, 1);
+
+	(void) zonecfg_endnwifent(snap_hndl);
+
+	if ((res = zonecfg_setdevent(snap_hndl)) != Z_OK)
+		goto done;
+
+	while (zonecfg_getdevent(snap_hndl, &dtab) == Z_OK) {
+		struct zone_res_attrtab *rap;
+		char *match;
+
+		match = dtab.zone_dev_match;
+
+		(void) strlcat(dev_resources, match, sizeof (dev_resources));
+		(void) strlcat(dev_resources, " ", sizeof (dev_resources));
+
+		for (rap = dtab.zone_dev_attrp; rap != NULL;
+		    rap = rap->zone_res_attr_next)
+			set_zonecfg_env(RSRC_DEV, match,
+			    rap->zone_res_attr_name, rap->zone_res_attr_value);
+	}
+
+	(void) zonecfg_enddevent(snap_hndl);
+
+	if ((res = zonecfg_setattrent(snap_hndl)) != Z_OK)
+		goto done;
+
+	while (zonecfg_getattrent(snap_hndl, &atab) == Z_OK) {
+		set_zonecfg_env("attr", NULL, atab.zone_attr_name,
+		    atab.zone_attr_value);
+	}
+
+	(void) zonecfg_endattrent(snap_hndl);
+
+	if (debug)
+		(void) setenv("_ZONEADMD_brand_debug", "1", 1);
+	else
+		(void) setenv("_ZONEADMD_brand_debug", "", 1);
+
+	res = Z_OK;
+
+done:
+	return (res);
+}
+
+void
+nwifent_free_attrs(struct zone_nwiftab *np)
+{
+	struct zone_res_attrtab *rap;
+
+	for (rap = np->zone_nwif_attrp; rap != NULL; ) {
+		struct zone_res_attrtab *tp = rap;
+
+		rap = rap->zone_res_attr_next;
+		free(tp);
+	}
+}
+
+/*
  * If retstr is not NULL, the output of the subproc is returned in the str,
  * otherwise it is output using zerror().  Any memory allocated for retstr
  * should be freed by the caller.
  */
 int
-do_subproc(zlog_t *zlogp, char *cmdbuf, char **retstr)
+do_subproc(zlog_t *zlogp, char *cmdbuf, char **retstr, boolean_t debug)
 {
 	char buf[1024];		/* arbitrary large amount */
 	char *inbuf;
@@ -763,6 +919,11 @@
 		inbuf = buf;
 	}
 
+	if (setup_subproc_env(debug) != Z_OK) {
+		zerror(zlogp, B_FALSE, "failed to setup environment");
+		return (-1);
+	}
+
 	file = popen(cmdbuf, "r");
 	if (file == NULL) {
 		zerror(zlogp, B_TRUE, "could not launch: %s", cmdbuf);
@@ -771,8 +932,13 @@
 
 	while (fgets(inbuf, 1024, file) != NULL) {
 		if (retstr == NULL) {
-			if (zlogp != &logsys)
+			if (zlogp != &logsys) {
+				int last = strlen(inbuf) - 1;
+
+				if (inbuf[last] == '\n')
+					inbuf[last] = '\0';
 				zerror(zlogp, B_FALSE, "%s", inbuf);
+			}
 		} else {
 			char *p;
 
@@ -802,24 +968,91 @@
 	return (WEXITSTATUS(status));
 }
 
+/*
+ * Get the path for this zone's init(1M) (or equivalent) process. First look
+ * for a zone-specific init-name attr, then get it from the brand.
+ */
 static int
-zone_bootup(zlog_t *zlogp, const char *bootargs, int zstate)
+get_initname(brand_handle_t bh, char *initname, int len)
 {
+	struct zone_attrtab a;
+
+	bzero(&a, sizeof (a));
+	(void) strlcpy(a.zone_attr_name, "init-name",
+	    sizeof (a.zone_attr_name));
+
+	if (zonecfg_lookup_attr(snap_hndl, &a) == Z_OK) {
+		(void) strlcpy(initname, a.zone_attr_value, len);
+		return (0);
+	}
+
+	return (brand_get_initname(bh, initname, len));
+}
+
+/*
+ * Get the restart-init flag for this zone's init(1M) (or equivalent) process.
+ * First look for a zone-specific restart-init attr, then get it from the brand.
+ */
+static boolean_t
+restartinit(brand_handle_t bh)
+{
+	struct zone_attrtab a;
+
+	bzero(&a, sizeof (a));
+	(void) strlcpy(a.zone_attr_name, "restart-init",
+	    sizeof (a.zone_attr_name));
+
+	if (zonecfg_lookup_attr(snap_hndl, &a) == Z_OK) {
+		if (strcmp(a.zone_attr_value, "false") == 0)
+			return (B_FALSE);
+		return (B_TRUE);
+	}
+
+	return (brand_restartinit(bh));
+}
+
+/*
+ * Get the app-svc-dependent flag for this zone's init process. This is a
+ * zone-specific attr which controls the type of contract we create for the
+ * zone's init. When true, the contract will include CT_PR_EV_EXIT in the fatal
+ * set, so that when any service which is in the same contract exits, the init
+ * application will be terminated.
+ */
+static boolean_t
+is_app_svc_dep(brand_handle_t bh)
+{
+	struct zone_attrtab a;
+
+	bzero(&a, sizeof (a));
+	(void) strlcpy(a.zone_attr_name, "app-svc-dependent",
+	    sizeof (a.zone_attr_name));
+
+	if (zonecfg_lookup_attr(snap_hndl, &a) == Z_OK &&
+	    strcmp(a.zone_attr_value, "true") == 0) {
+		return (B_TRUE);
+	}
+
+	return (B_FALSE);
+}
+
+static int
+zone_bootup(zlog_t *zlogp, const char *bootargs, int zstate, boolean_t debug)
+{
 	zoneid_t zoneid;
 	struct stat st;
-	char zpath[MAXPATHLEN], initpath[MAXPATHLEN], init_file[MAXPATHLEN];
+	char rpath[MAXPATHLEN], initpath[MAXPATHLEN], init_file[MAXPATHLEN];
 	char nbootargs[BOOTARGS_MAX];
 	char cmdbuf[MAXPATHLEN];
 	fs_callback_t cb;
 	brand_handle_t bh;
 	zone_iptype_t iptype;
-	boolean_t links_loaded = B_FALSE;
 	dladm_status_t status;
 	char errmsg[DLADM_STRSIZE];
 	int err;
 	boolean_t restart_init;
+	boolean_t app_svc_dep;
 
-	if (brand_prestatechg(zlogp, zstate, Z_BOOT) != 0)
+	if (brand_prestatechg(zlogp, zstate, Z_BOOT, debug) != 0)
 		return (-1);
 
 	if ((zoneid = getzoneidbyname(zone_name)) == -1) {
@@ -852,13 +1085,8 @@
 	/*
 	 * Get the brand's boot callback if it exists.
 	 */
-	if (zone_get_zonepath(zone_name, zpath, sizeof (zpath)) != Z_OK) {
-		zerror(zlogp, B_FALSE, "unable to determine zone path");
-		brand_close(bh);
-		goto bad;
-	}
 	(void) strcpy(cmdbuf, EXEC_PREFIX);
-	if (brand_get_boot(bh, zone_name, zpath, cmdbuf + EXEC_LEN,
+	if (brand_get_boot(bh, zone_name, zonepath, cmdbuf + EXEC_LEN,
 	    sizeof (cmdbuf) - EXEC_LEN) != 0) {
 		zerror(zlogp, B_FALSE,
 		    "unable to determine branded zone's boot callback");
@@ -867,7 +1095,7 @@
 	}
 
 	/* Get the path for this zone's init(1M) (or equivalent) process.  */
-	if (brand_get_initname(bh, init_file, MAXPATHLEN) != 0) {
+	if (get_initname(bh, init_file, MAXPATHLEN) != 0) {
 		zerror(zlogp, B_FALSE,
 		    "unable to determine zone's init(1M) location");
 		brand_close(bh);
@@ -874,34 +1102,42 @@
 		goto bad;
 	}
 
-	/* See if this zone's brand should restart init if it dies. */
-	restart_init = brand_restartinit(bh);
+	/* See if we should restart init if it dies. */
+	restart_init = restartinit(bh);
 
+	/*
+	 * See if we need to setup contract dependencies between the zone's
+	 * primary application and any of its services.
+	 */
+	app_svc_dep = is_app_svc_dep(bh);
+
 	brand_close(bh);
 
-	err = filter_bootargs(zlogp, bootargs, nbootargs, init_file,
-	    bad_boot_arg);
-	if (err == Z_INVAL)
-		eventstream_write(Z_EVT_ZONE_BADARGS);
-	else if (err != Z_OK)
+	err = filter_bootargs(zlogp, bootargs, nbootargs, init_file);
+	if (err != Z_OK)
 		goto bad;
 
 	assert(init_file[0] != '\0');
 
-	/* Try to anticipate possible problems: Make sure init is executable. */
-	if (zone_get_rootpath(zone_name, zpath, sizeof (zpath)) != Z_OK) {
+	/*
+	 * Try to anticipate possible problems: If possible, make sure init is
+	 * executable.
+	 */
+	if (zone_get_rootpath(zone_name, rpath, sizeof (rpath)) != Z_OK) {
 		zerror(zlogp, B_FALSE, "unable to determine zone root");
 		goto bad;
 	}
 
-	(void) snprintf(initpath, sizeof (initpath), "%s%s", zpath, init_file);
+	(void) snprintf(initpath, sizeof (initpath), "%s%s", rpath, init_file);
 
-	if (stat(initpath, &st) == -1) {
+	if (lstat(initpath, &st) == -1) {
 		zerror(zlogp, B_TRUE, "could not stat %s", initpath);
 		goto bad;
 	}
 
-	if ((st.st_mode & S_IXUSR) == 0) {
+	if ((st.st_mode & S_IFMT) == S_IFLNK) {
+		/* symlink, we'll have to wait and resolve when we boot */
+	} else if ((st.st_mode & S_IXUSR) == 0) {
 		zerror(zlogp, B_FALSE, "%s is not executable", initpath);
 		goto bad;
 	}
@@ -919,7 +1155,6 @@
 			    " %s", dladm_status2str(status, errmsg));
 			goto bad;
 		}
-		links_loaded = B_TRUE;
 	}
 
 	/*
@@ -928,7 +1163,7 @@
 	 * is booted.
 	 */
 	if ((strlen(cmdbuf) > EXEC_LEN) &&
-	    (do_subproc(zlogp, cmdbuf, NULL) != Z_OK)) {
+	    (do_subproc(zlogp, cmdbuf, NULL, debug) != Z_OK)) {
 		zerror(zlogp, B_FALSE, "%s failed", cmdbuf);
 		goto bad;
 	}
@@ -949,6 +1184,12 @@
 		goto bad;
 	}
 
+	if (app_svc_dep && zone_setattr(zoneid, ZONE_ATTR_APP_SVC_CT,
+	    (void *)B_TRUE, sizeof (boolean_t)) == -1) {
+		zerror(zlogp, B_TRUE, "could not set zone app-die");
+		goto bad;
+	}
+
 	/*
 	 * Inform zonestatd of a new zone so that it can install a door for
 	 * the zone to contact it.
@@ -960,9 +1201,15 @@
 		goto bad;
 	}
 
-	if (brand_poststatechg(zlogp, zstate, Z_BOOT) != 0)
+	if (brand_poststatechg(zlogp, zstate, Z_BOOT, debug) != 0)
 		goto bad;
 
+	/* Startup a thread to perform zfd logging/tty svc for the zone. */
+	create_log_thread(zlogp, zone_id);
+
+	/* Startup a thread to perform memory capping for the zone. */
+	create_mcap_thread(zlogp, zone_id);
+
 	return (0);
 
 bad:
@@ -970,32 +1217,42 @@
 	 * If something goes wrong, we up the zones's state to the target
 	 * state, RUNNING, and then invoke the hook as if we're halting.
 	 */
-	(void) brand_poststatechg(zlogp, ZONE_STATE_RUNNING, Z_HALT);
-	if (links_loaded)
-		(void) dladm_zone_halt(dld_handle, zoneid);
+	(void) brand_poststatechg(zlogp, ZONE_STATE_RUNNING, Z_HALT, debug);
+
 	return (-1);
 }
 
 static int
-zone_halt(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting, int zstate)
+zone_halt(zlog_t *zlogp, boolean_t unmount_cmd, boolean_t rebooting, int zstate,
+    boolean_t debug)
 {
 	int err;
 
-	if (brand_prestatechg(zlogp, zstate, Z_HALT) != 0)
+	if (brand_prestatechg(zlogp, zstate, Z_HALT, debug) != 0)
 		return (-1);
 
-	if (vplat_teardown(zlogp, unmount_cmd, rebooting) != 0) {
+	/* Shutting down, stop the memcap thread */
+	destroy_mcap_thread();
+
+	if (vplat_teardown(zlogp, unmount_cmd, rebooting, debug) != 0) {
 		if (!bringup_failure_recovery)
 			zerror(zlogp, B_FALSE, "unable to destroy zone");
+		destroy_log_thread();
 		return (-1);
 	}
 
+	/* Shut down is done, stop the log thread */
+	destroy_log_thread();
+
+	if (brand_poststatechg(zlogp, zstate, Z_HALT, debug) != 0)
+		return (-1);
+
 	if ((err = zonecfg_destroy_snapshot(zone_name)) != Z_OK)
 		zerror(zlogp, B_FALSE, "destroying snapshot: %s",
 		    zonecfg_strerror(err));
 
-	if (brand_poststatechg(zlogp, zstate, Z_HALT) != 0)
-		return (-1);
+	zonecfg_fini_handle(snap_hndl);
+	snap_hndl = NULL;
 
 	return (0);
 }
@@ -1007,7 +1264,6 @@
 	pid_t child;
 	char cmdbuf[MAXPATHLEN];
 	brand_handle_t bh = NULL;
-	char zpath[MAXPATHLEN];
 	ctid_t ct;
 	int tmpl_fd;
 	int child_status;
@@ -1028,18 +1284,12 @@
 		return (-1);
 	}
 
-	if (zone_get_zonepath(zone_name, zpath, sizeof (zpath)) != Z_OK) {
-		zerror(zlogp, B_FALSE, "unable to determine zone path");
-		brand_close(bh);
-		return (-1);
-	}
-
 	/*
 	 * If there is a brand 'shutdown' callback, execute it now to give the
 	 * brand a chance to cleanup any custom configuration.
 	 */
 	(void) strcpy(cmdbuf, EXEC_PREFIX);
-	if (brand_get_shutdown(bh, zone_name, zpath, cmdbuf + EXEC_LEN,
+	if (brand_get_shutdown(bh, zone_name, zonepath, cmdbuf + EXEC_LEN,
 	    sizeof (cmdbuf) - EXEC_LEN) != 0 || strlen(cmdbuf) <= EXEC_LEN) {
 		(void) strcat(cmdbuf, SHUTDOWN_DEFAULT);
 	}
@@ -1177,6 +1427,36 @@
 }
 
 /*
+ * Log the exit time and status of the zone's init process into
+ * {zonepath}/lastexited. If the zone shutdown normally, the exit status will
+ * be -1, otherwise it will be the exit status as described in wait.3c.
+ * If the zone is configured to restart init, then nothing will be logged if
+ * init exits unexpectedly (the kernel will never upcall in this case).
+ */
+static void
+log_init_exit(int status)
+{
+	char p[MAXPATHLEN];
+	char buf[128];
+	struct timeval t;
+	int fd;
+
+	if (snprintf(p, sizeof (p), "%s/lastexited", zonepath) > sizeof (p))
+		return;
+	if (gettimeofday(&t, NULL) != 0)
+		return;
+	if (snprintf(buf, sizeof (buf), "%ld.%ld %d\n", t.tv_sec, t.tv_usec,
+	    status) > sizeof (buf))
+		return;
+	if ((fd = open(p, O_WRONLY | O_CREAT | O_TRUNC, 0644)) < 0)
+		return;
+
+	(void) write(fd, buf, strlen(buf));
+
+	(void) close(fd);
+}
+
+/*
  * The main routine for the door server that deals with zone state transitions.
  */
 /* ARGSUSED */
@@ -1189,9 +1469,11 @@
 
 	zone_state_t zstate;
 	zone_cmd_t cmd;
+	boolean_t debug;
+	int init_status;
 	zone_cmd_arg_t *zargp;
 
-	boolean_t kernelcall;
+	boolean_t kernelcall = B_TRUE;
 
 	int rval = -1;
 	uint64_t uniqid;
@@ -1241,6 +1523,8 @@
 		goto out;
 	}
 	cmd = zargp->cmd;
+	debug = zargp->debug;
+	init_status = zargp->status;
 
 	if (door_ucred(&uc) != 0) {
 		zerror(&logsys, B_TRUE, "door_ucred");
@@ -1347,23 +1631,25 @@
 	case ZONE_STATE_INSTALLED:
 		switch (cmd) {
 		case Z_READY:
-			rval = zone_ready(zlogp, Z_MNT_BOOT, zstate);
+			rval = zone_ready(zlogp, Z_MNT_BOOT, zstate, debug);
 			if (rval == 0)
 				eventstream_write(Z_EVT_ZONE_READIED);
+			zcons_statechanged();
 			break;
 		case Z_BOOT:
 		case Z_FORCEBOOT:
 			eventstream_write(Z_EVT_ZONE_BOOTING);
-			if ((rval = zone_ready(zlogp, Z_MNT_BOOT, zstate))
-			    == 0) {
+			if ((rval = zone_ready(zlogp, Z_MNT_BOOT, zstate,
+			    debug)) == 0) {
 				rval = zone_bootup(zlogp, zargp->bootbuf,
-				    zstate);
+				    zstate, debug);
 			}
 			audit_put_record(zlogp, uc, rval, "boot");
+			zcons_statechanged();
 			if (rval != 0) {
 				bringup_failure_recovery = B_TRUE;
 				(void) zone_halt(zlogp, B_FALSE, B_FALSE,
-				    zstate);
+				    zstate, debug);
 				eventstream_write(Z_EVT_ZONE_BOOTFAILED);
 			}
 			break;
@@ -1415,7 +1701,7 @@
 
 			rval = zone_ready(zlogp,
 			    strcmp(zargp->bootbuf, "-U") == 0 ?
-			    Z_MNT_UPDATE : Z_MNT_SCRATCH, zstate);
+			    Z_MNT_UPDATE : Z_MNT_SCRATCH, zstate, debug);
 			if (rval != 0)
 				break;
 
@@ -1477,15 +1763,18 @@
 			rval = 0;
 			break;
 		case Z_BOOT:
+		case Z_FORCEBOOT:
 			(void) strlcpy(boot_args, zargp->bootbuf,
 			    sizeof (boot_args));
 			eventstream_write(Z_EVT_ZONE_BOOTING);
-			rval = zone_bootup(zlogp, zargp->bootbuf, zstate);
+			rval = zone_bootup(zlogp, zargp->bootbuf, zstate,
+			    debug);
 			audit_put_record(zlogp, uc, rval, "boot");
+			zcons_statechanged();
 			if (rval != 0) {
 				bringup_failure_recovery = B_TRUE;
 				(void) zone_halt(zlogp, B_FALSE, B_TRUE,
-				    zstate);
+				    zstate, debug);
 				eventstream_write(Z_EVT_ZONE_BOOTFAILED);
 			}
 			boot_args[0] = '\0';
@@ -1493,9 +1782,10 @@
 		case Z_HALT:
 			if (kernelcall)	/* Invalid; can't happen */
 				abort();
-			if ((rval = zone_halt(zlogp, B_FALSE, B_FALSE, zstate))
-			    != 0)
+			if ((rval = zone_halt(zlogp, B_FALSE, B_FALSE, zstate,
+			    debug)) != 0)
 				break;
+			zcons_statechanged();
 			eventstream_write(Z_EVT_ZONE_HALTED);
 			break;
 		case Z_SHUTDOWN:
@@ -1502,6 +1792,7 @@
 		case Z_REBOOT:
 		case Z_NOTE_UNINSTALLING:
 		case Z_MOUNT:
+		case Z_FORCEMOUNT:
 		case Z_UNMOUNT:
 			if (kernelcall)	/* Invalid; can't happen */
 				abort();
@@ -1518,7 +1809,7 @@
 		case Z_UNMOUNT:
 			if (kernelcall)	/* Invalid; can't happen */
 				abort();
-			rval = zone_halt(zlogp, B_TRUE, B_FALSE, zstate);
+			rval = zone_halt(zlogp, B_TRUE, B_FALSE, zstate, debug);
 			if (rval == 0) {
 				eventstream_write(Z_EVT_ZONE_HALTED);
 				(void) sema_post(&scratch_sem);
@@ -1540,15 +1831,18 @@
 	case ZONE_STATE_DOWN:
 		switch (cmd) {
 		case Z_READY:
-			if ((rval = zone_halt(zlogp, B_FALSE, B_TRUE, zstate))
-			    != 0)
+			if ((rval = zone_halt(zlogp, B_FALSE, B_TRUE, zstate,
+			    debug)) != 0)
 				break;
-			if ((rval = zone_ready(zlogp, Z_MNT_BOOT, zstate)) == 0)
+			zcons_statechanged();
+			if ((rval = zone_ready(zlogp, Z_MNT_BOOT, zstate,
+			    debug)) == 0)
 				eventstream_write(Z_EVT_ZONE_READIED);
 			else
 				eventstream_write(Z_EVT_ZONE_HALTED);
 			break;
 		case Z_BOOT:
+		case Z_FORCEBOOT:
 			/*
 			 * We could have two clients racing to boot this
 			 * zone; the second client loses, but his request
@@ -1559,32 +1853,40 @@
 			rval = 0;
 			break;
 		case Z_HALT:
-			if ((rval = zone_halt(zlogp, B_FALSE, B_FALSE, zstate))
-			    != 0)
+			if (kernelcall) {
+				log_init_exit(init_status);
+			} else {
+				log_init_exit(-1);
+			}
+			if ((rval = zone_halt(zlogp, B_FALSE, B_FALSE, zstate,
+			    debug)) != 0)
 				break;
 			eventstream_write(Z_EVT_ZONE_HALTED);
+			zcons_statechanged();
 			break;
 		case Z_REBOOT:
 			(void) strlcpy(boot_args, zargp->bootbuf,
 			    sizeof (boot_args));
 			eventstream_write(Z_EVT_ZONE_REBOOTING);
-			if ((rval = zone_halt(zlogp, B_FALSE, B_TRUE, zstate))
-			    != 0) {
+			if ((rval = zone_halt(zlogp, B_FALSE, B_TRUE, zstate,
+			    debug)) != 0) {
 				eventstream_write(Z_EVT_ZONE_BOOTFAILED);
 				boot_args[0] = '\0';
 				break;
 			}
-			if ((rval = zone_ready(zlogp, Z_MNT_BOOT, zstate))
-			    != 0) {
+			zcons_statechanged();
+			if ((rval = zone_ready(zlogp, Z_MNT_BOOT, zstate,
+			    debug)) != 0) {
 				eventstream_write(Z_EVT_ZONE_BOOTFAILED);
 				boot_args[0] = '\0';
 				break;
 			}
-			rval = zone_bootup(zlogp, zargp->bootbuf, zstate);
+			rval = zone_bootup(zlogp, zargp->bootbuf, zstate,
+			    debug);
 			audit_put_record(zlogp, uc, rval, "reboot");
 			if (rval != 0) {
 				(void) zone_halt(zlogp, B_FALSE, B_TRUE,
-				    zstate);
+				    zstate, debug);
 				eventstream_write(Z_EVT_ZONE_BOOTFAILED);
 			}
 			boot_args[0] = '\0';
@@ -1596,6 +1898,7 @@
 			break;
 		case Z_NOTE_UNINSTALLING:
 		case Z_MOUNT:
+		case Z_FORCEMOUNT:
 		case Z_UNMOUNT:
 			zerror(zlogp, B_FALSE, "%s operation is invalid "
 			    "for zones in state '%s'", z_cmd_name(cmd),
@@ -1759,11 +2062,38 @@
 		 * state.
 		 */
 		if (zstate > ZONE_STATE_INSTALLED) {
+			static zoneid_t zid;
+
 			zerror(zlogp, B_FALSE,
 			    "zone '%s': WARNING: zone is in state '%s', but "
 			    "zoneadmd does not appear to be available; "
 			    "restarted zoneadmd to recover.",
 			    zone_name, zone_state_str(zstate));
+
+			/*
+			 * Startup a thread to perform the zfd logging/tty svc
+			 * and a thread to perform memory capping for the
+			 * zone. zlogp won't be valid for much longer so use
+			 * logsys.
+			 */
+			if ((zid = getzoneidbyname(zone_name)) != -1) {
+				create_log_thread(&logsys, zid);
+				create_mcap_thread(&logsys, zid);
+			}
+
+			/* recover the global configuration snapshot */
+			if (snap_hndl == NULL) {
+				if ((snap_hndl = zonecfg_init_handle())
+				    == NULL ||
+				    zonecfg_create_snapshot(zone_name)
+				    != Z_OK ||
+				    zonecfg_get_snapshot_handle(zone_name,
+				    snap_hndl) != Z_OK) {
+					zerror(zlogp, B_FALSE, "recovering "
+					    "zone configuration handle");
+					goto out;
+				}
+			}
 		}
 
 		(void) fdetach(zone_door_path);
@@ -1777,21 +2107,62 @@
 }
 
 /*
- * Setup the brand's pre and post state change callbacks, as well as the
- * query callback, if any of these exist.
+ * Run the query hook with the 'env' parameter.  It should return a
+ * string of tab-delimited key-value pairs, each of which should be set
+ * in the environment.
+ *
+ * Because the env_vars string values become part of the environment, the
+ * string is static and we don't free it.
+ *
+ * This function is always called before zoneadmd forks and makes itself
+ * exclusive, so it is possible there could more than one instance of zoneadmd
+ * running in parallel at this point. Thus, we have no zonecfg snapshot and
+ * shouldn't take one yet (i.e. snap_hndl is NULL). Thats ok, since we don't
+ * need any zonecfg info to query for a brand-specific env value.
  */
 static int
-brand_callback_init(brand_handle_t bh, char *zone_name)
+set_brand_env(zlog_t *zlogp)
 {
-	char zpath[MAXPATHLEN];
+	int ret = 0;
+	static char *env_vars = NULL;
+	char buf[2 * MAXPATHLEN];
 
-	if (zone_get_zonepath(zone_name, zpath, sizeof (zpath)) != Z_OK)
+	if (query_hook[0] == '\0' || env_vars != NULL)
+		return (0);
+
+	if (snprintf(buf, sizeof (buf), "%s env", query_hook) > sizeof (buf))
 		return (-1);
 
+	if (do_subproc(zlogp, buf, &env_vars, B_FALSE) != 0)
+		return (-1);
+
+	if (env_vars != NULL) {
+		char *sp;
+
+		sp = strtok(env_vars, "\t");
+		while (sp != NULL) {
+			if (putenv(sp) != 0) {
+				ret = -1;
+				break;
+			}
+			sp = strtok(NULL, "\t");
+		}
+	}
+
+	return (ret);
+}
+
+/*
+ * Setup the brand's pre and post state change callbacks, as well as the
+ * query callback, if any of these exist.
+ */
+static int
+brand_callback_init(brand_handle_t bh, char *zone_name)
+{
 	(void) strlcpy(pre_statechg_hook, EXEC_PREFIX,
 	    sizeof (pre_statechg_hook));
 
-	if (brand_get_prestatechange(bh, zone_name, zpath,
+	if (brand_get_prestatechange(bh, zone_name, zonepath,
 	    pre_statechg_hook + EXEC_LEN,
 	    sizeof (pre_statechg_hook) - EXEC_LEN) != 0)
 		return (-1);
@@ -1802,7 +2173,7 @@
 	(void) strlcpy(post_statechg_hook, EXEC_PREFIX,
 	    sizeof (post_statechg_hook));
 
-	if (brand_get_poststatechange(bh, zone_name, zpath,
+	if (brand_get_poststatechange(bh, zone_name, zonepath,
 	    post_statechg_hook + EXEC_LEN,
 	    sizeof (post_statechg_hook) - EXEC_LEN) != 0)
 		return (-1);
@@ -1813,7 +2184,7 @@
 	(void) strlcpy(query_hook, EXEC_PREFIX,
 	    sizeof (query_hook));
 
-	if (brand_get_query(bh, zone_name, zpath, query_hook + EXEC_LEN,
+	if (brand_get_query(bh, zone_name, zonepath, query_hook + EXEC_LEN,
 	    sizeof (query_hook) - EXEC_LEN) != 0)
 		return (-1);
 
@@ -1941,6 +2312,11 @@
 		return (1);
 	}
 
+	if (zone_get_zonepath(zone_name, zonepath, sizeof (zonepath)) != Z_OK) {
+		zerror(zlogp, B_FALSE, "unable to determine zone path");
+		return (-1);
+	}
+
 	if (zonecfg_default_brand(default_brand,
 	    sizeof (default_brand)) != Z_OK) {
 		zerror(zlogp, B_FALSE, "unable to determine default brand");
@@ -2012,6 +2388,11 @@
 	}
 	priv_freeset(privset);
 
+	if (set_brand_env(zlogp) != 0) {
+		zerror(zlogp, B_FALSE, "Unable to setup brand's environment");
+		return (1);
+	}
+
 	if (mkzonedir(zlogp) != 0)
 		return (1);
 
usr/src/cmd/zoneadmd/zoneadmd.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/cmd/zoneadmd/zoneadmd.h	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/cmd/zoneadmd/zoneadmd.h	Wed Jun 17 17:43:38 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2014, Joyent, Inc. All rights reserved.
  */
 
 #ifndef	_ZONEADMD_H
@@ -90,11 +91,12 @@
 extern boolean_t in_death_throes;
 extern boolean_t bringup_failure_recovery;
 extern char *zone_name;
+extern char zonepath[MAXNAMELEN];
+extern zone_dochandle_t snap_hndl;
 extern char pool_name[MAXNAMELEN];
 extern char brand_name[MAXNAMELEN];
 extern char default_brand[MAXNAMELEN];
 extern char boot_args[BOOTARGS_MAX];
-extern char bad_boot_arg[BOOTARGS_MAX];
 extern boolean_t zone_isnative;
 extern boolean_t zone_iscluster;
 extern dladm_handle_t dld_handle;
@@ -101,6 +103,7 @@
 
 extern void zerror(zlog_t *, boolean_t, const char *, ...);
 extern char *localize_msg(char *locale, const char *msg);
+extern void nwifent_free_attrs(struct zone_nwiftab *);
 
 /*
  * Eventstream interfaces.
@@ -112,8 +115,7 @@
 	Z_EVT_ZONE_HALTED,
 	Z_EVT_ZONE_READIED,
 	Z_EVT_ZONE_UNINSTALLING,
-	Z_EVT_ZONE_BOOTFAILED,
-	Z_EVT_ZONE_BADARGS
+	Z_EVT_ZONE_BOOTFAILED
 } zone_evt_t;
 
 extern int eventstream_init();
@@ -135,9 +137,9 @@
 /*
  * Virtual platform interfaces.
  */
-extern zoneid_t vplat_create(zlog_t *, zone_mnt_t);
+extern zoneid_t vplat_create(zlog_t *, zone_mnt_t, zoneid_t);
 extern int vplat_bringup(zlog_t *, zone_mnt_t, zoneid_t);
-extern int vplat_teardown(zlog_t *, boolean_t, boolean_t);
+extern int vplat_teardown(zlog_t *, boolean_t, boolean_t, boolean_t);
 extern int vplat_get_iptype(zlog_t *, zone_iptype_t *);
 
 /*
@@ -154,8 +156,21 @@
  */
 extern int init_console(zlog_t *);
 extern void serve_console(zlog_t *);
+extern void zcons_statechanged();
 
 /*
+ * Memory capping thread creation.
+ */
+extern void create_mcap_thread(zlog_t *, zoneid_t);
+extern void destroy_mcap_thread();
+
+/*
+ * Zone FD log thread creation.
+ */
+extern void create_log_thread(zlog_t *, zoneid_t);
+extern void destroy_log_thread();
+
+/*
  * Contract handling.
  */
 extern int init_template(void);
@@ -163,7 +178,7 @@
 /*
  * Routine to manage child processes.
  */
-extern int do_subproc(zlog_t *, char *, char **);
+extern int do_subproc(zlog_t *, char *, char **, boolean_t);
 
 #ifdef __cplusplus
 }
usr/src/common/brand/lx/lx_auxv.c
usr/src/common/brand/lx/lx_auxv.h
usr/src/common/brand/lx/lx_errno.c
usr/src/common/brand/lx/lx_errno.h
usr/src/common/brand/lx/lx_signum.c
usr/src/common/brand/lx/lx_signum.h
usr/src/common/brand/lx/lx_syscall.h
usr/src/common/brand/lx/tools/Makefile
usr/src/common/brand/lx/tools/README.md
usr/src/common/brand/lx/tools/gen_errno.c
usr/src/head/regexp.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/head/regexp.h	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/head/regexp.h	Wed Jun 17 17:43:38 2015
@@ -394,12 +394,12 @@
 			/*FALLTHRU*/
 
 		case CBRA:
-			braslist[*ep++] = (char *)lp;
+			braslist[(int)*ep++] = (char *)lp;
 			continue;
 			/*FALLTHRU*/
 
 		case CKET:
-			braelist[*ep++] = (char *)lp;
+			braelist[(int)*ep++] = (char *)lp;
 			continue;
 			/*FALLTHRU*/
 
@@ -477,8 +477,8 @@
 			/*FALLTHRU*/
 
 		case CBACK:
-			bbeg = braslist[*ep];
-			ct = braelist[*ep++] - bbeg;
+			bbeg = braslist[(int)*ep];
+			ct = braelist[(int)*ep++] - bbeg;
 
 			if (ecmp(bbeg, lp, ct)) {
 				lp += ct;
@@ -488,8 +488,8 @@
 			/*FALLTHRU*/
 
 		case CBACK | STAR:
-			bbeg = braslist[*ep];
-			ct = braelist[*ep++] - bbeg;
+			bbeg = braslist[(int)*ep];
+			ct = braelist[(int)*ep++] - bbeg;
 			curlp = lp;
 			while (ecmp(bbeg, lp, ct))
 				lp += ct;
usr/src/head/zone.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/head/zone.h	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/head/zone.h	Wed Jun 17 17:43:38 2015
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent Inc.
  */
 
 #ifndef _ZONE_H
@@ -46,10 +47,13 @@
  * NOTE
  *
  * The remaining contents of this file are private to the implementation
- * of Solaris and are subject to change at any time without notice,
+ * of Illumos and are subject to change at any time without notice,
  * Applications using these interfaces may fail to run on future releases.
  */
 
+#define	ZLOGIN_DISCONNECT	0x1	/* disconnect on zone halt */
+#define	ZLOGIN_ZFD_EOF		0x2	/* EOF on ZFD */
+
 extern int zonept(int, zoneid_t);
 extern int zone_get_id(const char *, zoneid_t *);
 
@@ -56,7 +60,7 @@
 /* System call API */
 extern zoneid_t	zone_create(const char *, const char *,
     const struct priv_set *, const char *, size_t, const char *, size_t, int *,
-    int, int, const bslabel_t *, int);
+    int, int, const bslabel_t *, int, zoneid_t);
 extern int	zone_boot(zoneid_t);
 extern int	zone_destroy(zoneid_t);
 extern ssize_t	zone_getattr(zoneid_t, int, void *, size_t);
@@ -69,6 +73,7 @@
 extern int	zone_remove_datalink(zoneid_t, datalink_id_t);
 extern int	zone_check_datalink(zoneid_t *, datalink_id_t);
 extern int	zone_list_datalink(zoneid_t, int *, datalink_id_t *);
+extern const char *zone_get_nroot(void);
 
 #ifdef	__cplusplus
 }
usr/src/lib/Makefile.lib
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/Makefile.lib	Tue Nov  3 10:15:33 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/Makefile.lib	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 # Copyright 2015 Gary Mills
 # Copyright 2015 Igor Kozhukhov <ikozhukhov@gmail.com>
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2015, Joyent, Inc.
 #
 #
 # Definitions common to libraries.
@@ -135,7 +136,24 @@
 # combining relocations into one relocation table reduces startup costs.
 # All options are tunable to allow overload/omission from lower makefiles.
 
+#
+# DTrace related rules
+#
+# These allow for multiple USDT providers to be specified by a library.
+# If a library needs to break up the set of objects that are passed to
+# the dtrace -G invocation, then they can place the following in heir
+# Makefile.com:
+#
+# pics/<provider>.o	:= USDT_G_PICS = <files>
+#
+# <provider> should be replaced with the basename of one of the USDT
+# providers specified in USDT_PROVIDERS in their Makefile.com.
+#
+USDT_HEADERS=	$(USDT_PROVIDERS:%.d=%_impl.h)
+USDT_PICS=	$(USDT_PROVIDERS:%.d=pics/%.o)
+USDT_G_PICS=	$(PICS)
 
+
 HSONAME=	-h$(SONAME)
 DYNFLAGS=	$(HSONAME) $(ZTEXT) $(ZDEFS) $(BDIRECT) \
 		$(MAPFILES:%=-M%) $(MAPFILE.PGA:%=-M%) $(MAPFILE.NED:%=-M%)
@@ -157,7 +175,7 @@
 # overridden locally when extra processing is needed
 BUILD.AR=	$(AR) $(ARFLAGS) $@ $(AROBJS)
 BUILD.SO=	$(CC) $(CFLAGS) -o $@ $(GSHARED) $(DYNFLAGS) \
-		$(PICS) $(EXTPICS) $(LDLIBS)
+		$(PICS) $(EXTPICS) $(USDT_PICS) $(LDLIBS)
 BUILDCCC.SO=	$(CCC) $(CCFLAGS) -o $@ $(GSHARED) $(DYNFLAGS) \
 		$(PICS) $(EXTPICS) $(LDLIBS)
 
@@ -254,3 +272,15 @@
 # shouldn't override this - they should override $(CLOBBERFILES) instead.
 #
 CLOBBERTARGFILES= $(LIBS) $(DYNLIB) $(CLOBBERFILES)
+
+#
+# Define the default ctfdiff invocation used to check a list of types
+# supplied by a user of a library. The goal is to validate that a given
+# series of types is the same in both a 32-bit and 64-bit artifact. This
+# is only defined if we have a 64-bit build to do.
+#
+TYPECHECK_LIB32 =		$(TYPECHECK_LIB:%=$(MACH)/%)
+TYPECHECK_LIB64 =		$(TYPECHECK_LIB:%=$(MACH64)/%)
+TYPECHECK_LIST=			$(TYPELIST:%=-T %)
+$(BUILD64)TYPECHECK.lib =	$(CTFDIFF) -t -I $(TYPECHECK_LIST) $(TYPECHECK_LIB32) $(TYPECHECK_LIB64)
+TYPECHECK =			$(TYPECHECK_LIB:%=%.typecheck)
usr/src/lib/Makefile.targ
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/Makefile.targ	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/Makefile.targ	Wed Jun 17 17:43:38 2015
@@ -20,6 +20,7 @@
 #
 #
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2014, Joyent, Inc.
 #
 
 #
@@ -90,7 +91,7 @@
 
 $(DYNLIB): $$(MAPFILES)
 
-$(DYNLIB): pics .WAIT $$(PICS) $$(ALTPICS) $$(EXTPICS)
+$(DYNLIB): pics $(USDT_HEADERS) .WAIT $$(PICS) $$(ALTPICS) $$(EXTPICS) .WAIT $(USDT_PICS)
 	$(BUILD.SO)
 	$(POST_PROCESS_SO)
 
@@ -104,9 +105,12 @@
 lintcheck: $$(SRCS)
 	$(LINT.c) $(LINTCHECKFLAGS) $(SRCS) $(LDLIBS)
 
+$(TYPECHECK): $(TYPECHECK_LIB32) $(TYPECHECK_LIB64)
+	$(TYPECHECK.lib)
+
 clobber: clean
 	-$(RM) $(CLOBBERTARGFILES)
 
 clean:
-	-$(RM) $(OBJS)
+	-$(RM) $(OBJS) $(USDT_HEADERS) $(USDT_PICS)
 	-$(RM) $(PICS) $(DUPLICATE_SRC) $(LINTOUT) $(LINTLIB) $(CLEANFILES)
usr/src/lib/Makefile.usdt
usr/src/lib/brand/Makefile
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/brand/Makefile	Tue Jan  5 17:20:21 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/brand/Makefile	Mon Dec 28 16:27:39 2015
@@ -30,7 +30,10 @@
 # Build everything in parallel; use .WAIT for dependencies
 .PARALLEL:
 
-SUBDIRS= shared .WAIT sn1 solaris10 ipkg labeled lipkg $($(MACH)_SUBDIRS)
+i386_SUBDIRS= lx
+i386_MSGSUBDIRS= lx
+
+SUBDIRS= shared .WAIT sn1 solaris10 ipkg labeled $($(MACH)_SUBDIRS)
 MSGSUBDIRS= solaris10 shared $($(MACH)_MSGSUBDIRS)
 
 all :=		TARGET= all
usr/src/lib/brand/lx/Makefile
usr/src/lib/brand/lx/Makefile.lx
usr/src/lib/brand/lx/cgrpmgr/Makefile
usr/src/lib/brand/lx/cgrpmgr/cgrpmgr.c
usr/src/lib/brand/lx/cmd/Makefile
usr/src/lib/brand/lx/cmd/ifconfig.sh
usr/src/lib/brand/lx/cmd/lx_ipmgmtd.sh
usr/src/lib/brand/lx/cmd/lx_isaexec_wrapper.sh
usr/src/lib/brand/lx/cmd/lx_lockd.sh
usr/src/lib/brand/lx/cmd/lx_native.sh
usr/src/lib/brand/lx/cmd/lx_statd.sh
usr/src/lib/brand/lx/cmd/lx_thunk.sh
usr/src/lib/brand/lx/librtld_db/Makefile
usr/src/lib/brand/lx/librtld_db/Makefile.com
usr/src/lib/brand/lx/librtld_db/amd64/Makefile
usr/src/lib/brand/lx/librtld_db/amd64/mapfile-vers
usr/src/lib/brand/lx/librtld_db/common/lx_librtld_db.c
usr/src/lib/brand/lx/librtld_db/common/mapfile-vers
usr/src/lib/brand/lx/librtld_db/i386/Makefile
usr/src/lib/brand/lx/lx_brand/Makefile
usr/src/lib/brand/lx/lx_brand/Makefile.com
usr/src/lib/brand/lx/lx_brand/amd64/Makefile
usr/src/lib/brand/lx/lx_brand/amd64/lx_crt.s
usr/src/lib/brand/lx/lx_brand/amd64/lx_handler.s
usr/src/lib/brand/lx/lx_brand/amd64/lx_runexe.s
usr/src/lib/brand/lx/lx_brand/amd64/offsets.in
usr/src/lib/brand/lx/lx_brand/common/aio.c
usr/src/lib/brand/lx/lx_brand/common/capabilities.c
usr/src/lib/brand/lx/lx_brand/common/clock.c
usr/src/lib/brand/lx/lx_brand/common/clone.c
usr/src/lib/brand/lx/lx_brand/common/debug.c
usr/src/lib/brand/lx/lx_brand/common/dir.c
usr/src/lib/brand/lx/lx_brand/common/fcntl.c
usr/src/lib/brand/lx/lx_brand/common/file.c
usr/src/lib/brand/lx/lx_brand/common/fork.c
usr/src/lib/brand/lx/lx_brand/common/id.c
usr/src/lib/brand/lx/lx_brand/common/ioctl.c
usr/src/lib/brand/lx/lx_brand/common/iovec.c
usr/src/lib/brand/lx/lx_brand/common/lx_brand.c
usr/src/lib/brand/lx/lx_brand/common/lx_provider.d
usr/src/lib/brand/lx/lx_brand/common/lx_thunk_server.c
usr/src/lib/brand/lx/lx_brand/common/mapfile
usr/src/lib/brand/lx/lx_brand/common/mapfile-vers
usr/src/lib/brand/lx/lx_brand/common/mem.c
usr/src/lib/brand/lx/lx_brand/common/misc.c
usr/src/lib/brand/lx/lx_brand/common/module.c
usr/src/lib/brand/lx/lx_brand/common/mount.c
usr/src/lib/brand/lx/lx_brand/common/mount_nfs.c
usr/src/lib/brand/lx/lx_brand/common/open.c
usr/src/lib/brand/lx/lx_brand/common/pgrp.c
usr/src/lib/brand/lx/lx_brand/common/poll_select.c
usr/src/lib/brand/lx/lx_brand/common/priority.c
usr/src/lib/brand/lx/lx_brand/common/ptrace.c
usr/src/lib/brand/lx/lx_brand/common/rlimit.c
usr/src/lib/brand/lx/lx_brand/common/sched.c
usr/src/lib/brand/lx/lx_brand/common/sendfile.c
usr/src/lib/brand/lx/lx_brand/common/signal.c
usr/src/lib/brand/lx/lx_brand/common/socket.c
usr/src/lib/brand/lx/lx_brand/common/stack.c
usr/src/lib/brand/lx/lx_brand/common/stat.c
usr/src/lib/brand/lx/lx_brand/common/statfs.c
usr/src/lib/brand/lx/lx_brand/common/sysctl.c
usr/src/lib/brand/lx/lx_brand/common/sysv_ipc.c
usr/src/lib/brand/lx/lx_brand/common/time.c
usr/src/lib/brand/lx/lx_brand/common/truncate.c
usr/src/lib/brand/lx/lx_brand/common/wait.c
usr/src/lib/brand/lx/lx_brand/common/xattr.c
usr/src/lib/brand/lx/lx_brand/i386/Makefile
usr/src/lib/brand/lx/lx_brand/i386/lx_crt.s
usr/src/lib/brand/lx/lx_brand/i386/lx_handler.s
usr/src/lib/brand/lx/lx_brand/i386/lx_runexe.s
usr/src/lib/brand/lx/lx_brand/i386/offsets.in
usr/src/lib/brand/lx/lx_brand/sys/lx_aio.h
usr/src/lib/brand/lx/lx_brand/sys/lx_debug.h
usr/src/lib/brand/lx/lx_brand/sys/lx_fcntl.h
usr/src/lib/brand/lx/lx_brand/sys/lx_ioctl.h
usr/src/lib/brand/lx/lx_brand/sys/lx_misc.h
usr/src/lib/brand/lx/lx_brand/sys/lx_mount.h
usr/src/lib/brand/lx/lx_brand/sys/lx_poll.h
usr/src/lib/brand/lx/lx_brand/sys/lx_signal.h
usr/src/lib/brand/lx/lx_brand/sys/lx_sigstack.h
usr/src/lib/brand/lx/lx_brand/sys/lx_socket.h
usr/src/lib/brand/lx/lx_brand/sys/lx_stat.h
usr/src/lib/brand/lx/lx_brand/sys/lx_statfs.h
usr/src/lib/brand/lx/lx_brand/sys/lx_syscall.h
usr/src/lib/brand/lx/lx_brand/sys/lx_sysv_ipc.h
usr/src/lib/brand/lx/lx_brand/sys/lx_thread.h
usr/src/lib/brand/lx/lx_brand/sys/lx_thunk_server.h
usr/src/lib/brand/lx/lx_brand/sys/lx_types.h
usr/src/lib/brand/lx/lx_init/Makefile
usr/src/lib/brand/lx/lx_init/lxinit.c
usr/src/lib/brand/lx/lx_init/pipe_stream.c
usr/src/lib/brand/lx/lx_init/pipe_stream.h
usr/src/lib/brand/lx/lx_init/run_command.c
usr/src/lib/brand/lx/lx_init/run_command.h
usr/src/lib/brand/lx/lx_nametoaddr/Makefile
usr/src/lib/brand/lx/lx_nametoaddr/Makefile.com
usr/src/lib/brand/lx/lx_nametoaddr/amd64/Makefile
usr/src/lib/brand/lx/lx_nametoaddr/common/lx_nametoaddr.c
usr/src/lib/brand/lx/lx_nametoaddr/common/mapfile-vers
usr/src/lib/brand/lx/lx_nametoaddr/i386/Makefile
usr/src/lib/brand/lx/lx_support/Makefile
usr/src/lib/brand/lx/lx_support/lx_support.c
usr/src/lib/brand/lx/lx_thunk/Makefile
usr/src/lib/brand/lx/lx_thunk/Makefile.com
usr/src/lib/brand/lx/lx_thunk/amd64/Makefile
usr/src/lib/brand/lx/lx_thunk/common/lx_thunk.c
usr/src/lib/brand/lx/lx_thunk/common/mapfile-vers
usr/src/lib/brand/lx/lx_thunk/i386/Makefile
usr/src/lib/brand/lx/lx_thunk/sys/lx_thunk.h
usr/src/lib/brand/lx/lx_vdso/Makefile
usr/src/lib/brand/lx/lx_vdso/Makefile.com
usr/src/lib/brand/lx/lx_vdso/amd64/Makefile
usr/src/lib/brand/lx/lx_vdso/amd64/lx_vdso.s
usr/src/lib/brand/lx/lx_vdso/common/mapfile-vers
usr/src/lib/brand/lx/lx_vdso/tools/Makefile
usr/src/lib/brand/lx/lx_vdso/tools/vdso_tool.c
usr/src/lib/brand/lx/netfiles/Makefile
usr/src/lib/brand/lx/netfiles/etc_netconfig
usr/src/lib/brand/lx/testing/Makefile
usr/src/lib/brand/lx/testing/Readme_ltp
usr/src/lib/brand/lx/testing/ltp_skiplist
usr/src/lib/brand/lx/testing/ltp_tests
usr/src/lib/brand/lx/zone/Makefile
usr/src/lib/brand/lx/zone/SUNWlx.xml
usr/src/lib/brand/lx/zone/SUNWlx26.xml
usr/src/lib/brand/lx/zone/config.xml
usr/src/lib/brand/lx/zone/distros/Makefile
usr/src/lib/brand/lx/zone/distros/centos35.distro
usr/src/lib/brand/lx/zone/distros/centos36.distro
usr/src/lib/brand/lx/zone/distros/centos37.distro
usr/src/lib/brand/lx/zone/distros/centos38.distro
usr/src/lib/brand/lx/zone/distros/rhel35.distro
usr/src/lib/brand/lx/zone/distros/rhel36.distro
usr/src/lib/brand/lx/zone/distros/rhel37.distro
usr/src/lib/brand/lx/zone/distros/rhel38.distro
usr/src/lib/brand/lx/zone/distros/rhel_centos_common
usr/src/lib/brand/lx/zone/lx_boot.ksh
usr/src/lib/brand/lx/zone/lx_boot_zone_busybox.ksh
usr/src/lib/brand/lx/zone/lx_boot_zone_debian.ksh
usr/src/lib/brand/lx/zone/lx_boot_zone_redhat.ksh
usr/src/lib/brand/lx/zone/lx_boot_zone_ubuntu.ksh
usr/src/lib/brand/lx/zone/lx_distro_install.ksh
usr/src/lib/brand/lx/zone/lx_init_zone.ksh
usr/src/lib/brand/lx/zone/lx_init_zone_debian.ksh
usr/src/lib/brand/lx/zone/lx_init_zone_redhat.ksh
usr/src/lib/brand/lx/zone/lx_init_zone_ubuntu.ksh
usr/src/lib/brand/lx/zone/lx_install.ksh
usr/src/lib/brand/lx/zone/lx_networking.ksh
usr/src/lib/brand/lx/zone/platform.xml
usr/src/lib/brand/shared/zone/common.ksh
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/brand/shared/zone/common.ksh	Tue Jul 21 14:14:24 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/brand/shared/zone/common.ksh	Wed Jun 17 17:43:38 2015
@@ -19,6 +19,7 @@
 # CDDL HEADER END
 #
 # Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2014, Joyent, Inc. All rights reserved.
 #
 
 #
@@ -96,9 +97,27 @@
 safe_dir()
 {
 	typeset dir="$1"
+	typeset pwd_dir=""
 
-	if [[ -h $ZONEROOT/$dir || ! -d $ZONEROOT/$dir ]]; then
-		fatal "$e_baddir" "$dir"
+	if [[ -d $ZONEROOT/$dir ]]; then
+		if [[ -h $ZONEROOT/$dir ]]; then
+			#
+			# When dir is a symlink to a directory, we 'cd' to that
+			# directory to ensure that's under $ZONEROOT. We use pwd
+			# from /usr/bin instead of built-in because they give
+			# different results.
+			#
+			pwd_dir=$(cd $ZONEROOT/$dir && /usr/bin/pwd)
+			if [[ $pwd_dir =~ "^$ZONEROOT" ]]; then
+				return;
+			else
+				fatal \
+				    "$e_baddir: symlink out of zoneroot" "$dir"
+			fi
+		else
+			# it's a dir and not a symlink, so that's ok.
+			return
+		fi
 	fi
 }
 
@@ -109,9 +128,7 @@
 
 	[[ ! -e $ZONEROOT/$dir ]] && return
 
-	if [[ -h $ZONEROOT/$dir || ! -d $ZONEROOT/$dir ]]; then
-		fatal "$e_baddir" "$dir"
-	fi
+	safe_dir $dir
 }
 
 # Only make a copy if we haven't already done so.
@@ -187,7 +204,7 @@
 	fi
 
 	cat <<-END >$filename || exit 1
-	#!/bin/sh -p
+	#!/bin/sh
 	#
 	# Solaris Brand Replacement
 	#
@@ -333,10 +350,12 @@
 	#
 	# Check if the image was created with a valid libc.so.1.
 	#
-	hwcap=`moe -v -32 $ZONEROOT/lib/libc.so.1 2>&1`
-	if (( $? != 0 )); then
-		vlog "$f_hwcap_info" "$hwcap"
-		fail_fatal "$f_sanity_hwcap"
+	if [[ -f $ZONEROOT/lib/libc.so.1 ]]; then
+		hwcap=`moe -v -32 $ZONEROOT/lib/libc.so.1 2>&1`
+		if (( $? != 0 )); then
+			vlog "$f_hwcap_info" "$hwcap"
+			fail_fatal "$f_sanity_hwcap"
+		fi
 	fi
 
 	( cd "$ZONEROOT" && \
@@ -1003,41 +1022,36 @@
 	return 0
 }
 
-# Setup i18n output
-TEXTDOMAIN="SUNW_OST_OSCMD"
-export TEXTDOMAIN
-
-e_cannot_wrap=$(gettext "%s: error: wrapper file already exists")
-e_baddir=$(gettext "Invalid '%s' directory within the zone")
-e_badfile=$(gettext "Invalid '%s' file within the zone")
-e_path_abs=$(gettext "Pathname specified to -a '%s' must be absolute.")
-e_not_found=$(gettext "%s: error: file or directory not found.")
-e_install_abort=$(gettext "Installation aborted.")
-e_not_readable=$(gettext "Cannot read directory '%s'")
-e_not_dir=$(gettext "Error: must be a directory")
-e_unknown_archive=$(gettext "Error: Unknown archive format. Must be a flash archive, a cpio archive (can also be gzipped or bzipped), a pax XUSTAR archive, or a level 0 ufsdump archive.")
-e_absolute_archive=$(gettext "Error: archive contains absolute paths instead of relative paths.")
-e_mismatch_archive=$(gettext "Error: the archive top-level directory (%s) does not match the zonepath (%s).")
-e_tmpfile=$(gettext "Unable to create temporary file")
-e_root_full=$(gettext "Zonepath root %s exists and contains data; remove or move aside prior to install.")
-f_mkdir=$(gettext "Unable to create directory %s.")
-f_chmod=$(gettext "Unable to chmod directory %s.")
-f_chown=$(gettext "Unable to chown directory %s.")
-f_hwcap_info=$(gettext "HWCAP: %s\n")
-f_sanity_hwcap=$(gettext \
-"The image was created with an incompatible libc.so.1 hwcap lofs mount.\n"\
+e_cannot_wrap="%s: error: wrapper file already exists"
+e_baddir="Invalid '%s' directory within the zone"
+e_badfile="Invalid '%s' file within the zone"
+e_path_abs="Pathname specified to -a '%s' must be absolute."
+e_not_found="%s: error: file or directory not found."
+e_install_abort="Installation aborted."
+e_not_readable="Cannot read directory '%s'"
+e_not_dir="Error: must be a directory"
+e_unknown_archive="Error: Unknown archive format. Must be a flash archive, a cpio archive (can also be gzipped or bzipped), a pax XUSTAR archive, or a level 0 ufsdump archive."
+e_absolute_archive="Error: archive contains absolute paths instead of relative paths."
+e_mismatch_archive="Error: the archive top-level directory (%s) does not match the zonepath (%s)."
+e_tmpfile="Unable to create temporary file"
+e_root_full="Zonepath root %s exists and contains data; remove or move aside prior to install."
+f_mkdir="Unable to create directory %s."
+f_chmod="Unable to chmod directory %s."
+f_chown="Unable to chown directory %s."
+f_hwcap_info="HWCAP: %s\n"
+f_sanity_hwcap="The image was created with an incompatible libc.so.1 hwcap lofs mount.\n"\
 "       The zone will not boot on this platform.  See the zone's\n"\
-"       documentation for the recommended way to create the archive.")
+"       documentation for the recommended way to create the archive."
 
-m_analyse_archive=$(gettext "Analysing the archive")
+m_analyse_archive="Analysing the archive"
 
-not_readable=$(gettext "Cannot read file '%s'")
-not_flar=$(gettext "Input is not a flash archive")
-bad_flar=$(gettext "Flash archive is a corrupt")
-bad_zfs_flar=$(gettext "Flash archive contains a ZFS send stream.\n\tRecreate the flar using the -L option with cpio or pax.")
-f_unpack_failed=$(gettext "Unpacking the archive failed")
-unknown_archiver=$(gettext "Archiver %s is not supported")
-cmd_not_exec=$(gettext "Required command '%s' not executable!")
+not_readable="Cannot read file '%s'"
+not_flar="Input is not a flash archive"
+bad_flar="Flash archive is a corrupt"
+bad_zfs_flar="Flash archive contains a ZFS send stream.\n\tRecreate the flar using the -L option with cpio or pax."
+f_unpack_failed="Unpacking the archive failed"
+unknown_archiver="Archiver %s is not supported"
+cmd_not_exec="Required command '%s' not executable!"
 
 #
 # Exit values used by the script, as #defined in <sys/zone.h>
usr/src/lib/libbrand/common/libbrand.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libbrand/common/libbrand.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libbrand/common/libbrand.c	Wed Jun 17 17:43:39 2015
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
  */
 
@@ -323,6 +323,7 @@
     const char *curr_zone)
 {
 	int dst, src;
+	static char *env_pool = NULL;
 
 	/*
 	 * Walk through the characters, substituting values as needed.
@@ -339,6 +340,13 @@
 		case '%':
 			dst += strlcpy(dbuf + dst, "%", dbuf_size - dst);
 			break;
+		case 'P':
+			if (env_pool == NULL)
+				env_pool = getenv("_ZONEADMD_ZPOOL");
+			if (env_pool == NULL)
+				break;
+			dst += strlcpy(dbuf + dst, env_pool, dbuf_size - dst);
+			break;
 		case 'R':
 			if (zonepath == NULL)
 				break;
@@ -810,13 +818,14 @@
 }
 
 static int
-i_brand_platform_iter_mounts(struct brand_handle *bhp, const char *zonepath,
-    int (*func)(void *, const char *, const char *, const char *,
-    const char *), void *data, const xmlChar *mount_type)
+i_brand_platform_iter_mounts(struct brand_handle *bhp, const char *zonename,
+    const char *zonepath, int (*func)(void *, const char *, const char *,
+    const char *, const char *), void *data, const xmlChar *mount_type)
 {
 	xmlNodePtr node;
 	xmlChar *special, *dir, *type, *opt;
 	char special_exp[MAXPATHLEN];
+	char dir_exp[MAXPATHLEN];
 	char opt_exp[MAXPATHLEN];
 	int ret;
 
@@ -841,8 +850,12 @@
 		/* Substitute token values as needed. */
 		if ((ret = i_substitute_tokens((char *)special,
 		    special_exp, sizeof (special_exp),
-		    NULL, zonepath, NULL, NULL)) != 0)
+		    zonename, zonepath, NULL, NULL)) != 0)
 			goto next;
+		if ((ret = i_substitute_tokens((char *)dir,
+		    dir_exp, sizeof (dir_exp),
+		    zonename, zonepath, NULL, NULL)) != 0)
+			goto next;
 
 		/* opt might not be defined */
 		if (strlen((const char *)opt) == 0) {
@@ -851,11 +864,11 @@
 		} else {
 			if ((ret = i_substitute_tokens((char *)opt,
 			    opt_exp, sizeof (opt_exp),
-			    NULL, zonepath, NULL, NULL)) != 0)
+			    zonename, zonepath, NULL, NULL)) != 0)
 				goto next;
 		}
 
-		ret = func(data, (char *)special_exp, (char *)dir,
+		ret = func(data, (char *)special_exp, (char *)dir_exp,
 		    (char *)type, ((opt != NULL) ? opt_exp : NULL));
 
 next:
@@ -885,13 +898,13 @@
  *	%R	Zonepath of zone
  */
 int
-brand_platform_iter_gmounts(brand_handle_t bh, const char *zonepath,
-    int (*func)(void *, const char *, const char *, const char *,
-    const char *), void *data)
+brand_platform_iter_gmounts(brand_handle_t bh, const char *zonename,
+    const char *zonepath, int (*func)(void *, const char *, const char *,
+    const char *, const char *), void *data)
 {
 	struct brand_handle *bhp = (struct brand_handle *)bh;
-	return (i_brand_platform_iter_mounts(bhp, zonepath, func, data,
-	    DTD_ELEM_GLOBAL_MOUNT));
+	return (i_brand_platform_iter_mounts(bhp, zonename, zonepath, func,
+	    data, DTD_ELEM_GLOBAL_MOUNT));
 }
 
 /*
@@ -905,7 +918,7 @@
     const char *, const char *, const char *, const char *), void *data)
 {
 	struct brand_handle *bhp = (struct brand_handle *)bh;
-	return (i_brand_platform_iter_mounts(bhp, NULL, func, data,
+	return (i_brand_platform_iter_mounts(bhp, NULL, NULL, func, data,
 	    DTD_ELEM_MOUNT));
 }
 
usr/src/lib/libc/amd64/gen/siginfolst.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/amd64/gen/siginfolst.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/amd64/gen/siginfolst.c	Wed Jun 17 17:43:39 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -188,6 +189,7 @@
 	0,		0,
 	0,		0,
 	0,		0,			/* SIGRTMIN+15 */
+	0,		0,			/* SIGRTMIN+16 */
 	0,		0,			/* SIGRTMAX-15 */
 	0,		0,
 	0,		0,
usr/src/lib/libc/i386/gen/siginfolst.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/i386/gen/siginfolst.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/i386/gen/siginfolst.c	Wed Jun 17 17:43:39 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -188,6 +189,7 @@
 	0,		0,
 	0,		0,
 	0,		0,			/* SIGRTMIN+15 */
+	0,		0,			/* SIGRTMIN+16 */
 	0,		0,			/* SIGRTMAX-15 */
 	0,		0,
 	0,		0,
usr/src/lib/libc/inc/thr_uberdata.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/inc/thr_uberdata.h	Wed Sep 16 08:01:39 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/inc/thr_uberdata.h	Wed Jun 17 17:43:39 2015
@@ -932,6 +932,7 @@
 	int	ndaemons;	/* total number of THR_DAEMON threads/lwps */
 	pid_t	pid;		/* the current process's pid */
 	void	(*sigacthandler)(int, siginfo_t *, void *);
+	int	(*setctxt)(const ucontext_t *);
 	ulwp_t	*lwp_stacks;
 	ulwp_t	*lwp_laststack;
 	int	nfreestack;
@@ -944,6 +945,7 @@
 	robust_t	**robustlocks;	/* table of registered robust locks */
 	robust_t	*robustlist;	/* list of registered robust locks */
 	char	*progname;	/* the basename of the program, from argv[0] */
+	char	*ub_broot;	/* the root of the native code in the brand */
 	struct uberdata **tdb_bootstrap;
 	tdb_t	tdb;		/* thread debug interfaces (for libc_db) */
 } uberdata_t;
@@ -1144,6 +1146,7 @@
 	int		ndaemons;
 	int		pid;
 	caddr32_t	sigacthandler;
+	caddr32_t	setctxt;
 	caddr32_t	lwp_stacks;
 	caddr32_t	lwp_laststack;
 	int		nfreestack;
@@ -1245,6 +1248,7 @@
 extern	void	heldlock_exit(void);
 extern	void	heldlock_free(ulwp_t *);
 extern	void	sigacthandler(int, siginfo_t *, void *);
+extern	int	setctxt(const ucontext_t *);
 extern	void	signal_init(void);
 extern	int	sigequalset(const sigset_t *, const sigset_t *);
 extern	void	mutex_setup(void);
usr/src/lib/libc/port/gen/getauxv.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/gen/getauxv.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/gen/getauxv.c	Wed Jun 17 17:43:39 2015
@@ -24,9 +24,8 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "lint.h"
+#include "thr_uberdata.h"
 #include <libc.h>
 #include <fcntl.h>
 #include <stdlib.h>
@@ -38,6 +37,7 @@
 #include <thread.h>
 #include <synch.h>
 #include <atomic.h>
+#include <limits.h>
 
 static mutex_t auxlock = DEFAULTMUTEX;
 
@@ -59,11 +59,20 @@
 	if (auxb == NULL) {
 		lmutex_lock(&auxlock);
 		if (auxb == NULL) {
+			uberdata_t *udp = curthread->ul_uberdata;
 			struct stat statb;
 			auxv_t *buf = NULL;
+			char *path = "/proc/self/auxv";
+			char pbuf[PATH_MAX];
 			int fd;
 
-			if ((fd = open("/proc/self/auxv", O_RDONLY)) != -1 &&
+			if (udp->ub_broot != NULL) {
+				(void) snprintf(pbuf, sizeof (pbuf),
+				    "%s/proc/self/auxv", udp->ub_broot);
+				path = pbuf;
+			}
+
+			if ((fd = open(path, O_RDONLY)) != -1 &&
 			    fstat(fd, &statb) != -1)
 				buf = libc_malloc(
 				    statb.st_size + sizeof (auxv_t));
usr/src/lib/libc/port/gen/siglist.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/gen/siglist.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/gen/siglist.c	Wed Jun 17 17:43:39 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -128,6 +129,7 @@
 		"Fourteenth Realtime Signal",		/* SIGRTMIN+13	*/
 		"Fifteenth Realtime Signal",		/* SIGRTMIN+14	*/
 		"Sixteenth Realtime Signal",		/* SIGRTMIN+15	*/
+		"Seventeenth Realtime Signal",		/* SIGRTMIN+16	*/
 		"Sixteenth Last Realtime Signal",	/* SIGRTMAX-15	*/
 		"Fifteenth Last Realtime Signal",	/* SIGRTMAX-14	*/
 		"Fourteenth Last Realtime Signal",	/* SIGRTMAX-13	*/
usr/src/lib/libc/port/gen/str2sig.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/gen/str2sig.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/gen/str2sig.c	Wed Jun 17 17:43:39 2015
@@ -22,7 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -102,6 +102,7 @@
 	{ "RTMIN+13",	_SIGRTMIN+13 },
 	{ "RTMIN+14",	_SIGRTMIN+14 },
 	{ "RTMIN+15",	_SIGRTMIN+15 },
+	{ "RTMIN+16",	_SIGRTMIN+16 },
 	{ "RTMAX-15",	_SIGRTMAX-15 },
 	{ "RTMAX-14",	_SIGRTMAX-14 },
 	{ "RTMAX-13",	_SIGRTMAX-13 },
usr/src/lib/libc/port/mapfile-vers
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/mapfile-vers	Mon Dec  7 18:06:21 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/mapfile-vers	Mon Dec 14 10:47:45 2015
@@ -2926,6 +2926,10 @@
 	__idmap_unreg;
 	__init_daemon_priv;
 	__init_suid_priv;
+	inotify_init;
+	inotify_init1;
+	inotify_add_watch;
+	inotify_rm_watch;
 	_insert;
 	inst_sync;
 	_iswctype;
@@ -3004,7 +3008,9 @@
 	scrwidth;
 	semctl64;
 	_semctl64;
+	set_escaped_context_cleanup;
 	set_setcontext_enforcement;
+	setcontext_sigmask;
 	_setbufend;
 	__set_errno;
 	setprojrctl;
@@ -3121,6 +3127,7 @@
 	zone_list;
 	zone_list_datalink;
 	zonept;
+	zone_get_nroot;
 	zone_remove_datalink;
 	zone_setattr;
 	zone_shutdown;
usr/src/lib/libc/port/sys/zone.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/sys/zone.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/sys/zone.c	Wed Jun 17 17:43:39 2015
@@ -22,9 +22,11 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2011 Joyent Inc.  All rights reserved.
  */
 
 #include "lint.h"
+#include "thr_uberdata.h"
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <sys/zone.h>
@@ -39,7 +41,8 @@
 zoneid_t
 zone_create(const char *name, const char *root, const struct priv_set *privs,
     const char *rctls, size_t rctlsz, const char *zfs, size_t zfssz,
-    int *extended_error, int match, int doi, const bslabel_t *label, int flags)
+    int *extended_error, int match, int doi, const bslabel_t *label, int flags,
+    zoneid_t req_zoneid)
 {
 	zone_def  zd;
 	priv_data_t *d;
@@ -59,6 +62,7 @@
 	zd.doi = doi;
 	zd.label = label;
 	zd.flags = flags;
+	zd.zoneid = req_zoneid;
 
 	return ((zoneid_t)syscall(SYS_zone, ZONE_CREATE, &zd));
 }
@@ -240,4 +244,11 @@
 zone_list_datalink(zoneid_t zoneid, int *dlnump, datalink_id_t *linkids)
 {
 	return (syscall(SYS_zone, ZONE_LIST_DATALINK, zoneid, dlnump, linkids));
+}
+
+const char *
+zone_get_nroot()
+{
+	uberdata_t *udp = curthread->ul_uberdata;
+	return (udp->ub_broot);
 }
usr/src/lib/libc/port/threads/sigaction.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/threads/sigaction.c	Mon Dec  7 23:29:56 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/threads/sigaction.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include "lint.h"
@@ -284,7 +285,25 @@
 		thr_panic("take_deferred_signal(): __sigresend() failed");
 }
 
+/*
+ * sigacthandler() attempts to clean up dangling uc_link pointers in
+ * signal handling contexts when libc believes us to have escaped
+ * a signal handler incorrectly in the past.
+ *
+ * Branded processes have a legitimate use for a chain including contexts
+ * other than those used for signal handling when tracking emulation
+ * requests from the kernel.  We allow them to disable this cleanup
+ * behaviour.
+ */
+static int escaped_context_cleanup = 1;
+
 void
+set_escaped_context_cleanup(int on)
+{
+	escaped_context_cleanup = on;
+}
+
+void
 sigacthandler(int sig, siginfo_t *sip, void *uvp)
 {
 	ucontext_t *ucp = uvp;
@@ -306,7 +325,7 @@
 	 * we are actually executing at main level (self->ul_siglink == NULL).
 	 * See the code for setjmp()/longjmp() for more details.
 	 */
-	if (self->ul_siglink == NULL)
+	if (escaped_context_cleanup && self->ul_siglink == NULL)
 		ucp->uc_link = NULL;
 
 	/*
@@ -458,11 +477,12 @@
 }
 
 /*
- * This is a private interface for the linux brand interface.
+ * This is a private interface for the lx brand.
  */
 void
 setsigacthandler(void (*nsigacthandler)(int, siginfo_t *, void *),
-    void (**osigacthandler)(int, siginfo_t *, void *))
+    void (**osigacthandler)(int, siginfo_t *, void *),
+    int (*brsetctxt)(const ucontext_t *))
 {
 	ulwp_t *self = curthread;
 	uberdata_t *udp = self->ul_uberdata;
@@ -471,6 +491,9 @@
 		*osigacthandler = udp->sigacthandler;
 
 	udp->sigacthandler = nsigacthandler;
+
+	if (brsetctxt != NULL)
+		udp->setctxt = brsetctxt;
 }
 
 /*
@@ -517,11 +540,39 @@
 	setcontext_enforcement = on;
 }
 
+/*
+ * The LX brand emulation library implements an operation that is analogous to
+ * setcontext(), but takes a different path in to the kernel.  So that it can
+ * correctly restore a signal mask, we expose just the signal mask handling
+ * part of the regular setcontext() routine as a private interface.
+ */
+void
+setcontext_sigmask(ucontext_t *ucp)
+{
+	ulwp_t *self = curthread;
+
+	if (ucp->uc_flags & UC_SIGMASK) {
+		block_all_signals(self);
+		delete_reserved_signals(&ucp->uc_sigmask);
+		self->ul_sigmask = ucp->uc_sigmask;
+		if (self->ul_cursig) {
+			/*
+			 * We have a deferred signal present.
+			 * The signal mask will be set when the
+			 * signal is taken in take_deferred_signal().
+			 */
+			ASSERT(self->ul_critical + self->ul_sigdefer != 0);
+			ucp->uc_flags &= ~UC_SIGMASK;
+		}
+	}
+}
+
 #pragma weak _setcontext = setcontext
 int
 setcontext(const ucontext_t *ucp)
 {
 	ulwp_t *self = curthread;
+	uberdata_t *udp = self->ul_uberdata;
 	int ret;
 	ucontext_t uc;
 
@@ -536,20 +587,7 @@
 	/*
 	 * Restore previous signal mask and context link.
 	 */
-	if (uc.uc_flags & UC_SIGMASK) {
-		block_all_signals(self);
-		delete_reserved_signals(&uc.uc_sigmask);
-		self->ul_sigmask = uc.uc_sigmask;
-		if (self->ul_cursig) {
-			/*
-			 * We have a deferred signal present.
-			 * The signal mask will be set when the
-			 * signal is taken in take_deferred_signal().
-			 */
-			ASSERT(self->ul_critical + self->ul_sigdefer != 0);
-			uc.uc_flags &= ~UC_SIGMASK;
-		}
-	}
+	setcontext_sigmask(&uc);
 	self->ul_siglink = uc.uc_link;
 
 	/*
@@ -578,7 +616,7 @@
 	 */
 	set_parking_flag(self, 0);
 	self->ul_sp = 0;
-	ret = __setcontext(&uc);
+	ret = udp->setctxt(&uc);
 
 	/*
 	 * It is OK for setcontext() to return if the user has not specified
usr/src/lib/libc/port/threads/thr.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/port/threads/thr.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/port/threads/thr.c	Wed Jun 17 17:43:39 2015
@@ -23,7 +23,7 @@
  * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
  */
 /*
- * Copyright (c) 2012, Joyent, Inc. All rights reserved.
+ * Copyright 2014 Joyent, Inc. All rights reserved.
  */
 
 #include "lint.h"
@@ -124,6 +124,7 @@
 	0,			/* ndaemons */
 	0,			/* pid */
 	sigacthandler,		/* sigacthandler */
+	__setcontext,		/* setctxt */
 	NULL,			/* lwp_stacks */
 	NULL,			/* lwp_laststack */
 	0,			/* nfreestack */
@@ -136,6 +137,7 @@
 	NULL,			/* robustlocks */
 	NULL,			/* robustlist */
 	NULL,			/* progname */
+	NULL,			/* ub_broot */
 	NULL,			/* __tdb_bootstrap */
 	{			/* tdb */
 		NULL,		/* tdb_sync_addr_hash */
@@ -1219,6 +1221,24 @@
 extern void __proc64id(void);
 #endif
 
+static void
+init_brandroot(uberdata_t *udp)
+{
+	Dl_argsinfo_t args;
+
+	udp->ub_broot = NULL;
+	if (dlinfo(RTLD_SELF, RTLD_DI_ARGSINFO, &args) < 0)
+		return;
+
+	while (args.dla_auxv->a_type != AT_NULL) {
+		if (args.dla_auxv->a_type == AT_SUN_BRAND_NROOT) {
+			udp->ub_broot = args.dla_auxv->a_un.a_ptr;
+			return;
+		}
+		args.dla_auxv++;
+	}
+}
+
 /*
  * libc_init() is called by ld.so.1 for library initialization.
  * We perform minimal initialization; enough to work with the main thread.
@@ -1255,6 +1275,13 @@
 	(void) _atexit(__cleanup);
 
 	/*
+	 * Every libc, regardless of link map, needs to go through and check its
+	 * aux vectors so as to indicate whether or not this has been given a
+	 * brand root with which we use to qualify various other data.
+	 */
+	init_brandroot(udp);
+
+	/*
 	 * We keep our uberdata on one of (a) the first alternate link map
 	 * or (b) the primary link map.  We switch to the primary link map
 	 * and stay there once we see it.  All intermediate link maps are
usr/src/lib/libc/sparc/gen/siginfolst.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/sparc/gen/siginfolst.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/sparc/gen/siginfolst.c	Wed Jun 17 17:43:39 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -188,6 +189,7 @@
 	0,		0,
 	0,		0,
 	0,		0,			/* SIGRTMIN+15 */
+	0,		0,			/* SIGRTMIN+16 */
 	0,		0,			/* SIGRTMAX-15 */
 	0,		0,
 	0,		0,
usr/src/lib/libc/sparcv9/Makefile.com
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/sparcv9/Makefile.com	Mon Dec  7 18:06:21 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/sparcv9/Makefile.com	Mon Dec 14 10:47:45 2015
@@ -882,6 +882,7 @@
 	chmod.o			\
 	chown.o			\
 	corectl.o		\
+	epoll.o			\
 	eventfd.o		\
 	epoll.o			\
 	exacctsys.o		\
@@ -921,6 +922,7 @@
 	sidsys.o		\
 	siginterrupt.o		\
 	signal.o		\
+	signalfd.o		\
 	sigpending.o		\
 	sigstack.o		\
 	stat.o			\
usr/src/lib/libc/sparcv9/gen/siginfolst.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libc/sparcv9/gen/siginfolst.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libc/sparcv9/gen/siginfolst.c	Wed Jun 17 17:43:39 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -188,6 +189,7 @@
 	0,		0,
 	0,		0,
 	0,		0,			/* SIGRTMIN+15 */
+	0,		0,			/* SIGRTMIN+16 */
 	0,		0,			/* SIGRTMAX-15 */
 	0,		0,
 	0,		0,
usr/src/lib/libcmdutils/common/custr.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libcmdutils/common/custr.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libcmdutils/common/custr.c	Wed Aug 19 10:40:33 2015
@@ -14,19 +14,27 @@
  */
 
 /*
- * Copyright 2014, Joyent, Inc.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <stdlib.h>
 #include <err.h>
 #include <string.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/debug.h>
 
 #include "libcmdutils.h"
 
+typedef enum {
+	CUSTR_FIXEDBUF	= 0x01
+} custr_flags_t;
+
 struct custr {
 	size_t cus_strlen;
 	size_t cus_datalen;
 	char *cus_data;
+	custr_flags_t cus_flags;
 };
 
 #define	STRING_CHUNK_SIZE	64
@@ -50,26 +58,28 @@
 const char *
 custr_cstr(custr_t *cus)
 {
+	if (cus->cus_data == NULL) {
+		VERIFY(cus->cus_strlen == 0);
+		VERIFY(cus->cus_datalen == 0);
+
+		/*
+		 * This function should never return NULL.  If no buffer has
+		 * been allocated, return a pointer to a zero-length string.
+		 */
+		return ("");
+	}
 	return (cus->cus_data);
 }
 
-int
-custr_appendc(custr_t *cus, char newc)
+static int
+custr_append_vprintf(custr_t *cus, const char *fmt, va_list ap)
 {
-	char news[2];
-
-	news[0] = newc;
-	news[1] = '\0';
-
-	return (custr_append(cus, news));
-}
-
-int
-custr_append(custr_t *cus, const char *news)
-{
-	size_t len = strlen(news);
+	int len = vsnprintf(NULL, 0, fmt, ap);
 	size_t chunksz = STRING_CHUNK_SIZE;
 
+	if (len == -1)
+		return (len);
+
 	while (chunksz < len) {
 		chunksz *= 2;
 	}
@@ -78,6 +88,11 @@
 		char *new_data;
 		size_t new_datalen = cus->cus_datalen + chunksz;
 
+		if (cus->cus_flags & CUSTR_FIXEDBUF) {
+			errno = EOVERFLOW;
+			return (-1);
+		}
+
 		/*
 		 * Allocate replacement memory:
 		 */
@@ -104,7 +119,10 @@
 	/*
 	 * Append new string to existing string:
 	 */
-	(void) memcpy(cus->cus_data + cus->cus_strlen, news, len + 1);
+	len = vsnprintf(cus->cus_data + cus->cus_strlen,
+	    (uintptr_t)cus->cus_data - (uintptr_t)cus->cus_strlen, fmt, ap);
+	if (len == -1)
+		return (len);
 	cus->cus_strlen += len;
 
 	return (0);
@@ -111,6 +129,31 @@
 }
 
 int
+custr_appendc(custr_t *cus, char newc)
+{
+	return (custr_append_printf(cus, "%c", newc));
+}
+
+int
+custr_append_printf(custr_t *cus, const char *fmt, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap, fmt);
+	ret = custr_append_vprintf(cus, fmt, ap);
+	va_end(ap);
+
+	return (ret);
+}
+
+int
+custr_append(custr_t *cus, const char *name)
+{
+	return (custr_append_printf(cus, "%s", name));
+}
+
+int
 custr_alloc(custr_t **cus)
 {
 	custr_t *t;
@@ -124,6 +167,28 @@
 	return (0);
 }
 
+int
+custr_alloc_buf(custr_t **cus, void *buf, size_t buflen)
+{
+	int ret;
+
+	if (buflen == 0 || buf == NULL) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if ((ret = custr_alloc(cus)) != 0)
+		return (ret);
+
+	(*cus)->cus_data = buf;
+	(*cus)->cus_datalen = buflen;
+	(*cus)->cus_strlen = 0;
+	(*cus)->cus_flags = CUSTR_FIXEDBUF;
+	(*cus)->cus_data[0] = '\0';
+
+	return (0);
+}
+
 void
 custr_free(custr_t *cus)
 {
@@ -130,6 +195,7 @@
 	if (cus == NULL)
 		return;
 
-	free(cus->cus_data);
+	if ((cus->cus_flags & CUSTR_FIXEDBUF) == 0)
+		free(cus->cus_data);
 	free(cus);
 }
usr/src/lib/libcurses/screen/setupterm.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libcurses/screen/setupterm.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libcurses/screen/setupterm.c	Wed Jun 17 17:43:39 2015
@@ -37,8 +37,6 @@
  * contributors.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 /*LINTLIBRARY*/
 
 #include	<stdio.h>
@@ -48,6 +46,7 @@
 #include	<string.h>
 #include	<unistd.h>
 #include	<errno.h>
+#include	<zone.h>
 #include	"curses_inc.h"
 
 #define	TERMPATH	"/usr/share/lib/terminfo/"
@@ -272,9 +271,11 @@
 	}
 
 	if (tfd < 0) {
+		const char *zroot = zone_get_nroot();
 		/* /usr/share/lib/terminfo/?/$TERM */
 		if (snprintf(fname, sizeof (fname),
-			"%s/%c/%s", TERMPATH, *term, term) >= sizeof (fname)) {
+			"%s/%s/%c/%s", zroot == NULL ? "" : zroot, TERMPATH,
+			*term, term) >= sizeof (fname)) {
 			term_errno = TERMINFO_TOO_LONG;
 			goto out_err;
 		}
usr/src/lib/libdhcpagent/common/dhcpagent_util.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libdhcpagent/common/dhcpagent_util.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libdhcpagent/common/dhcpagent_util.c	Wed Oct 14 16:03:01 2015
@@ -36,6 +36,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <zone.h>
 
 #include "dhcpagent_ipc.h"
 #include "dhcpagent_util.h"
@@ -125,7 +126,13 @@
 	int			ctfd;
 	pid_t			childpid;
 	ctid_t			ct;
+	char			dhcpcmd[MAXPATHLEN];
+	const char		*zroot = zone_get_nroot();
 
+	/* Prepend the root of the native code in the brand to the command */
+	(void) snprintf(dhcpcmd, sizeof (dhcpcmd), "%s%s", zroot != NULL ?
+	    zroot : "", DHCP_AGENT_PATH);
+
 	/*
 	 * just send a dummy request to the agent to find out if it's
 	 * up.  we do this instead of directly connecting to it since
@@ -160,7 +167,7 @@
 		goto fail;
 
 	case  0:
-		(void) execl(DHCP_AGENT_PATH, DHCP_AGENT_PATH, (char *)0);
+		(void) execl(dhcpcmd, dhcpcmd, (char *)0);
 		_exit(EXIT_FAILURE);
 
 	default:
usr/src/lib/libdtrace/common/dt_open.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libdtrace/common/dt_open.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libdtrace/common/dt_open.c	Wed Jun 17 17:43:39 2015
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc.
  * Copyright (c) 2012 by Delphix. All rights reserved.
  */
 
@@ -40,6 +40,7 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <assert.h>
+#include <zone.h>
 
 #define	_POSIX_PTHREAD_SEMANTICS
 #include <dirent.h>
@@ -683,8 +684,8 @@
 { DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_COMMON },
 };
 
-const char *_dtrace_defcpp = "/usr/ccs/lib/cpp"; /* default cpp(1) to invoke */
-const char *_dtrace_defld = "/usr/ccs/bin/ld";   /* default ld(1) to invoke */
+const char *_dtrace_defcpp = "/usr/lib/cpp"; /* default cpp(1) to invoke */
+const char *_dtrace_defld = "/usr/bin/ld";   /* default ld(1) to invoke */
 
 const char *_dtrace_libdir = "/usr/lib/dtrace"; /* default library directory */
 const char *_dtrace_provdir = "/dev/dtrace/provider"; /* provider directory */
@@ -824,6 +825,8 @@
 	dt_provmod_t *provmod = NULL;
 	int i, err;
 	struct rlimit rl;
+	const char *zroot;
+	char *libpath = NULL;
 
 	const dt_intrinsic_t *dinp;
 	const dt_typedef_t *dtyp;
@@ -956,11 +959,19 @@
 	dtp->dt_provs = calloc(dtp->dt_provbuckets, sizeof (dt_provider_t *));
 	dt_proc_init(dtp);
 	dtp->dt_vmax = DT_VERS_LATEST;
-	dtp->dt_cpp_path = strdup(_dtrace_defcpp);
+	zroot = zone_get_nroot();
+	if (zroot != NULL) {
+		(void) asprintf(&dtp->dt_ld_path, "%s/%s", zroot,
+		    _dtrace_defld);
+		(void) asprintf(&dtp->dt_cpp_path, "%s/%s", zroot,
+		    _dtrace_defcpp);
+	} else {
+		dtp->dt_ld_path = strdup(_dtrace_defld);
+		dtp->dt_cpp_path = strdup(_dtrace_defcpp);
+	}
 	dtp->dt_cpp_argv = malloc(sizeof (char *));
 	dtp->dt_cpp_argc = 1;
 	dtp->dt_cpp_args = 1;
-	dtp->dt_ld_path = strdup(_dtrace_defld);
 	dtp->dt_provmod = provmod;
 	dtp->dt_vector = vector;
 	dtp->dt_varg = arg;
@@ -1134,13 +1145,13 @@
 	 * Add intrinsic pointer types that are needed to initialize printf
 	 * format dictionary types (see table in dt_printf.c).
 	 */
-	(void) ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT,
+	(void) ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT, NULL,
 	    ctf_lookup_by_name(dmp->dm_ctfp, "void"));
 
-	(void) ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT,
+	(void) ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT, NULL,
 	    ctf_lookup_by_name(dmp->dm_ctfp, "char"));
 
-	(void) ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT,
+	(void) ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT, NULL,
 	    ctf_lookup_by_name(dmp->dm_ctfp, "int"));
 
 	if (ctf_update(dmp->dm_ctfp) != 0) {
@@ -1200,11 +1211,11 @@
 	ctc.ctc_argc = 0;
 	ctc.ctc_flags = 0;
 
-	dtp->dt_type_func = ctf_add_function(dmp->dm_ctfp,
+	dtp->dt_type_func = ctf_add_funcptr(dmp->dm_ctfp,
 	    CTF_ADD_ROOT, &ctc, NULL);
 
-	dtp->dt_type_fptr = ctf_add_pointer(dmp->dm_ctfp,
-	    CTF_ADD_ROOT, dtp->dt_type_func);
+	dtp->dt_type_fptr = ctf_add_pointer(dmp->dm_ctfp, CTF_ADD_ROOT, NULL,
+	    dtp->dt_type_func);
 
 	/*
 	 * We also insert CTF definitions for the special D intrinsic types
@@ -1305,9 +1316,15 @@
 	 * compile, and to provide better error reporting (because the full
 	 * reporting of compiler errors requires dtrace_open() to succeed).
 	 */
-	if (dtrace_setopt(dtp, "libdir", _dtrace_libdir) != 0)
+	if (zroot != NULL)
+		(void) asprintf(&libpath, "%s/%s", zroot, _dtrace_libdir);
+	if (dtrace_setopt(dtp, "libdir",
+	    libpath != NULL ? libpath : _dtrace_libdir) != 0)
 		return (set_open_errno(dtp, errp, dtp->dt_errno));
 
+	if (libpath != NULL)
+		free(libpath);
+
 	return (dtp);
 }
 
usr/src/lib/libipadm/common/libipadm.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libipadm/common/libipadm.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libipadm/common/libipadm.c	Wed Jun 17 17:43:39 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
  */
 
@@ -285,11 +286,19 @@
 boolean_t
 ipadm_check_auth(void)
 {
+	int		uid;
 	struct passwd	pwd;
 	char		buf[NSS_BUFLEN_PASSWD];
 
+	/*
+	 * Branded zones may have different kinds of auth, but root always
+	 * allowed.
+	 */
+	if ((uid = getuid()) == 0)
+		return (B_TRUE);
+
 	/* get the password entry for the given user ID */
-	if (getpwuid_r(getuid(), &pwd, buf, sizeof (buf)) == NULL)
+	if (getpwuid_r(uid, &pwd, buf, sizeof (buf)) == NULL)
 		return (B_FALSE);
 
 	/* check for presence of given authorization */
@@ -897,9 +906,21 @@
 
 reopen:
 	(void) pthread_mutex_lock(&iph->iph_lock);
-	/* The door descriptor is opened if it isn't already */
+	/*
+	 * The door descriptor is opened if it isn't already.
+	 */
 	if (iph->iph_door_fd == -1) {
-		if ((iph->iph_door_fd = open(IPMGMT_DOOR, O_RDONLY)) < 0) {
+		char door[MAXPATHLEN];
+		const char *zroot = zone_get_nroot();
+
+		/*
+		 * If this is a branded zone, make sure we use the "/native"
+		 * prefix for the door path:
+		 */
+		(void) snprintf(door, sizeof (door), "%s%s", zroot != NULL ?
+		    zroot : "", IPMGMT_DOOR);
+
+		if ((iph->iph_door_fd = open(door, O_RDONLY)) < 0) {
 			err = errno;
 			(void) pthread_mutex_unlock(&iph->iph_lock);
 			return (err);
usr/src/lib/libnsl/common/mapfile-vers
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libnsl/common/mapfile-vers	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libnsl/common/mapfile-vers	Wed Jun 17 17:43:40 2015
@@ -21,6 +21,7 @@
 #
 # Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2015 Joyent, Inc.
 #
 
 #
@@ -467,6 +468,7 @@
 
 SYMBOL_VERSION SUNWprivate_1.5 {
     global:
+ 	_nsl_brand_set_hooks;
 	clnt_create_service_timed;
 	inet_matchaddr;
 } SUNWprivate_1.4;
usr/src/lib/libnsl/netselect/netselect.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libnsl/netselect/netselect.c	Tue Jul 21 14:14:25 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libnsl/netselect/netselect.c	Wed Jun 17 17:43:40 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -32,8 +33,6 @@
  * under license from the Regents of the University of California.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "mt.h"
 #include "../rpc/rpc_mt.h"		/* for MT declarations only */
 #include <rpc/types.h>
@@ -45,6 +44,7 @@
 #include <malloc.h>
 #include <libintl.h>
 #include <syslog.h>
+#include <zone.h>
 #include "netcspace.h"
 
 #define	FAILURE  (unsigned)(-1)
@@ -70,6 +70,9 @@
 
 extern const char __nsl_dom[];
 
+static int (*brand_get_sz)(void) = NULL;
+static struct netconfig *(*brand_get_net_ent)(int) = NULL;
+
 /*
  *	Static global variables used by the library procedures:
  *
@@ -255,6 +258,14 @@
 	netconfig_free(netp);
 }
 
+void
+_nsl_brand_set_hooks(int (*set_sz_func)(void),
+    struct netconfig *(*get_ent_func)(int))
+{
+	brand_get_sz = set_sz_func;
+	brand_get_net_ent = get_ent_func;
+}
+
 /*
  *	getnetlist() reads the netconfig file and creates a
  *	NULL-terminated list of entries.
@@ -265,52 +276,82 @@
 static struct netconfig **
 getnetlist(void)
 {
-	char line[BUFSIZ];	/* holds each line of NETCONFIG */
-	FILE *fp;		/* file stream for NETCONFIG */
+	FILE *fp = NULL;	/* file stream for NETCONFIG */
 	struct netconfig **listpp; /* the beginning of the netconfig list */
 	struct netconfig **tpp;	/* used to traverse the netconfig list */
 	int count;		/* the number of entries in file */
+	char nc_path[MAXPATHLEN];
+	const char *zroot = zone_get_nroot();
 
-	if ((fp = fopen(NETCONFIG, "rF")) == NULL) {
-		nc_error = NC_OPENFAIL;
-		return (NULL);
-	}
+	/*
+	 * If we are running in a branded zone, ensure we use the "/native"
+	 * prefix when opening the netconfig file:
+	 */
+	(void) snprintf(nc_path, sizeof (nc_path), "%s%s", zroot != NULL ?
+	    zroot : "", NETCONFIG);
 
-	count = 0;
-	while (fgets(line, BUFSIZ, fp)) {
-		if (!(blank(line) || comment(line))) {
-			++count;
+	if (brand_get_sz != NULL) {
+		count = brand_get_sz();
+	} else {
+		char line[BUFSIZ];	/* holds each line of NETCONFIG */
+
+		if ((fp = fopen(nc_path, "rF")) == NULL) {
+			nc_error = NC_OPENFAIL;
+			return (NULL);
 		}
+
+		count = 0;
+		while (fgets(line, BUFSIZ, fp)) {
+			if (!(blank(line) || comment(line))) {
+				++count;
+			}
+		}
+		rewind(fp);
 	}
-	rewind(fp);
 
 	if (count == 0) {
 		nc_error = NC_NOTFOUND;
-		(void) fclose(fp);
+		if (fp != NULL)
+			(void) fclose(fp);
 		return (NULL);
 	}
+
 	if ((listpp = malloc((count + 1) *
 	    sizeof (struct netconfig *))) == NULL) {
 		nc_error = NC_NOMEM;
-		(void) fclose(fp);
+		if (fp != NULL)
+			(void) fclose(fp);
 		return (NULL);
 	}
 
-	/*
-	 *	The following loop fills in the list (loops until
-	 *	fgetnetconfig() returns a NULL) and counts the
-	 *	number of entries placed in the list.  Note that
-	 *	when the loop is completed, the last entry in the
-	 *	list will contain a NULL (signifying the end of
-	 *	the list).
-	 */
-	linenum = 0;
-	for (tpp = listpp; *tpp = fgetnetconfig(fp, NULL); tpp++)
-		;
-	(void) fclose(fp);
+	if (brand_get_net_ent != NULL) {
+		int i;
 
-	if (nc_error != NC_NOMOREENTRIES) /* Something is screwed up */
-		netlist_free(&listpp);
+		tpp = listpp;
+		for (i = 0; i < count; i++) {
+			*tpp = brand_get_net_ent(i);
+			tpp++;
+		}
+		*tpp = NULL;
+		nc_error = NC_NOMOREENTRIES;
+	} else {
+		/*
+		 *	The following loop fills in the list (loops until
+		 *	fgetnetconfig() returns a NULL) and counts the
+		 *	number of entries placed in the list.  Note that
+		 *	when the loop is completed, the last entry in the
+		 *	list will contain a NULL (signifying the end of
+		 *	the list).
+		 */
+		linenum = 0;
+		for (tpp = listpp; *tpp = fgetnetconfig(fp, NULL); tpp++)
+			;
+		(void) fclose(fp);
+
+		if (nc_error != NC_NOMOREENTRIES) /* Something is screwed up */
+			netlist_free(&listpp);
+	}
+
 	return (listpp);
 }
 
usr/src/lib/libproc/common/Pcontrol.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/lib/libproc/common/Pcontrol.c	Tue Jul 21 14:14:26 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/lib/libproc/common/Pcontrol.c	Wed Jun 17 17:43:40 2015
@@ -26,6 +26,7 @@
  * Portions Copyright 2007 Chad Mynhier
  * Copyright 2012 DEY Storage Systems, Inc.  All rights reserved.
  * Copyright (c) 2013 by Delphix. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <assert.h>
@@ -337,10 +338,16 @@
 void
 _libproc_init(void)
 {
+	const char *root;
+
 	_libproc_debug = getenv("LIBPROC_DEBUG") != NULL;
 	_libproc_no_qsort = getenv("LIBPROC_NO_QSORT") != NULL;
 	_libproc_incore_elf = getenv("LIBPROC_INCORE_ELF") != NULL;
 
+	if ((root = zone_get_nroot()) != NULL)
+		(void) snprintf(procfs_path, sizeof (procfs_path), "%s/proc",
+		    root);
+
 	(void) sigfillset(&blockable_sigs);
 	(void) sigdelset(&blockable_sigs, SIGKILL);
 	(void) sigdelset(&blockable_sigs, SIGSTOP);
@@ -1752,6 +1759,9 @@
 	case PR_SUSPENDED:
 		dprintf("%s: SUSPENDED\n", caller);
 		break;
+	case PR_BRAND:
+		dprintf("%s: BRANDPRIVATE (%d)\n", caller, lsp->pr_what);
+		break;
 	default:
 		dprintf("%s: Unknown\n", caller);
 		break;
@@ -1931,6 +1941,7 @@
 	case PR_FAULTED:
 	case PR_JOBCONTROL:
 	case PR_SUSPENDED:
+	case PR_BRAND:
 		break;
 	default:
 		errno = EPROTO;
@@ -3505,6 +3516,7 @@
 	case PR_FAULTED:
 	case PR_JOBCONTROL:
 	case PR_SUSPENDED:
+	case PR_BRAND:
 		break;
 	default:
 		errno = EPROTO;
usr/src/lib/varpd/files/common/libvarpd_files_json.c
usr/src/man/man1/zlogin.1
--- /export/home/danmcd/ws/illumos-omnios/usr/src/man/man1/zlogin.1	Tue Jul 21 14:14:26 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/man/man1/zlogin.1	Wed Jun 17 17:43:40 2015
@@ -13,24 +13,24 @@
 .\" Portions Copyright [yyyy] [name of copyright owner]
 .\" Copyright 2013 DEY Storage Systems, Inc.
 .\" Copyright (c) 2014 Gary Mills
+.\" Copyright (c) 2015, Joyent, Inc. All Rights Reserved
 .\" Copyright 2015 Nexenta Systems, Inc. All rights reserved.
-.TH ZLOGIN 1 "Mar 17, 2015"
+.TH ZLOGIN 1 "Mar 30, 2015"
 .SH NAME
 zlogin \- enter a zone
 .SH SYNOPSIS
 .LP
 .nf
-\fBzlogin\fR [\fB-dCEQ\fR] [\fB-e\fR \fIc\fR] [\fB-l\fR \fIusername\fR] \fIzonename\fR
+\fBzlogin\fR [\fB-dCEINQ\fR] [\fB-e\fR \fIc\fR] [\fB-l\fR \fIusername\fR] \fIzonename\fR
 .fi
 
 .LP
 .nf
-\fBzlogin\fR [\fB-nEQS\fR] [\fB-e\fR \fIc\fR] [\fB-l\fR \fIusername\fR] \fIzonename\fR \fIutility\fR
+\fBzlogin\fR [\fB-inEQS\fR] [\fB-e\fR \fIc\fR] [\fB-l\fR \fIusername\fR] \fIzonename\fR \fIutility\fR
      [\fIargument\fR]...
 .fi
 
 .SH DESCRIPTION
-.sp
 .LP
 The \fBzlogin\fR utility is used by the administrator to enter an operating
 system zone. Only a superuser operating in the global system zone can use this
@@ -37,7 +37,7 @@
 utility.
 .sp
 .LP
-\fBzlogin\fR operates in one of three modes:
+\fBzlogin\fR operates in one of four modes:
 .sp
 .ne 2
 .na
@@ -44,12 +44,12 @@
 \fBInteractive Mode\fR
 .ad
 .RS 24n
-If no utility argument is given and the stdin file descriptor for the
-\fBzlogin\fR process is a tty device, \fBzlogin\fR operates in \fBinteractive
-mode\fR. In this mode, \fBzlogin\fR creates a new pseudo terminal for use
-within the login session. Programs requiring a tty device, for example,
-\fBvi\fR(1), work properly in this mode. In this mode, \fBzlogin\fR invokes
-\fBlogin\fR(1) to provide a suitable login session.
+If no utility argument is given or if the \fB-i\fR option is specified, and the
+stdin file descriptor for the \fBzlogin\fR process is a tty device, \fBzlogin\fR
+operates in \fBinteractive mode\fR. In this mode, \fBzlogin\fR creates a new
+pseudo terminal for use within the login session. Programs requiring a tty
+device, for example, \fBvi\fR(1), work properly in this mode. In this mode,
+\fBzlogin\fR invokes \fBlogin\fR(1) to provide a suitable login session.
 .RE
 
 .sp
@@ -58,11 +58,12 @@
 \fBNon-Interactive Mode\fR
 .ad
 .RS 24n
-If a utility is specified, \fBzlogin\fR operates in \fBnon-interactive mode\fR.
-This mode can be useful for script authors since stdin, stdout, and stderr are
-preserved and the exit status of \fIutility\fR is returned upon termination. In
-this mode, \fBzlogin\fR invokes \fBsu\fR(1M) in order to set up the user's
-environment and to provide a login environment.
+If a utility is specified and the \fB-i\fR option is not specified, \fBzlogin\fR
+operates in \fBnon-interactive mode\fR.  This mode can be useful for script
+authors since stdin, stdout, and stderr are preserved and the exit status of
+\fIutility\fR is returned upon termination. In this mode, \fBzlogin\fR invokes
+\fBsu\fR(1M) in order to set up the user's environment and to provide a login
+environment.
 .sp
 The specified command is passed as a string and interpreted by a shell running
 in the non-global zone. See \fBrsh\fR(1).
@@ -80,8 +81,17 @@
 are persistent across reboot of the zone.
 .RE
 
-.SH OPTIONS
 .sp
+.ne 2
+.na
+\fBStandalone-processs Interactive Mode\fR
+.ad
+.RS 24n
+If the \fB-I\fR option is specified the user is connected to the zone's stdin,
+stdout and stderr \fBzfd(7D)\fR devices.
+.RE
+
+.SH OPTIONS
 .LP
 The following options are supported:
 .sp
@@ -127,6 +137,25 @@
 .sp
 .ne 2
 .na
+\fB\fB-i\fR\fR
+.ad
+.RS 15n
+Forces interactive mode when a utility argument is specified.
+.RE
+
+.sp
+.ne 2
+.na
+\fB\fB-I\fR\fR
+.ad
+.RS 15n
+Connects to the zone's \fBzfd(7D)\fR devices.
+.RE
+
+.sp
+.sp
+.ne 2
+.na
 \fB\fB-l\fR \fIusername\fR\fR
 .ad
 .RS 15n
@@ -149,6 +178,17 @@
 .sp
 .ne 2
 .na
+\fB-N\fR
+.ad
+.RS 15n
+Nohup. This may only be used with the -I option to avoid sending EOF to the zfd
+device when zlogin's stdin receives EOF. It can also be toggled by sending
+\fBSIGUSR1\fR to an attached zlogin process.
+.RE
+
+.sp
+.ne 2
+.na
 \fB-Q\fR
 .ad
 .RS 15n
@@ -172,7 +212,6 @@
 .RE
 
 .SS "Escape Sequences"
-.sp
 .LP
 Lines that you type that start with the tilde character (\fB~\fR) are "escape
 sequences". The escape character can be changed using the \fB-e\fR option.
@@ -187,12 +226,10 @@
 .RE
 
 .SH SECURITY
-.sp
 .LP
 Once a process has been placed in a zone other than the global zone, the
 process cannot change zone again, nor can any of its children.
 .SH OPERANDS
-.sp
 .LP
 The following operands are supported:
 .sp
@@ -223,7 +260,6 @@
 .RE
 
 .SH EXIT STATUS
-.sp
 .LP
 In interactive and non-interactive modes, the \fBzlogin\fR utility exits when
 the command or shell in the non-global zone exits. In non-interactive mode, the
@@ -268,7 +304,6 @@
 .RE
 
 .SH ATTRIBUTES
-.sp
 .LP
 See \fBattributes\fR(5) for descriptions of the following attributes:
 .sp
@@ -284,12 +319,10 @@
 .TE
 
 .SH SEE ALSO
-.sp
 .LP
 \fBlogin\fR(1), \fBrsh\fR(1), \fBvi\fR(1), \fBsu\fR(1M), \fBzoneadm\fR(1M),
 \fBzonecfg\fR(1M), \fBattributes\fR(5), \fBzones\fR(5)
 .SH NOTES
-.sp
 .LP
 \fBzlogin\fR fails if its open files or any portion of its address space
 corresponds to an NFS file. This includes the executable itself or the shared
usr/src/man/man2/exec.2
--- /export/home/danmcd/ws/illumos-omnios/usr/src/man/man2/exec.2	Tue Jul 21 14:14:26 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/man/man2/exec.2	Mon Dec 14 10:47:45 2015
@@ -1,5 +1,6 @@
 '\" te
 .\" Copyright (c) 2008, Sun Microsystems, Inc.  All Rights Reserved.
+.\" Copyright 2015, Joyent, Inc.
 .\" Copyright 1989 AT&T.
 .\" Portions Copyright (c) 1992, X/Open Company Limited.  All Rights Reserved.
 .\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for permission to reproduce portions of its copyrighted documentation. Original documentation from The Open Group can be obtained online at
@@ -9,7 +10,7 @@
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH EXEC 2 "Jun 16, 2008"
+.TH EXEC 2 "Oct 27, 2015"
 .SH NAME
 exec, execl, execle, execlp, execv, execve, execvp \- execute a file
 .SH SYNOPSIS
@@ -76,7 +77,8 @@
 as \fIarg0\fR to the interpreter. If \fIarg\fR was specified in the interpreter
 file, it is passed as \fIarg1\fR to the interpreter. The remaining arguments to
 the interpreter are \fIarg0\fR through \fIargn\fR of the originally exec'd
-file. The interpreter named by \fIpathname\fR must not be an interpreter file.
+file. The interpreter named by \fIpathname\fR may also be an interpreter file.
+There can be up to four nested interpreter files before the final interpreter.
 .sp
 .LP
 When a C-language program is executed as a result of this call, it is entered
@@ -587,7 +589,7 @@
 .ad
 .RS 16n
 Too many symbolic links were encountered in translating \fIpath\fR or
-\fIfile\fR.
+\fIfile\fR, or too many nested interpreter files.
 .RE
 
 .sp
usr/src/man/man4/proc.4
--- /export/home/danmcd/ws/illumos-omnios/usr/src/man/man4/proc.4	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/man/man4/proc.4	Wed Jun 17 17:43:41 2015
@@ -1,15 +1,14 @@
 '\" te
 .\" Copyright 1989 AT&T
 .\" Copyright (c) 2006, Sun Microsystems, Inc. All Rights Reserved.
-.\" Copyright (c) 2013, Joyent, Inc. All rights reserved.
+.\" Copyright 2015, Joyent, Inc.
 .\" The contents of this file are subject to the terms of the Common Development and Distribution License (the "License").  You may not use this file except in compliance with the License.
 .\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or http://www.opensolaris.org/os/licensing.  See the License for the specific language governing permissions and limitations under the License.
 .\" When distributing Covered Code, include this CDDL HEADER in each file and include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add the following below this CDDL HEADER, with the fields enclosed by brackets "[]" replaced with your own identifying information: Portions Copyright [yyyy] [name of copyright owner]
-.TH PROC 4 "Mar 31, 2013"
+.TH PROC 4 "May 19, 2014"
 .SH NAME
 proc \- /proc, the process file system
 .SH DESCRIPTION
-.sp
 .LP
 \fB/proc\fR is a file system that provides access to the state of each process
 and light-weight process (lwp) in the system. The name of each entry in the
@@ -174,7 +173,6 @@
 explicit 32-bit fixed-width data structures (like \fBcstruct stat32\fR) visible
 to the 64-bit program. See \fBtypes32.h\fR(3HEAD).
 .SH DIRECTORY STRUCTURE
-.sp
 .LP
 At the top level, the directory \fB/proc\fR contains entries each of which
 names an existing process in the system. These entries are themselves
@@ -201,7 +199,6 @@
 of the system and it is not legitimate for a program to assume that they will
 not.
 .SH STRUCTURE OF \fB/proc/\fR\fIpid\fR
-.sp
 .LP
 A given directory \fB/proc/\fR\fIpid\fR contains the following entries. A
 process can use the invisible alias \fB/proc/self\fR if it wishes to open one
@@ -209,13 +206,11 @@
 does not appear in a directory listing of \fB/proc\fR obtained from
 \fBls\fR(1), \fBgetdents\fR(2), or \fBreaddir\fR(3C)).
 .SS "contracts"
-.sp
 .LP
 A directory containing references to the contracts held by the process. Each
 entry is a symlink to the contract's directory under \fB/system/contract\fR.
 See \fBcontract\fR(4).
 .SS "as"
-.sp
 .LP
 Contains the address-space image of the process; it can be opened for both
 reading and writing. \fBlseek\fR(2) is used to position the file at the virtual
@@ -223,7 +218,6 @@
 through \fBread\fR(2) or \fBwrite\fR(2) (or by using \fBpread\fR(2) or
 \fBpwrite\fR(2) for the combined operation).
 .SS "ctl"
-.sp
 .LP
 A write-only file to which structured messages are written directing the system
 to change some aspect of the process's state or control its behavior in some
@@ -235,7 +229,6 @@
 appropriate status and information files. The types of control messages are
 described in detail later. See \fBCONTROL MESSAGES\fR.
 .SS "status"
-.sp
 .LP
 Contains state information about the process and the representative lwp. The
 file contains a \fBpstatus\fR structure which contains an embedded
@@ -672,6 +665,18 @@
 .RE
 
 .sp
+.ne 2
+.na
+\fB\fBPR_BRAND\fR\fR
+.ad
+.RS 17n
+indicates that the lwp stopped for a brand-specific reason.  Interpretation
+of the value of \fBpr_what\fR depends on which zone brand is in use.  It is
+not generally expected that an lwp stopped in this state will be restarted
+by native \fBproc\fR(4) consumers.
+.RE
+
+.sp
 .LP
 \fBpr_cursig\fR names the current signal, that is, the next signal to be
 delivered to the lwp, if any. \fBpr_info\fR, when the lwp is in a
@@ -864,7 +869,6 @@
 .LP
 If the lwp is not stopped, all register values are undefined.
 .SS "psinfo"
-.sp
 .LP
 Contains miscellaneous information about the process and the representative lwp
 needed by the \fBps\fR(1) command. \fBpsinfo\fR remains accessible after a
@@ -930,6 +934,15 @@
 0x8000). \fBpr_pctcpu\fR is the summation over all lwps in the process.
 .sp
 .LP
+The \fBpr_fname\fR and \fBpr_psargs\fR are writable by the owner of the
+process. To write to them, the \fBpsinfo\fR file should be open for writing
+and the desired value for the field should be written at the file offset
+that corresponds to the member of structure.  No other entry may be written
+to; if a write is attempted to an offset that does not represent one of
+these two memers, or if the size of the write is not exactly the size of
+the member being written, no bytes will be written and zero will be returned.
+.sp
+.LP
 \fBpr_lwp\fR contains the \fBps\fR(1) information for the representative lwp.
 If the process is a \fIzombie\fR, \fBpr_nlwp\fR, \fBpr_nzomb\fR, and
 \fBpr_lwp.pr_lwpid\fR are zero and the other fields of \fBpr_lwp\fR are
@@ -983,7 +996,6 @@
 \fBpr_contract\fR is the id of the process contract of which the process is a
 member. See \fBcontract\fR(4) and \fBprocess\fR(4).
 .SS "cred"
-.sp
 .LP
 Contains a description of the credentials associated with the process:
 .sp
@@ -1010,7 +1022,6 @@
 \fBpr_ngroups\fR indicates the number of supplementary groups. (See also the
 \fBPCSCRED\fR and \fBPCSCREDX\fR control operations.)
 .SS "priv"
-.sp
 .LP
 Contains a description of the privileges associated with the process:
 .sp
@@ -1044,7 +1055,6 @@
 The full size of the structure can be computed using
 \fBPRIV_PRPRIV_SIZE\fR(\fBprpriv_t *\fR).
 .SS "sigact"
-.sp
 .LP
 Contains an array of \fBsigaction structures\fR describing the current
 dispositions of all signals associated with the traced process (see
@@ -1052,14 +1062,18 @@
 that the action for signal number \fIn\fR appears in position \fIn\fR-1 of the
 array.
 .SS "auxv"
-.sp
 .LP
 Contains the initial values of the process's aux vector in an array of
 \fBauxv_t\fR structures (see \fB<sys/auxv.h>\fR). The values are those that
 were passed by the operating system as startup information to the dynamic
 linker.
+.SS "argv"
+.LP
+Contains the concatenation of each of the argument strings, including their
+\fBNUL\fR terminators, in the argument vector (\fBargv\fR) for the process. If
+the process has modified either its argument vector, or the contents of any of
+the strings referenced by that vector, those changes will be visible here.
 .SS "ldt"
-.sp
 .LP
 This file exists only on x86-based machines. It is non-empty only if the
 process has established a local descriptor table (\fBLDT\fR). If non-empty, the
@@ -1067,7 +1081,6 @@
 elements of type \fBstruct ssd\fR, defined in \fB<sys/sysi86.h>\fR, one element
 for each active \fBLDT\fR entry.
 .SS "map, xmap"
-.sp
 .LP
 Contain information about the virtual address map of the process. The map file
 contains an array of \fBprmap\fR structures while the xmap file contains an
@@ -1235,7 +1248,6 @@
 \fBpr_pagesize.\fR The possible values are hardware architecture specific, and
 may change over a mapping's lifetime.
 .SS "rmap"
-.sp
 .LP
 Contains information about the reserved address ranges of the process. The file
 contains an array of \fBprmap\fR structures, as defined above for the \fBmap\fR
@@ -1246,7 +1258,6 @@
 include the address ranges reserved for the process stack and the individual
 thread stacks of a multi-threaded process.
 .SS "cwd"
-.sp
 .LP
 A symbolic link to the process's current working directory. See \fBchdir\fR(2).
 A \fBreadlink\fR(2) of \fB/proc/\fIpid\fR/cwd\fR yields a null string. However,
@@ -1253,7 +1264,6 @@
 it can be opened, listed, and searched as a directory, and can be the target of
 \fBchdir\fR(2).
 .SS "root"
-.sp
 .LP
 A symbolic link to the process's root directory.
 \fB/proc/\fR\fIpid\fR\fB/root\fR can differ from the system root directory if
@@ -1260,7 +1270,6 @@
 the process or one of its ancestors executed \fBchroot\fR(2) as super user. It
 has the same semantics as \fB/proc/\fR\fIpid\fR\fB/cwd\fR.
 .SS "fd"
-.sp
 .LP
 A directory containing references to the open files of the process. Each entry
 is a decimal number corresponding to an open file descriptor in the process.
@@ -1274,7 +1283,6 @@
 \fB/proc/\fIpid\fR/cwd\fR. An attempt to open any other type of entry fails
 with \fBEACCES\fR.
 .SS "object"
-.sp
 .LP
 A directory containing read-only files with names corresponding to the
 \fBpr_mapname\fR entries in the \fBmap\fR and \fBpagedata\fR files. Opening
@@ -1287,7 +1295,6 @@
 access to the object file and any shared libraries (and consequently the symbol
 tables) without having to know the actual path names of the executable files.
 .SS "path"
-.sp
 .LP
 A directory containing symbolic links to files opened by the process. The
 directory includes one entry for \fBcwd\fR and \fBroot\fR. The directory also
@@ -1299,7 +1306,6 @@
 files. For the file descriptor entries, the path may be different from the one
 used by the process to open the file.
 .SS "pagedata"
-.sp
 .LP
 Opening the page data file enables tracking of address space references and
 modifications on a per-page basis.
@@ -1381,13 +1387,11 @@
 data being collected by the system for the others. An open of the page data
 file will fail with \fBENOMEM\fR if the system-imposed limit would be exceeded.
 .SS "watch"
-.sp
 .LP
 Contains an array of \fBprwatch\fR structures, one for each watched area
 established by the \fBPCWATCH\fR control operation. See \fBPCWATCH\fR for
 details.
 .SS "usage"
-.sp
 .LP
 Contains process usage information described by a \fBprusage\fR structure which
 contains at least the following fields:
@@ -1434,7 +1438,6 @@
 information is now never an estimate represents time the process has spent in
 various states.
 .SS "lstatus"
-.sp
 .LP
 Contains a \fBprheader\fR structure followed by an array of \fBlwpstatus\fR
 structures, one for each active lwp in the process (see also
@@ -1459,13 +1462,11 @@
 files that include a \fBprheader\fR structure (\fBlpsinfo\fR and \fBlusage\fR,
 below).
 .SS "lpsinfo"
-.sp
 .LP
 Contains a \fBprheader\fR structure followed by an array of \fBlwpsinfo\fR
 structures, one for eachactive and zombie lwp in the process. See also
 \fB/proc/\fR\fIpid\fR\fB/lwp/\fR\fIlwpid\fR/\fBlwpsinfo\fR, below.
 .SS "lusage"
-.sp
 .LP
 Contains a \fBprheader\fR structure followed by an array of \fBprusage\fR
 structures, one for each active lwp in the process, plus an additional element
@@ -1476,7 +1477,6 @@
 information obtained from the \fBusage\fR file. (See also
 \fB/proc/\fR\fIpid\fR\fB/lwp/\fR\fIlwpid\fR/\fBlwpusage\fR, below.)
 .SS "lwp"
-.sp
 .LP
 A directory containing entries each of which names an active or zombie lwp
 within the process. These entries are themselves directories containing
@@ -1483,24 +1483,20 @@
 additional files as described below. Only the \fBlwpsinfo\fR file exists in the
 directory of a zombie lwp.
 .SH STRUCTURE OF \fB/proc/\fR\fIpid\fR\fB/lwp/\fR\fIlwpid\fR
-.sp
 .LP
 A given directory \fB/proc/\fR\fIpid\fR\fB/lwp/\fR\fIlwpid\fR contains the
 following entries:
 .SS "lwpctl"
-.sp
 .LP
 Write-only control file. The messages written to this file affect the specific
 lwp rather than the representative lwp, as is the case for the process's
 \fBctl\fR file.
 .SS "lwpstatus"
-.sp
 .LP
 lwp-specific state information. This file contains the \fBlwpstatus\fR
 structure for the specific lwp as described above for the representative lwp in
 the process's \fBstatus\fR file.
 .SS "lwpsinfo"
-.sp
 .LP
 lwp-specific \fBps\fR(1) information. This file contains the \fBlwpsinfo\fR
 structure for the specific lwp as described above for the representative lwp in
@@ -1507,12 +1503,10 @@
 the process's \fBpsinfo\fR file. The \fBlwpsinfo\fR file remains accessible
 after an lwp becomes a zombie.
 .SS "lwpusage"
-.sp
 .LP
 This file contains the \fBprusage\fR structure for the specific lwp as
 described above for the process's \fBusage\fR file.
 .SS "gwindows"
-.sp
 .LP
 This file exists only on SPARC based machines. If it is non-empty, it contains
 a \fBgwindows_t\fR structure, defined in \fB<sys/regset.h>\fR, with the values
@@ -1523,7 +1517,6 @@
 register windows that could not be stored on the stack, the file is empty (the
 usual case).
 .SS "xregs"
-.sp
 .LP
 Extra state registers. The extra state register set is architecture dependent;
 this file is empty if the system does not support extra state registers. If the
@@ -1532,7 +1525,6 @@
 extra state registers. If the lwp is not stopped, all register values are
 undefined. See also the \fBPCSXREG\fR control operation, below.
 .SS "asrs"
-.sp
 .LP
 This file exists only for 64-bit SPARC V9 processes. It contains an
 \fBasrset_t\fR structure, defined in <\fBsys/regset.h\fR>, containing the
@@ -1540,7 +1532,6 @@
 not stopped, all register values are undefined. See also the \fBPCSASRS\fR
 control operation, below.
 .SS "spymaster"
-.sp
 .LP
 For an agent lwp (see \fBPCAGENT\fR), this file contains a \fBpsinfo_t\fR
 structure that corresponds to the process that created the agent lwp at the
@@ -1549,7 +1540,6 @@
 correspond to the CPU time for the process, but rather to the creation time of
 the agent lwp.
 .SS "templates"
-.sp
 .LP
 A directory which contains references to the active templates for the lwp,
 named by the contract type. Changes made to an active template descriptor do
@@ -1557,7 +1547,6 @@
 active template. It is not possible to activate an active template descriptor.
 See \fBcontract\fR(4).
 .SH CONTROL MESSAGES
-.sp
 .LP
 Process state changes are effected through messages written to a process's
 \fBctl\fR file or to an individual lwp's \fBlwpctl\fR file. All control
@@ -1577,7 +1566,6 @@
 message to a control file for a process or lwp that has terminated elicits the
 error \fBENOENT\fR.
 .SS "PCSTOP PCDSTOP PCWSTOP PCTWSTOP"
-.sp
 .LP
 When applied to the process control file, \fBPCSTOP\fR directs all lwps to stop
 and waits for them to stop, \fBPCDSTOP\fR directs all lwps to stop without
@@ -1626,7 +1614,6 @@
 be stopped. Applying one of these operations to a system process or any of its
 lwps elicits the error \fBEBUSY\fR.
 .SS "PCRUN"
-.sp
 .LP
 Make an lwp runnable again after a stop. This operation takes a \fBlong\fR
 operand containing zero or more of the following flags:
@@ -1707,7 +1694,6 @@
 a consequence, all lwps are in the \fBPR_REQUESTED\fR or \fBPR_SUSPENDED\fR
 stop state, all lwps showing \fBPR_REQUESTED\fR are made runnable.
 .SS "PCSTRACE"
-.sp
 .LP
 Define a set of signals to be traced in the process. The receipt of one of
 these signals by an lwp causes the lwp to stop. The set of signals is defined
@@ -1720,11 +1706,9 @@
 is removed from the held signal set, either by the lwp itself or by setting the
 held signal set with \fBPCSHOLD\fR.
 .SS "PCCSIG"
-.sp
 .LP
 The current signal, if any, is cleared from the specific or representative lwp.
 .SS "PCSSIG"
-.sp
 .LP
 The current signal and its associated signal information for the specific or
 representative lwp are set according to the contents of the operand
@@ -1736,7 +1720,6 @@
 is traced. Setting the current signal to \fBSIGKILL\fR terminates the process
 immediately.
 .SS "PCKILL"
-.sp
 .LP
 If applied to the process control file, a signal is sent to the process with
 semantics identical to those of \fBkill\fR(2). If applied to an lwp control
@@ -1744,7 +1727,6 @@
 \fBlong\fR operand contained in the message. Sending \fBSIGKILL\fR terminates
 the process immediately.
 .SS "PCUNKILL"
-.sp
 .LP
 A signal is deleted, that is, it is removed from the set of pending signals. If
 applied to the process control file, the signal is deleted from the process's
@@ -1753,7 +1735,6 @@
 signal is named in a \fBlong\fR operand in the control message. It is an error
 (\fBEINVAL\fR) to attempt to delete \fBSIGKILL\fR.
 .SS "PCSHOLD"
-.sp
 .LP
 Set the set of held signals for the specific or representative lwp (signals
 whose delivery will be blocked if sent to the lwp). The set of signals is
@@ -1760,7 +1741,6 @@
 specified with a \fBsigset_t\fR operand. \fBSIGKILL\fR and \fBSIGSTOP\fR cannot
 be held; if specified, they are silently ignored.
 .SS "PCSFAULT"
-.sp
 .LP
 Define a set of hardware faults to be traced in the process. On incurring one
 of these faults, an lwp stops. The set is defined via the operand
@@ -1885,12 +1865,10 @@
 identifies the signal to be sent and contains machine-specific information
 about the fault.
 .SS "PCCFAULT"
-.sp
 .LP
 The current fault, if any, is cleared; the associated signal will not be sent
 to the specific or representative lwp.
 .SS "PCSENTRY PCSEXIT"
-.sp
 .LP
 These control operations instruct the process's lwps to stop on entry to or
 exit from specified system calls. The set of system calls to be traced is
@@ -1911,7 +1889,6 @@
 flag in a \fBPCRUN\fR control message. Unless exit from the system call is
 being traced, the lwp returns to user level showing \fBEINTR\fR.
 .SS "PCWATCH"
-.sp
 .LP
 Set or clear a watched area in the controlled process from a \fBprwatch\fR
 structure operand:
@@ -2060,7 +2037,6 @@
 All watched areas are cancelled when the traced process performs a successful
 \fBexec\fR(2).
 .SS "PCSET PCUNSET"
-.sp
 .LP
 \fBPCSET\fR sets one or more modes of operation for the traced process.
 \fBPCUNSET\fR unsets these modes. The modes to be set or unset are specified by
@@ -2176,7 +2152,6 @@
 reported in the \fBpr_flags\fR field of \fB/proc/\fR\fIpid\fR\fB/status\fR and
 \fB/proc/\fR\fIpid\fR\fB/lwp/\fR\fIlwp\fR\fB/lwpstatus\fR.
 .SS "PCSREG"
-.sp
 .LP
 Set the general registers for the specific or representative lwp according to
 the operand \fBprgregset_t\fR structure.
@@ -2195,7 +2170,6 @@
 \fBPCSREG\fR fails with \fBEBUSY\fR if the lwp is not stopped on an event of
 interest.
 .SS "PCSVADDR"
-.sp
 .LP
 Set the address at which execution will resume for the specific or
 representative lwp from the operand \fBlong\fR. On SPARC based systems, both
@@ -2203,7 +2177,6 @@
 address. On x86-based systems, only %eip is set. \fBPCSVADDR\fR fails with
 \fBEBUSY\fR if the lwp is not stopped on an event of interest.
 .SS "PCSFPREG"
-.sp
 .LP
 Set the floating-point registers for the specific or representative lwp
 according to the operand \fBprfpregset_t\fR structure. An error (\fBEINVAL\fR)
@@ -2212,7 +2185,6 @@
 instructions). \fBPCSFPREG\fR fails with \fBEBUSY\fR if the lwp is not stopped
 on an event of interest.
 .SS "PCSXREG"
-.sp
 .LP
 Set the extra state registers for the specific or representative lwp according
 to the architecture-dependent operand \fBprxregset_t\fR structure. An error
@@ -2220,7 +2192,6 @@
 registers. \fBPCSXREG\fR fails with \fBEBUSY\fR if the lwp is not stopped on an
 event of interest.
 .SS "PCSASRS"
-.sp
 .LP
 Set the ancillary state registers for the specific or representative lwp
 according to the SPARC V9 platform-dependent operand \fBasrset_t\fR structure.
@@ -2230,7 +2201,6 @@
 that can be modified are set; all others are silently ignored. \fBPCSASRS\fR
 fails with \fBEBUSY\fR if the lwp is not stopped on an event of interest.
 .SS "PCAGENT"
-.sp
 .LP
 Create an agent lwp in the controlled process with register values from the
 operand \fBprgregset_t\fR structure (see \fBPCSREG\fR, above). The agent lwp is
@@ -2291,7 +2261,6 @@
 Symbolic constants for system call trap numbers like \fBSYS_lwp_exit\fR and
 \fBSYS_lwp_create\fR can be found in the header file <\fBsys/syscall.h\fR>.
 .SS "PCREAD PCWRITE"
-.sp
 .LP
 Read or write the target process's address space via a \fBpriovec\fR structure
 operand:
@@ -2318,7 +2287,6 @@
 and \fBpwrite\fR(2), no provision is made for partial reads or writes; if the
 operation cannot be performed completely, it fails with \fBEIO\fR.
 .SS "PCNICE"
-.sp
 .LP
 The traced process's \fBnice\fR(2) value is incremented by the amount in the
 operand \fBlong\fR. Only a process with the {\fBPRIV_PROC_PRIOCNTL\fR}
@@ -2326,7 +2294,6 @@
 way, but any user may lower the priority. This operation is not meaningful for
 all scheduling classes.
 .SS "PCSCRED"
-.sp
 .LP
 Set the target process credentials to the values contained in the
 \fBprcred_t\fR structure operand (see \fB/proc/\fR\fIpid\fR\fB/cred\fR). The
@@ -2336,13 +2303,11 @@
 ignored. Only the privileged processes can perform this operation; for all
 others it fails with \fBEPERM\fR.
 .SS "PCSCREDX"
-.sp
 .LP
 Operates like \fBPCSCRED\fR but also sets the supplementary groups; the length
 of the data written with this control operation should be "sizeof
 (\fBprcred_t\fR) + sizeof (\fBgid_t)\fR * (#groups - 1)".
 .SS "PCSPRIV"
-.sp
 .LP
 Set the target process privilege to the values contained in the \fBprpriv_t\fR
 operand (see \fB/proc/pid/priv\fR). The effective, permitted, inheritable, and
@@ -2360,7 +2325,6 @@
 If any of the above restrictions are not met, \fBEPERM\fR is returned. If the
 structure written is improperly formatted, \fBEINVAL\fR is returned.
 .SH PROGRAMMING NOTES
-.sp
 .LP
 For security reasons, except for the \fBpsinfo\fR, \fBusage\fR, \fBlpsinfo\fR,
 \fBlusage\fR, \fBlwpsinfo\fR, and \fBlwpusage\fR files, which are
@@ -2419,7 +2383,6 @@
 to a system process (see \fBPCSTOP\fR). The requested events may be empty to
 wait simply for termination.
 .SH FILES
-.sp
 .ne 2
 .na
 \fB\fB/proc\fR\fR
@@ -2582,6 +2545,16 @@
 .sp
 .ne 2
 .na
+\fB\fB/proc/\fIpid\fR/argv\fR\fR
+.ad
+.sp .6
+.RS 4n
+process argument vector
+.RE
+
+.sp
+.ne 2
+.na
 \fB\fB/proc/\fIpid\fR/ldt\fR\fR
 .ad
 .sp .6
@@ -2820,7 +2793,6 @@
 .RE
 
 .SH SEE ALSO
-.sp
 .LP
 \fBls\fR(1), \fBps\fR(1), \fBchroot\fR(1M), \fBalarm\fR(2), \fBbrk\fR(2),
 \fBchdir\fR(2), \fBchroot\fR(2), \fBclose\fR(2), \fBcreat\fR(2), \fBdup\fR(2),
@@ -2836,7 +2808,6 @@
 \fBwait\fR(3C), \fBcontract\fR(4), \fBcore\fR(4), \fBprocess\fR(4),
 \fBlfcompile\fR(5), \fBprivileges\fR(5)
 .SH DIAGNOSTICS
-.sp
 .LP
 Errors that can occur in addition to the errors normally associated with file
 system access:
@@ -2991,7 +2962,6 @@
 .RE
 
 .SH NOTES
-.sp
 .LP
 Descriptions of structures in this document include only interesting structure
 elements, not filler and padding fields, and may show elements out of order for
@@ -2998,7 +2968,6 @@
 descriptive clarity. The actual structure definitions are contained in
 \fB<procfs.h>\fR\&.
 .SH BUGS
-.sp
 .LP
 Because the old \fBioctl\fR(2)-based version of \fB/proc\fR is currently
 supported for binary compatibility with old applications, the top-level
usr/src/man/man7d/Makefile
--- /export/home/danmcd/ws/illumos-omnios/usr/src/man/man7d/Makefile	Wed Sep 16 08:01:39 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/man/man7d/Makefile	Wed Oct 14 16:03:01 2015
@@ -13,6 +13,7 @@
 # Copyright 2011, Richard Lowe
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
 # Copyright 2014 Garrett D'Amore <garrett@damore.org>
+# Copyright 2014 Joyent, Inc. All rights reserved.
 #
 
 include		$(SRC)/Makefile.master
@@ -142,11 +143,13 @@
 		virtualkm.7d	\
 		vni.7d		\
 		vr.7d		\
+		vnd.7d		\
 		wscons.7d	\
 		xge.7d		\
 		yge.7d		\
 		zcons.7d	\
-		zero.7d
+		zero.7d		\
+		zfd.7d
 
 sparc_MANFILES=	audiocs.7d	\
 		bbc_beep.7d	\
usr/src/man/man7d/zfd.7d
usr/src/pkg/manifests/SUNWlx.mf
--- /export/home/danmcd/ws/illumos-omnios/usr/src/pkg/manifests/SUNWlx.mf	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/pkg/manifests/SUNWlx.mf	Wed Jun 17 17:43:41 2015
@@ -20,11 +20,12 @@
 #
 
 #
-# Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
 #
 
-# Was renamed to system/zones/brand/lx, both now obsolete.
-
-set name=pkg.fmri value=pkg:/SUNWlx@0.5.11,5.11-0.143
-set name=pkg.obsolete value=true
+set name=pkg.fmri value=pkg:/SUNWlx@0.5.11,5.11-0.133
+set name=pkg.renamed value=true
 set name=variant.arch value=i386
+set name=variant.opensolaris.zone value=global value=nonglobal
+depend fmri=pkg:/system/zones/brand/lx@0.5.11,5.11-0.133 type=require
usr/src/pkg/manifests/system-zones-brand-lx.mf
--- /export/home/danmcd/ws/illumos-omnios/usr/src/pkg/manifests/system-zones-brand-lx.mf	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/pkg/manifests/system-zones-brand-lx.mf	Wed Jun 17 17:43:41 2015
@@ -20,9 +20,104 @@
 #
 
 #
-# Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+# Copyright 2015 Joyent, Inc.
 #
 
-set name=pkg.fmri value=pkg:/system/zones/brand/lx@0.5.11,5.11-0.143
-set name=pkg.obsolete value=true
+#
+# This package will install successfully into any zone, global or
+# non-global.  The files, directories, links, and hardlinks, however,
+# will only be installed into the global zone.
+#
+<include global_zone_only_component>
+set name=pkg.fmri value=pkg:/system/zones/brand/lx@$(PKGVERS)
+set name=pkg.description value="Support for the 'lx' Brand"
+set name=pkg.summary value="lx Brand"
+set name=info.classification \
+    value="org.opensolaris.category.2008:Applications/System Utilities"
 set name=variant.arch value=i386
+dir path=etc group=sys
+dir path=etc/zones group=sys
+dir path=usr group=sys
+dir path=usr/kernel group=sys
+dir path=usr/kernel/brand group=sys
+dir path=usr/kernel/brand/$(ARCH64) group=sys
+dir path=usr/kernel/drv group=sys
+dir path=usr/kernel/drv/$(ARCH64) group=sys
+dir path=usr/kernel/dtrace group=sys
+dir path=usr/kernel/dtrace/$(ARCH64) group=sys
+dir path=usr/kernel/fs group=sys
+dir path=usr/kernel/fs/$(ARCH64) group=sys
+dir path=usr/kernel/strmod group=sys
+dir path=usr/kernel/strmod/$(ARCH64) group=sys
+dir path=usr/lib
+dir path=usr/lib/brand
+dir path=usr/lib/brand/lx
+dir path=usr/lib/brand/lx/$(ARCH64)
+dir path=usr/lib/brand/lx/distros
+dir path=usr/lib/devfsadm group=sys
+dir path=usr/lib/devfsadm/linkmod group=sys
+driver name=lx_audio
+driver name=lx_ptm perms="lx_ptmajor 0666 root sys"
+driver name=lx_systrace perms="* 0644 root sys"
+file path=etc/zones/SUNWlx.xml mode=0444
+file path=etc/zones/SUNWlx26.xml mode=0444
+file path=usr/kernel/brand/$(ARCH64)/lx_brand group=sys mode=0755
+file path=usr/kernel/brand/lx_brand group=sys mode=0755
+file path=usr/kernel/drv/$(ARCH64)/lx_audio group=sys
+file path=usr/kernel/drv/$(ARCH64)/lx_ptm group=sys
+file path=usr/kernel/drv/$(ARCH64)/lx_systrace group=sys
+file path=usr/kernel/drv/lx_audio group=sys
+file path=usr/kernel/drv/lx_audio.conf group=sys
+file path=usr/kernel/drv/lx_ptm group=sys
+file path=usr/kernel/drv/lx_ptm.conf group=sys
+file path=usr/kernel/drv/lx_systrace group=sys
+file path=usr/kernel/drv/lx_systrace.conf group=sys
+file path=usr/kernel/fs/$(ARCH64)/lx_afs group=sys mode=0755
+file path=usr/kernel/fs/$(ARCH64)/lx_proc group=sys mode=0755
+file path=usr/kernel/fs/lx_afs group=sys mode=0755
+file path=usr/kernel/fs/lx_proc group=sys mode=0755
+file path=usr/kernel/strmod/$(ARCH64)/ldlinux group=sys mode=0755
+file path=usr/kernel/strmod/ldlinux group=sys mode=0755
+file path=usr/lib/brand/lx/$(ARCH64)/lx_librtld_db.so.1
+file path=usr/lib/brand/lx/config.xml mode=0444
+file path=usr/lib/brand/lx/distros/centos35.distro mode=0444
+file path=usr/lib/brand/lx/distros/centos36.distro mode=0444
+file path=usr/lib/brand/lx/distros/centos37.distro mode=0444
+file path=usr/lib/brand/lx/distros/centos38.distro mode=0444
+file path=usr/lib/brand/lx/distros/rhel35.distro mode=0444
+file path=usr/lib/brand/lx/distros/rhel36.distro mode=0444
+file path=usr/lib/brand/lx/distros/rhel37.distro mode=0444
+file path=usr/lib/brand/lx/distros/rhel38.distro mode=0444
+file path=usr/lib/brand/lx/distros/rhel_centos_common mode=0444
+file path=usr/lib/brand/lx/etc_default_nfs group=sys mode=0444
+file path=usr/lib/brand/lx/lx_distro_install mode=0755
+file path=usr/lib/brand/lx/lxinit mode=0755
+file path=usr/lib/brand/lx/lx_init_zone mode=0755
+file path=usr/lib/brand/lx/lx_init_zone_debian mode=0755
+file path=usr/lib/brand/lx/lx_init_zone_redhat mode=0755
+file path=usr/lib/brand/lx/lx_install mode=0755
+file path=usr/lib/brand/lx/lx_librtld_db.so.1
+file path=usr/lib/brand/lx/lx_native mode=0755
+file path=usr/lib/brand/lx/lx_support mode=0755
+file path=usr/lib/brand/lx/platform.xml mode=0444
+file path=usr/lib/devfsadm/linkmod/SUNW_lx_link_$(ARCH).so group=sys
+file path=usr/lib/lx_brand.so.1
+hardlink path=usr/kernel/dtrace/$(ARCH64)/lx_systrace \
+    target=../../../kernel/drv/$(ARCH64)/lx_systrace
+hardlink path=usr/kernel/dtrace/lx_systrace \
+    target=../../kernel/drv/lx_systrace
+legacy pkg=SUNWlxr arch=$(ARCH) category=system \
+    desc="Support for the 'lx' Brand" \
+    hotline="Please contact your local service provider" \
+    name="lx Brand (Root)" vendor="Sun Microsystems, Inc." \
+    version=11.11,REV=2009.11.11
+legacy pkg=SUNWlxu arch=$(ARCH) category=system \
+    desc="Support for the 'lx' Brand" \
+    hotline="Please contact your local service provider" \
+    name="lx Brand (Usr)" vendor="Sun Microsystems, Inc." \
+    version=11.11,REV=2009.11.11
+license cr_Sun license=cr_Sun
+license lic_CDDL license=lic_CDDL
+link path=usr/lib/brand/lx/64 target=$(ARCH64)
usr/src/uts/common/Makefile.files
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/Makefile.files	Tue Jan  5 17:20:21 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/Makefile.files	Mon Dec 14 10:47:45 2015
@@ -25,6 +25,7 @@
 # Copyright (c) 2011, 2014 by Delphix. All rights reserved.
 # Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
+# Copyright 2015, Joyent, Inc.
 #
 
 #
@@ -281,6 +282,7 @@
 		rctl.o		\
 		rctlsys.o	\
 		readlink.o	\
+		refhash.o	\
 		refstr.o	\
 		rename.o	\
 		resolvepath.o	\
@@ -428,6 +430,8 @@
 
 SYSTRACE_OBJS += systrace.o
 
+LX_SYSTRACE_OBJS += lx_systrace.o
+
 LOCKSTAT_OBJS += lockstat.o
 
 FASTTRAP_OBJS += fasttrap.o fasttrap_isa.o
@@ -492,6 +496,12 @@
 
 PTM_OBJS +=	ptm.o
 
+LX_PTM_OBJS +=	lx_ptm.o
+
+LX_AUDIO_OBJS += lx_audio.o
+
+LX_NETLINK_OBJS +=	lx_netlink.o
+
 MII_OBJS +=	mii.o mii_cicada.o mii_natsemi.o mii_intel.o mii_qualsemi.o \
 		mii_marvell.o mii_realtek.o mii_other.o
 
@@ -549,6 +559,7 @@
 		sctp_addr.o tn_ipopt.o tnet.o ip_netinfo.o \
 		sctp_misc.o
 IP_ILB_OBJS =	ilb.o ilb_nat.o ilb_conn.o ilb_alg_hash.o ilb_alg_rr.o
+IP_COMM_OBJS =	inet_hash.o
 
 IP_OBJS +=	igmp.o ipmp.o ip.o ip6.o ip6_asp.o ip6_if.o ip6_ire.o \
 		ip6_rts.o ip_if.o ip_ire.o ip_listutils.o ip_mroute.o \
@@ -564,7 +575,8 @@
 		$(IP_TCP_OBJS) \
 		$(IP_UDP_OBJS) \
 		$(IP_SCTP_OBJS) \
-		$(IP_ILB_OBJS)
+		$(IP_ILB_OBJS) \
+		$(IP_COMM_OBJS)
 
 IP6_OBJS +=	ip6ddi.o
 
@@ -584,8 +596,6 @@
 
 DATAFILT_OBJS += datafilt.o
 
-HTTPFILT_OBJS += httpfilt.o
-
 SPPP_OBJS +=	sppp.o sppp_dlpi.o sppp_mod.o s_common.o
 
 SPPPTUN_OBJS +=	sppptun.o sppptun_mod.o
@@ -683,6 +693,15 @@
 
 VNIC_OBJS +=	vnic_ctl.o vnic_dev.o
 
+OVERLAY_OBJS +=	overlay.o overlay_fm.o overlay_mux.o overlay_plugin.o \
+		overlay_prop.o overlay_target.o
+
+OVERLAY_VXLAN_OBJS +=	overlay_vxlan.o
+
+VND_OBJS +=	vnd.o frameio.o
+
+GSQUEUE_OBJS +=	gsqueue.o
+
 SIMNET_OBJS +=	simnet.o
 
 IB_OBJS +=	ibnex.o ibnex_ioctl.o ibnex_hca.o
@@ -1001,6 +1020,8 @@
 
 I8042_OBJS +=	i8042.o
 
+INOTIFY_OBJS +=	inotify.o
+
 KB8042_OBJS +=	\
 		at_keyprocess.o	\
 		kb8042.o	\
@@ -1075,6 +1096,8 @@
 
 ZCONS_OBJS += zcons.o
 
+ZFD_OBJS += zfd.o
+
 NV_SATA_OBJS += nv_sata.o
 
 SI3124_OBJS += si3124.o
@@ -1128,8 +1151,7 @@
 DEV_OBJS  +=	sdev_subr.o	sdev_vfsops.o	sdev_vnops.o	\
 		sdev_ptsops.o	sdev_zvolops.o	sdev_comm.o	\
 		sdev_profile.o	sdev_ncache.o	sdev_netops.o	\
-		sdev_ipnetops.o	\
-		sdev_vtops.o
+		sdev_ipnetops.o	sdev_vtops.o	sdev_plugin.o
 
 CTFS_OBJS +=	ctfs_all.o ctfs_cdir.o ctfs_ctl.o ctfs_event.o \
 		ctfs_latest.o ctfs_root.o ctfs_sym.o ctfs_tdir.o ctfs_tmpl.o
@@ -1146,8 +1168,13 @@
 HSFS_OBJS +=	hsfs_node.o	hsfs_subr.o	hsfs_vfsops.o	hsfs_vnops.o \
 		hsfs_susp.o	hsfs_rrip.o	hsfs_susp_subr.o
 
+HYPRLOFS_OBJS += hyprlofs_dir.o hyprlofs_subr.o \
+		hyprlofs_vnops.o hyprlofs_vfsops.o
+
 LOFS_OBJS +=	lofs_subr.o	lofs_vfsops.o	lofs_vnops.o
 
+LXPROC_OBJS +=	lxpr_subr.o	lxpr_vfsops.o	lxpr_vnops.o
+
 NAMEFS_OBJS +=	namevfs.o	namevno.o
 
 NFS_OBJS +=	nfs_client.o	nfs_common.o	nfs_dump.o \
@@ -1299,8 +1326,8 @@
 PCFS_OBJS +=	pc_alloc.o	pc_dir.o	pc_node.o	pc_subr.o \
 		pc_vfsops.o	pc_vnops.o
 
-PROC_OBJS +=	prcontrol.o	prioctl.o	prsubr.o	prusrio.o \
-		prvfsops.o	prvnops.o
+PROC_OBJS +=	prargv.o	prcontrol.o	prioctl.o	prsubr.o \
+		prusrio.o	prvfsops.o	prvnops.o
 
 MNTFS_OBJS +=	mntvfsops.o	mntvnops.o
 
@@ -1889,7 +1916,7 @@
 
 MXFE_OBJS += mxfe.o
 
-MPTSAS_OBJS += mptsas.o mptsas_hash.o mptsas_impl.o mptsas_init.o \
+MPTSAS_OBJS += mptsas.o mptsas_impl.o mptsas_init.o \
 		mptsas_raid.o mptsas_smhba.o
 
 SFE_OBJS += sfe.o sfe_util.o
@@ -2087,6 +2114,11 @@
 MR_SAS_OBJS = ld_pd_map.o mr_sas.o mr_sas_tbolt.o mr_sas_list.o
 
 #
+#	DR_SAS module
+#
+DR_SAS_OBJS = dr_sas.o
+
+#
 #	CPQARY3 module
 #
 CPQARY3_OBJS =	cpqary3.o cpqary3_noe.o cpqary3_talk2ctlr.o	\
@@ -2125,6 +2157,20 @@
 TPM_OBJS =	tpm.o tpm_hcall.o
 
 #
+# USB Fast ethernet drivers
+#
+USBGEM_OBJS = usbgem.o
+AXF_OBJS = axf_usbgem.o
+UDMF_OBJS = udmf_usbgem.o
+URF_OBJS = urf_usbgem.o
+UPF_OBJS = upf_usbgem.o
+
+#
+#	NFP objects
+#
+NFP_OBJS = hostif.o osif.o drvlist.o i21555.o i21285.o i21555d.o
+
+#
 #	BNXE objects
 #
 BNXE_OBJS +=	bnxe_cfg.o		\
usr/src/uts/common/brand/lx/autofs/lx_autofs.c
usr/src/uts/common/brand/lx/cgroups/cgrps.h
usr/src/uts/common/brand/lx/cgroups/cgrps_node.c
usr/src/uts/common/brand/lx/cgroups/cgrps_vfsops.c
usr/src/uts/common/brand/lx/cgroups/cgrps_vnops.c
usr/src/uts/common/brand/lx/devfs/lxd.h
usr/src/uts/common/brand/lx/devfs/lxd_node.c
usr/src/uts/common/brand/lx/devfs/lxd_vfsops.c
usr/src/uts/common/brand/lx/devfs/lxd_vnops.c
usr/src/uts/common/brand/lx/dtrace/lx_systrace.c
usr/src/uts/common/brand/lx/dtrace/lx_systrace.conf
usr/src/uts/common/brand/lx/io/ldlinux.c
usr/src/uts/common/brand/lx/io/lx_audio.c
usr/src/uts/common/brand/lx/io/lx_audio.conf
usr/src/uts/common/brand/lx/io/lx_netlink.c
usr/src/uts/common/brand/lx/io/lx_ptm.c
usr/src/uts/common/brand/lx/io/lx_ptm.conf
usr/src/uts/common/brand/lx/os/lx_brand.c
usr/src/uts/common/brand/lx/os/lx_misc.c
usr/src/uts/common/brand/lx/os/lx_pid.c
usr/src/uts/common/brand/lx/os/lx_ptrace.c
usr/src/uts/common/brand/lx/os/lx_signal.c
usr/src/uts/common/brand/lx/os/lx_syscall.c
usr/src/uts/common/brand/lx/procfs/lx_proc.h
usr/src/uts/common/brand/lx/procfs/lx_prsubr.c
usr/src/uts/common/brand/lx/procfs/lx_prvfsops.c
usr/src/uts/common/brand/lx/procfs/lx_prvnops.c
usr/src/uts/common/brand/lx/sys/ldlinux.h
usr/src/uts/common/brand/lx/sys/lx_audio.h
usr/src/uts/common/brand/lx/sys/lx_autofs.h
usr/src/uts/common/brand/lx/sys/lx_autofs_impl.h
usr/src/uts/common/brand/lx/sys/lx_brand.h
usr/src/uts/common/brand/lx/sys/lx_fcntl.h
usr/src/uts/common/brand/lx/sys/lx_futex.h
usr/src/uts/common/brand/lx/sys/lx_impl.h
usr/src/uts/common/brand/lx/sys/lx_ldt.h
usr/src/uts/common/brand/lx/sys/lx_misc.h
usr/src/uts/common/brand/lx/sys/lx_pid.h
usr/src/uts/common/brand/lx/sys/lx_ptm.h
usr/src/uts/common/brand/lx/sys/lx_sched.h
usr/src/uts/common/brand/lx/sys/lx_siginfo.h
usr/src/uts/common/brand/lx/sys/lx_signal.h
usr/src/uts/common/brand/lx/sys/lx_socket.h
usr/src/uts/common/brand/lx/sys/lx_syscalls.h
usr/src/uts/common/brand/lx/sys/lx_types.h
usr/src/uts/common/brand/lx/syscall/lx_aio.c
usr/src/uts/common/brand/lx/syscall/lx_brk.c
usr/src/uts/common/brand/lx/syscall/lx_chmod.c
usr/src/uts/common/brand/lx/syscall/lx_chown.c
usr/src/uts/common/brand/lx/syscall/lx_clone.c
usr/src/uts/common/brand/lx/syscall/lx_close.c
usr/src/uts/common/brand/lx/syscall/lx_cpu.c
usr/src/uts/common/brand/lx/syscall/lx_epoll.c
usr/src/uts/common/brand/lx/syscall/lx_fallocate.c
usr/src/uts/common/brand/lx/syscall/lx_fcntl.c
usr/src/uts/common/brand/lx/syscall/lx_futex.c
usr/src/uts/common/brand/lx/syscall/lx_getdents.c
usr/src/uts/common/brand/lx/syscall/lx_getpid.c
usr/src/uts/common/brand/lx/syscall/lx_getrandom.c
usr/src/uts/common/brand/lx/syscall/lx_id.c
usr/src/uts/common/brand/lx/syscall/lx_ioctl.c
usr/src/uts/common/brand/lx/syscall/lx_ioprio.c
usr/src/uts/common/brand/lx/syscall/lx_kill.c
usr/src/uts/common/brand/lx/syscall/lx_mkdir.c
usr/src/uts/common/brand/lx/syscall/lx_modify_ldt.c
usr/src/uts/common/brand/lx/syscall/lx_open.c
usr/src/uts/common/brand/lx/syscall/lx_pipe.c
usr/src/uts/common/brand/lx/syscall/lx_poll.c
usr/src/uts/common/brand/lx/syscall/lx_prctl.c
usr/src/uts/common/brand/lx/syscall/lx_rlimit.c
usr/src/uts/common/brand/lx/syscall/lx_rw.c
usr/src/uts/common/brand/lx/syscall/lx_sched.c
usr/src/uts/common/brand/lx/syscall/lx_socket.c
usr/src/uts/common/brand/lx/syscall/lx_sync.c
usr/src/uts/common/brand/lx/syscall/lx_sysinfo.c
usr/src/uts/common/brand/lx/syscall/lx_thread_area.c
usr/src/uts/common/brand/lx/syscall/lx_timer.c
usr/src/uts/common/brand/lx/syscall/lx_uname.c
usr/src/uts/common/brand/lx/syscall/lx_wait.c
usr/src/uts/common/brand/lx/syscall/lx_xattr.c
usr/src/uts/common/brand/lx/sysfs/lx_sysfs.h
usr/src/uts/common/brand/lx/sysfs/lx_syssubr.c
usr/src/uts/common/brand/lx/sysfs/lx_sysvfsops.c
usr/src/uts/common/brand/lx/sysfs/lx_sysvnops.c
usr/src/uts/common/brand/sn1/sn1_brand.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/brand/sn1/sn1_brand.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/brand/sn1/sn1_brand.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc. All rights reserved.
  */
 
 #include <sys/errno.h>
@@ -48,37 +49,59 @@
 int	sn1_getattr(zone_t *, int, void *, size_t *);
 int	sn1_setattr(zone_t *, int, void *, size_t);
 int	sn1_brandsys(int, int64_t *, uintptr_t, uintptr_t, uintptr_t,
-		uintptr_t, uintptr_t, uintptr_t);
+		uintptr_t, uintptr_t);
 void	sn1_copy_procdata(proc_t *, proc_t *);
-void	sn1_proc_exit(struct proc *, klwp_t *);
+void	sn1_proc_exit(struct proc *);
 void	sn1_exec();
-int	sn1_initlwp(klwp_t *);
+void	sn1_initlwp(klwp_t *, void *);
 void	sn1_forklwp(klwp_t *, klwp_t *);
 void	sn1_freelwp(klwp_t *);
 void	sn1_lwpexit(klwp_t *);
 int	sn1_elfexec(vnode_t *, execa_t *, uarg_t *, intpdata_t *, int,
-	long *, int, caddr_t, cred_t *, int);
+	long *, int, caddr_t, cred_t *, int *);
 
 /* sn1 brand */
 struct brand_ops sn1_brops = {
-	sn1_init_brand_data,
-	sn1_free_brand_data,
-	sn1_brandsys,
-	sn1_setbrand,
-	sn1_getattr,
-	sn1_setattr,
-	sn1_copy_procdata,
-	sn1_proc_exit,
-	sn1_exec,
-	lwp_setrval,
-	sn1_initlwp,
-	sn1_forklwp,
-	sn1_freelwp,
-	sn1_lwpexit,
-	sn1_elfexec,
-	NULL,
-	NULL,
-	NSIG,
+	sn1_init_brand_data,		/* b_init_brand_data */
+	sn1_free_brand_data,		/* b_free_brand_data */
+	sn1_brandsys,			/* b_brandsys */
+	sn1_setbrand,			/* b_setbrand */
+	sn1_getattr,			/* b_getattr */
+	sn1_setattr,			/* b_setattr */
+	sn1_copy_procdata,		/* b_copy_procdata */
+	sn1_proc_exit,			/* b_proc_exit */
+	sn1_exec,			/* b_exec */
+	lwp_setrval,			/* b_lwp_setrval */
+	NULL,				/* b_lwpdata_alloc */
+	NULL,				/* b_lwpdata_free */
+	sn1_initlwp,			/* b_initlwp */
+	NULL,				/* b_initlwp_post */
+	sn1_forklwp,			/* b_forklwp */
+	sn1_freelwp,			/* b_freelwp */
+	sn1_lwpexit,			/* b_lwpexit */
+	sn1_elfexec,			/* b_elfexec */
+	NULL,				/* b_sigset_native_to_brand */
+	NULL,				/* b_sigset_brand_to_native */
+	NULL,				/* b_sigfd_translate */
+	NSIG,				/* b_nsig */
+	NULL,				/* b_exit_with_sig */
+	NULL,				/* b_wait_filter */
+	NULL,				/* b_native_exec */
+	NULL,				/* b_map32limit */
+	NULL,				/* b_stop_notify */
+	NULL,				/* b_waitid_helper */
+	NULL,				/* b_sigcld_repost */
+	NULL,				/* b_issig_stop */
+	NULL,				/* b_sig_ignorable */
+	NULL,				/* b_savecontext */
+#if defined(_SYSCALL32_IMPL)
+	NULL,				/* b_savecontext32 */
+#endif
+	NULL,				/* b_restorecontext */
+	NULL,				/* b_sendsig_stack */
+	NULL,				/* b_sendsig */
+	NULL,				/* b_setid_clear */
+	NULL				/* b_pagefault */
 };
 
 #ifdef	sparc
@@ -94,9 +117,12 @@
 
 struct brand_mach_ops sn1_mops = {
 	sn1_brand_sysenter_callback,
+	NULL,
 	sn1_brand_int91_callback,
 	sn1_brand_syscall_callback,
-	sn1_brand_syscall32_callback
+	sn1_brand_syscall32_callback,
+	NULL,
+	NULL
 };
 
 #else	/* ! __amd64 */
@@ -104,7 +130,10 @@
 struct brand_mach_ops sn1_mops = {
 	sn1_brand_sysenter_callback,
 	NULL,
+	NULL,
 	sn1_brand_syscall_callback,
+	NULL,
+	NULL,
 	NULL
 };
 #endif	/* __amd64 */
@@ -115,7 +144,8 @@
 	BRAND_VER_1,
 	"sn1",
 	&sn1_brops,
-	&sn1_mops
+	&sn1_mops,
+	sizeof (brand_proc_data_t),
 };
 
 static struct modlbrand modlbrand = {
@@ -151,7 +181,7 @@
 /*ARGSUSED*/
 int
 sn1_brandsys(int cmd, int64_t *rval, uintptr_t arg1, uintptr_t arg2,
-    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6)
+    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5)
 {
 	int	res;
 
@@ -171,9 +201,9 @@
 }
 
 void
-sn1_proc_exit(struct proc *p, klwp_t *l)
+sn1_proc_exit(struct proc *p)
 {
-	brand_solaris_proc_exit(p, l, &sn1_brand);
+	brand_solaris_proc_exit(p, &sn1_brand);
 }
 
 void
@@ -182,10 +212,10 @@
 	brand_solaris_exec(&sn1_brand);
 }
 
-int
-sn1_initlwp(klwp_t *l)
+void
+sn1_initlwp(klwp_t *l, void *bd)
 {
-	return (brand_solaris_initlwp(l, &sn1_brand));
+	brand_solaris_initlwp(l, &sn1_brand);
 }
 
 void
@@ -221,11 +251,11 @@
 int
 sn1_elfexec(vnode_t *vp, execa_t *uap, uarg_t *args, intpdata_t *idatap,
 	int level, long *execsz, int setid, caddr_t exec_file, cred_t *cred,
-	int brand_action)
+	int *brand_action)
 {
 	return (brand_solaris_elfexec(vp, uap, args, idatap, level, execsz,
 	    setid, exec_file, cred, brand_action, &sn1_brand, SN1_BRANDNAME,
-	    SN1_LIB, SN1_LIB32, SN1_LINKER, SN1_LINKER32));
+	    SN1_LIB, SN1_LIB32));
 }
 
 int
usr/src/uts/common/brand/sn1/sn1_brand.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/brand/sn1/sn1_brand.h	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/brand/sn1/sn1_brand.h	Wed Jun 17 17:43:41 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
  */
 
 #ifndef _SN1_BRAND_H
@@ -37,20 +38,14 @@
 #define	SN1_VERSION		SN1_VERSION_1
 
 #define	SN1_LIB_NAME		"sn1_brand.so.1"
-#define	SN1_LINKER_NAME		"ld.so.1"
 
 #define	SN1_LIB32		BRAND_NATIVE_DIR "usr/lib/" SN1_LIB_NAME
-#define	SN1_LINKER32		"/lib/" SN1_LINKER_NAME
-
 #define	SN1_LIB64		BRAND_NATIVE_DIR "usr/lib/64/" SN1_LIB_NAME
-#define	SN1_LINKER64		"/lib/64/" SN1_LINKER_NAME
 
 #if defined(_LP64)
 #define	SN1_LIB		SN1_LIB64
-#define	SN1_LINKER	SN1_LINKER64
 #else /* !_LP64 */
 #define	SN1_LIB		SN1_LIB32
-#define	SN1_LINKER	SN1_LINKER32
 #endif /* !_LP64 */
 
 #if defined(_KERNEL)
usr/src/uts/common/brand/sngl/sngl_brand.c
usr/src/uts/common/brand/sngl/sngl_brand.h
usr/src/uts/common/brand/solaris10/s10_brand.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/brand/solaris10/s10_brand.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/brand/solaris10/s10_brand.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2013, OmniTI Computer Consulting, Inc. All rights reserved.
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 #include <sys/errno.h>
@@ -51,39 +52,61 @@
 int	s10_getattr(zone_t *, int, void *, size_t *);
 int	s10_setattr(zone_t *, int, void *, size_t);
 int	s10_brandsys(int, int64_t *, uintptr_t, uintptr_t, uintptr_t,
-		uintptr_t, uintptr_t, uintptr_t);
+		uintptr_t, uintptr_t);
 void	s10_copy_procdata(proc_t *, proc_t *);
-void	s10_proc_exit(struct proc *, klwp_t *);
+void	s10_proc_exit(struct proc *);
 void	s10_exec();
-int	s10_initlwp(klwp_t *);
+void	s10_initlwp(klwp_t *, void *);
 void	s10_forklwp(klwp_t *, klwp_t *);
 void	s10_freelwp(klwp_t *);
 void	s10_lwpexit(klwp_t *);
 int	s10_elfexec(vnode_t *, execa_t *, uarg_t *, intpdata_t *, int,
-	long *, int, caddr_t, cred_t *, int);
+	long *, int, caddr_t, cred_t *, int *);
 void	s10_sigset_native_to_s10(sigset_t *);
 void	s10_sigset_s10_to_native(sigset_t *);
 
 /* s10 brand */
 struct brand_ops s10_brops = {
-	s10_init_brand_data,
-	s10_free_brand_data,
-	s10_brandsys,
-	s10_setbrand,
-	s10_getattr,
-	s10_setattr,
-	s10_copy_procdata,
-	s10_proc_exit,
-	s10_exec,
-	lwp_setrval,
-	s10_initlwp,
-	s10_forklwp,
-	s10_freelwp,
-	s10_lwpexit,
-	s10_elfexec,
-	s10_sigset_native_to_s10,
-	s10_sigset_s10_to_native,
-	S10_NSIG,
+	s10_init_brand_data,		/* b_init_brand_data */
+	s10_free_brand_data,		/* b_free_brand_data */
+	s10_brandsys,			/* b_brandsys */
+	s10_setbrand,			/* b_setbrand */
+	s10_getattr,			/* b_getattr */
+	s10_setattr,			/* b_setattr */
+	s10_copy_procdata,		/* b_copy_procdata */
+	s10_proc_exit,			/* b_proc_exit */
+	s10_exec,			/* b_exec */
+	lwp_setrval,			/* b_lwp_setrval */
+	NULL,				/* b_lwpdata_alloc */
+	NULL,				/* b_lwpdata_free */
+	s10_initlwp,			/* b_initlwp */
+	NULL,				/* b_initlwp_post */
+	s10_forklwp,			/* b_forklwp */
+	s10_freelwp,			/* b_freelwp */
+	s10_lwpexit,			/* b_lwpexit */
+	s10_elfexec,			/* b_elfexec */
+	s10_sigset_native_to_s10,	/* b_sigset_native_to_brand */
+	s10_sigset_s10_to_native,	/* b_sigset_brand_to_native */
+	NULL,				/* b_sigfd_translate */
+	S10_NSIG,			/* b_nsig */
+	NULL,				/* b_exit_with_sig */
+	NULL,				/* b_wait_filter */
+	NULL,				/* b_native_exec */
+	NULL,				/* b_map32limit */
+	NULL,				/* b_stop_notify */
+	NULL,				/* b_waitid_helper */
+	NULL,				/* b_sigcld_repost */
+	NULL,				/* b_issig_stop */
+	NULL,				/* b_sig_ignorable */
+	NULL,				/* b_savecontext */
+#if defined(_SYSCALL32_IMPL)
+	NULL,				/* b_savecontext32 */
+#endif
+	NULL,				/* b_restorecontext */
+	NULL,				/* b_sendsig_stack */
+	NULL,				/* b_sendsig */
+	NULL,				/* b_setid_clear */
+	NULL				/* b_pagefault */
 };
 
 #ifdef	sparc
@@ -99,9 +122,12 @@
 
 struct brand_mach_ops s10_mops = {
 	s10_brand_sysenter_callback,
+	NULL,
 	s10_brand_int91_callback,
 	s10_brand_syscall_callback,
-	s10_brand_syscall32_callback
+	s10_brand_syscall32_callback,
+	NULL,
+	NULL
 };
 
 #else	/* ! __amd64 */
@@ -109,7 +135,10 @@
 struct brand_mach_ops s10_mops = {
 	s10_brand_sysenter_callback,
 	NULL,
+	NULL,
 	s10_brand_syscall_callback,
+	NULL,
+	NULL,
 	NULL
 };
 #endif	/* __amd64 */
@@ -120,7 +149,8 @@
 	BRAND_VER_1,
 	"solaris10",
 	&s10_brops,
-	&s10_mops
+	&s10_mops,
+	sizeof (brand_proc_data_t),
 };
 
 static struct modlbrand modlbrand = {
@@ -252,7 +282,7 @@
 /*ARGSUSED*/
 int
 s10_brandsys(int cmd, int64_t *rval, uintptr_t arg1, uintptr_t arg2,
-    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6)
+    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5)
 {
 	proc_t	*p = curproc;
 	int	res;
@@ -326,9 +356,9 @@
 }
 
 void
-s10_proc_exit(struct proc *p, klwp_t *l)
+s10_proc_exit(struct proc *p)
 {
-	brand_solaris_proc_exit(p, l, &s10_brand);
+	brand_solaris_proc_exit(p, &s10_brand);
 }
 
 void
@@ -337,10 +367,10 @@
 	brand_solaris_exec(&s10_brand);
 }
 
-int
-s10_initlwp(klwp_t *l)
+void
+s10_initlwp(klwp_t *l, void *bd)
 {
-	return (brand_solaris_initlwp(l, &s10_brand));
+	brand_solaris_initlwp(l, &s10_brand);
 }
 
 void
@@ -390,11 +420,11 @@
 int
 s10_elfexec(vnode_t *vp, execa_t *uap, uarg_t *args, intpdata_t *idatap,
 	int level, long *execsz, int setid, caddr_t exec_file, cred_t *cred,
-	int brand_action)
+	int *brand_action)
 {
 	return (brand_solaris_elfexec(vp, uap, args, idatap, level, execsz,
 	    setid, exec_file, cred, brand_action, &s10_brand, S10_BRANDNAME,
-	    S10_LIB, S10_LIB32, S10_LINKER, S10_LINKER32));
+	    S10_LIB, S10_LIB32));
 }
 
 void
usr/src/uts/common/brand/solaris10/s10_brand.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/brand/solaris10/s10_brand.h	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/brand/solaris10/s10_brand.h	Wed Jun 17 17:43:41 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2013, OmniTI Computer Consulting, Inc. All rights reserved.
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
  */
 
 #ifndef _S10_BRAND_H
@@ -42,17 +43,12 @@
 #define	S10_LINKER_NAME		"ld.so.1"
 
 #define	S10_LIB32		BRAND_NATIVE_DIR "usr/lib/" S10_LIB_NAME
-#define	S10_LINKER32		"/lib/" S10_LINKER_NAME
-
 #define	S10_LIB64		BRAND_NATIVE_DIR "usr/lib/64/" S10_LIB_NAME
-#define	S10_LINKER64		"/lib/64/" S10_LINKER_NAME
 
 #if defined(_LP64)
 #define	S10_LIB		S10_LIB64
-#define	S10_LINKER	S10_LINKER64
 #else /* !_LP64 */
 #define	S10_LIB		S10_LIB32
-#define	S10_LINKER	S10_LINKER32
 #endif /* !_LP64 */
 
 /*
usr/src/uts/common/exec/aout/aout.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/exec/aout/aout.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/exec/aout/aout.c	Wed Jun 17 17:43:42 2015
@@ -22,6 +22,7 @@
  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright (c) 2011 Bayard G. Bell. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -54,7 +55,7 @@
 
 static int aoutexec(vnode_t *vp, execa_t *uap, uarg_t *args,
     intpdata_t *idatap, int level, long *execsz, int setid,
-    caddr_t exec_file, cred_t *cred, int brand_action);
+    caddr_t exec_file, cred_t *cred, int *brand_action);
 static int get_aout_head(struct vnode **vpp, struct exdata *edp, long *execsz,
     int *isdyn);
 static int aoutcore(vnode_t *vp, proc_t *pp, cred_t *credp,
@@ -130,7 +131,7 @@
 static int
 aoutexec(vnode_t *vp, struct execa *uap, struct uarg *args,
     struct intpdata *idatap, int level, long *execsz, int setid,
-    caddr_t exec_file, cred_t *cred, int brand_action)
+    caddr_t exec_file, cred_t *cred, int *brand_action)
 {
 	auxv32_t auxflags_auxv32;
 	int error;
usr/src/uts/common/exec/elf/elf.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/exec/elf/elf.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/exec/elf/elf.c	Wed Jan  6 14:59:25 2016
@@ -26,7 +26,7 @@
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
 /*	  All Rights Reserved  	*/
 /*
- * Copyright (c) 2013, Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 #include <sys/types.h>
@@ -163,12 +163,16 @@
 }
 
 /*
- * Map in the executable pointed to by vp. Returns 0 on success.
+ * Map in the executable pointed to by vp. Returns 0 on success.  Note that
+ * this function currently has the maximum number of arguments allowed by
+ * modstubs on x86 (MAXNARG)!  Do _not_ add to this function signature without
+ * adding to MAXNARG.  (Better yet, do not add to this monster of a function
+ * signature!)
  */
 int
 mapexec_brand(vnode_t *vp, uarg_t *args, Ehdr *ehdr, Addr *uphdr_vaddr,
-    intptr_t *voffset, caddr_t exec_file, int *interp, caddr_t *bssbase,
-    caddr_t *brkbase, size_t *brksize, uintptr_t *lddatap)
+    intptr_t *voffset, caddr_t exec_file, char **interpp, caddr_t *bssbase,
+    caddr_t *brkbase, size_t *brksize, uintptr_t *lddatap, uintptr_t *minaddrp)
 {
 	size_t		len;
 	struct vattr	vat;
@@ -180,6 +184,7 @@
 	Phdr		*junk = NULL;
 	Phdr		*dynphdr = NULL;
 	Phdr		*dtrphdr = NULL;
+	char		*interp = NULL;
 	uintptr_t	lddata;
 	long		execsz;
 	intptr_t	minaddr;
@@ -187,6 +192,9 @@
 	if (lddatap != NULL)
 		*lddatap = NULL;
 
+	if (minaddrp != NULL)
+		*minaddrp = NULL;
+
 	if (error = execpermissions(vp, &vat, args)) {
 		uprintf("%s: Cannot execute %s\n", exec_file, args->pathname);
 		return (error);
@@ -212,25 +220,65 @@
 	    &junk, &dtrphdr, NULL, bssbase, brkbase, voffset, &minaddr,
 	    len, &execsz, brksize)) {
 		uprintf("%s: Cannot map %s\n", exec_file, args->pathname);
+		if (uphdr != NULL && uphdr->p_flags == 0)
+			kmem_free(uphdr, sizeof (Phdr));
 		kmem_free(phdrbase, phdrsize);
 		return (error);
 	}
 
+	if (minaddrp != NULL)
+		*minaddrp = minaddr;
+
 	/*
-	 * Inform our caller if the executable needs an interpreter.
+	 * If the executable requires an interpreter, determine its name.
 	 */
-	*interp = (dynphdr == NULL) ? 0 : 1;
+	if (dynphdr != NULL) {
+		ssize_t	resid;
 
+		if (dynphdr->p_filesz > MAXPATHLEN || dynphdr->p_filesz == 0) {
+			uprintf("%s: Invalid interpreter\n", exec_file);
+			kmem_free(phdrbase, phdrsize);
+			return (ENOEXEC);
+		}
+
+		interp = kmem_alloc(MAXPATHLEN, KM_SLEEP);
+
+		if ((error = vn_rdwr(UIO_READ, vp, interp, dynphdr->p_filesz,
+		    (offset_t)dynphdr->p_offset, UIO_SYSSPACE, 0,
+		    (rlim64_t)0, CRED(), &resid)) != 0 || resid != 0 ||
+		    interp[dynphdr->p_filesz - 1] != '\0') {
+			uprintf("%s: Cannot obtain interpreter pathname\n",
+			    exec_file);
+			kmem_free(interp, MAXPATHLEN);
+			kmem_free(phdrbase, phdrsize);
+			return (error != 0 ? error : ENOEXEC);
+		}
+	}
+
 	/*
 	 * If this is a statically linked executable, voffset should indicate
 	 * the address of the executable itself (it normally holds the address
 	 * of the interpreter).
 	 */
-	if (ehdr->e_type == ET_EXEC && *interp == 0)
+	if (ehdr->e_type == ET_EXEC && interp == NULL)
 		*voffset = minaddr;
 
+	/*
+	 * If the caller has asked for the interpreter name, return it (it's
+	 * up to the caller to free it); if the caller hasn't asked for it,
+	 * free it ourselves.
+	 */
+	if (interpp != NULL) {
+		*interpp = interp;
+	} else if (interp != NULL) {
+		kmem_free(interp, MAXPATHLEN);
+	}
+
 	if (uphdr != NULL) {
 		*uphdr_vaddr = uphdr->p_vaddr;
+
+		if (uphdr->p_flags == 0)
+			kmem_free(uphdr, sizeof (Phdr));
 	} else {
 		*uphdr_vaddr = (Addr)-1;
 	}
@@ -243,13 +291,13 @@
 int
 elfexec(vnode_t *vp, execa_t *uap, uarg_t *args, intpdata_t *idatap,
     int level, long *execsz, int setid, caddr_t exec_file, cred_t *cred,
-    int brand_action)
+    int *brand_action)
 {
 	caddr_t		phdrbase = NULL;
 	caddr_t 	bssbase = 0;
 	caddr_t 	brkbase = 0;
 	size_t		brksize = 0;
-	ssize_t		dlnsize;
+	ssize_t		dlnsize, nsize = 0;
 	aux_entry_t	*aux;
 	int		error;
 	ssize_t		resid;
@@ -273,6 +321,7 @@
 	int		hasauxv = 0;
 	int		hasdy = 0;
 	int		branded = 0;
+	int		dynuphdr = 0;
 
 	struct proc *p = ttoproc(curthread);
 	struct user *up = PTOU(p);
@@ -339,14 +388,46 @@
 #endif	/* _LP64 */
 
 	/*
-	 * We delay invoking the brand callback until we've figured out
-	 * what kind of elf binary we're trying to run, 32-bit or 64-bit.
-	 * We do this because now the brand library can just check
-	 * args->to_model to see if the target is 32-bit or 64-bit without
-	 * having do duplicate all the code above.
+	 * We delay invoking the brand callback until we've figured out what
+	 * kind of elf binary we're trying to run, 32-bit or 64-bit.  We do this
+	 * because now the brand library can just check args->to_model to see if
+	 * the target is 32-bit or 64-bit without having do duplicate all the
+	 * code above.
+	 *
+	 * We also give the brand a chance to indicate that based on the ELF
+	 * OSABI of the target binary it should become unbranded and optionally
+	 * indicate that it should be treated as existing in a specific prefix.
+	 *
+	 * Note that if a brand opts to go down this route it does not actually
+	 * end up being debranded. In other words, future programs that exec
+	 * will still be considered for branding unless this escape hatch is
+	 * used. Consider the case of lx brand for example. If a user runs
+	 * /native/usr/sbin/dtrace -c /bin/ls, the isaexec and normal executable
+	 * of DTrace that's in /native will take this escape hatch and be run
+	 * and interpreted using the normal system call table; however, the
+	 * execution of a non-illumos binary in the form of /bin/ls will still
+	 * be branded and be subject to all of the normal actions of the brand.
+	 *
+	 * The level checks associated with brand handling below are used to
+	 * prevent a loop since the brand elfexec function typically comes back
+	 * through this function. We must check <= here since the nested
+	 * handling in the #! interpreter code will increment the level before
+	 * calling gexec to run the final elfexec interpreter.
 	 */
-	if ((level < 2) &&
-	    (brand_action != EBA_NATIVE) && (PROC_IS_BRANDED(p))) {
+	if ((level <= INTP_MAXDEPTH) && (*brand_action != EBA_NATIVE) &&
+	    (PROC_IS_BRANDED(p)) && (BROP(p)->b_native_exec != NULL)) {
+		if (BROP(p)->b_native_exec(ehdrp->e_ident[EI_OSABI],
+		    &args->brand_nroot) == B_TRUE) {
+			ASSERT(ehdrp->e_ident[EI_OSABI]);
+			*brand_action = EBA_NATIVE;
+			/* Add one for the trailing '/' in the path */
+			if (args->brand_nroot != NULL)
+				nsize = strlen(args->brand_nroot) + 1;
+		}
+	}
+
+	if ((level <= INTP_MAXDEPTH) &&
+	    (*brand_action != EBA_NATIVE) && (PROC_IS_BRANDED(p))) {
 		error = BROP(p)->b_elfexec(vp, uap, args,
 		    idatap, level + 1, execsz, setid, exec_file, cred,
 		    brand_action);
@@ -417,14 +498,15 @@
 		 *	AT_BASE
 		 *	AT_FLAGS
 		 *	AT_PAGESZ
+		 *	AT_RANDOM	(added in stk_copyout)
 		 *	AT_SUN_AUXFLAGS
 		 *	AT_SUN_HWCAP
 		 *	AT_SUN_HWCAP2
-		 *	AT_SUN_PLATFORM (added in stk_copyout)
-		 *	AT_SUN_EXECNAME (added in stk_copyout)
+		 *	AT_SUN_PLATFORM	(added in stk_copyout)
+		 *	AT_SUN_EXECNAME	(added in stk_copyout)
 		 *	AT_NULL
 		 *
-		 * total == 9
+		 * total == 10
 		 */
 		if (hasdy && hasu) {
 			/*
@@ -439,7 +521,7 @@
 			 *
 			 * total = 5
 			 */
-			args->auxsize = (9 + 5) * sizeof (aux_entry_t);
+			args->auxsize = (10 + 5) * sizeof (aux_entry_t);
 		} else if (hasdy) {
 			/*
 			 * Has PT_INTERP but no PT_PHDR
@@ -449,9 +531,9 @@
 			 *
 			 * total = 2
 			 */
-			args->auxsize = (9 + 2) * sizeof (aux_entry_t);
+			args->auxsize = (10 + 2) * sizeof (aux_entry_t);
 		} else {
-			args->auxsize = 9 * sizeof (aux_entry_t);
+			args->auxsize = 10 * sizeof (aux_entry_t);
 		}
 	} else {
 		args->auxsize = 0;
@@ -464,13 +546,21 @@
 	if (args->emulator != NULL)
 		args->auxsize += sizeof (aux_entry_t);
 
-	if ((brand_action != EBA_NATIVE) && (PROC_IS_BRANDED(p))) {
+	/*
+	 * If this is a native binary that's been given a modified interpreter
+	 * root, inform it that the native system exists at that root.
+	 */
+	if (args->brand_nroot != NULL) {
+		args->auxsize += sizeof (aux_entry_t);
+	}
+
+	if ((*brand_action != EBA_NATIVE) && (PROC_IS_BRANDED(p))) {
 		branded = 1;
 		/*
-		 * We will be adding 4 entries to the aux vectors.  One for
-		 * the the brandname and 3 for the brand specific aux vectors.
+		 * We will be adding 5 entries to the aux vectors.  One for
+		 * the the brandname and 4 for the brand specific aux vectors.
 		 */
-		args->auxsize += 4 * sizeof (aux_entry_t);
+		args->auxsize += 5 * sizeof (aux_entry_t);
 	}
 
 	/* Hardware/Software capabilities */
@@ -501,7 +591,8 @@
 	aux = bigwad->elfargs;
 	/*
 	 * Move args to the user's stack.
-	 * This can fill in the AT_SUN_PLATFORM and AT_SUN_EXECNAME aux entries.
+	 * This can fill in the AT_SUN_PLATFORM, AT_SUN_EXECNAME and AT_RANDOM
+	 * aux entries.
 	 */
 	if ((error = exec_args(uap, args, idatap, (void **)&aux)) != 0) {
 		if (error == -1) {
@@ -528,6 +619,14 @@
 	    len, execsz, &brksize)) != 0)
 		goto bad;
 
+	if (uphdr != NULL) {
+		/*
+		 * Our uphdr has been dynamically allocated if (and only if)
+		 * its program header flags are clear.
+		 */
+		dynuphdr = (uphdr->p_flags == 0);
+	}
+
 	if (uphdr != NULL && dyphdr == NULL)
 		goto bad;
 
@@ -542,17 +641,22 @@
 		char		*p;
 		struct vnode	*nvp;
 
-		dlnsize = dyphdr->p_filesz;
+		dlnsize = dyphdr->p_filesz + nsize;
 
 		if (dlnsize > MAXPATHLEN || dlnsize <= 0)
 			goto bad;
 
+		if (nsize != 0) {
+			bcopy(args->brand_nroot, dlnp, nsize - 1);
+			dlnp[nsize - 1] = '/';
+		}
+
 		/*
 		 * Read in "interpreter" pathname.
 		 */
-		if ((error = vn_rdwr(UIO_READ, vp, dlnp, dyphdr->p_filesz,
-		    (offset_t)dyphdr->p_offset, UIO_SYSSPACE, 0, (rlim64_t)0,
-		    CRED(), &resid)) != 0) {
+		if ((error = vn_rdwr(UIO_READ, vp, dlnp + nsize,
+		    dyphdr->p_filesz, (offset_t)dyphdr->p_offset, UIO_SYSSPACE,
+		    0, (rlim64_t)0, CRED(), &resid)) != 0) {
 			uprintf("%s: Cannot obtain interpreter pathname\n",
 			    exec_file);
 			goto bad;
@@ -688,9 +792,10 @@
 
 		dtrphdr = NULL;
 
-		error = mapelfexec(nvp, ehdrp, nphdrs, phdrbase, &junk, &junk,
+		error = mapelfexec(nvp, ehdrp, nphdrs, phdrbase, NULL, &junk,
 		    &junk, &dtrphdr, NULL, NULL, NULL, &voffset, NULL, len,
 		    execsz, NULL);
+
 		if (error || junk != NULL) {
 			VN_RELE(nvp);
 			uprintf("%s: Cannot map %s\n", exec_file, dlnp);
@@ -718,8 +823,8 @@
 	if (hasauxv) {
 		int auxf = AF_SUN_HWCAPVERIFY;
 		/*
-		 * Note: AT_SUN_PLATFORM and AT_SUN_EXECNAME were filled in via
-		 * exec_args()
+		 * Note: AT_SUN_PLATFORM, AT_SUN_EXECNAME and AT_RANDOM were
+		 * filled in via exec_args()
 		 */
 		ADDAUX(aux, AT_BASE, voffset)
 		ADDAUX(aux, AT_FLAGS, at_flags)
@@ -747,7 +852,7 @@
 		 * malicious user within the zone from crafting a wrapper to
 		 * run native suid commands with unsecure libraries interposed.
 		 */
-		if ((brand_action == EBA_NATIVE) && (PROC_IS_BRANDED(p) &&
+		if ((*brand_action == EBA_NATIVE) && (PROC_IS_BRANDED(p) &&
 		    (setid &= ~EXECSETID_SETID) != 0))
 			auxf &= ~AF_SUN_SETUGID;
 
@@ -789,6 +894,7 @@
 			ADDAUX(aux, AT_SUN_BRAND_AUX1, 0)
 			ADDAUX(aux, AT_SUN_BRAND_AUX2, 0)
 			ADDAUX(aux, AT_SUN_BRAND_AUX3, 0)
+			ADDAUX(aux, AT_SUN_BRAND_AUX4, 0)
 		}
 
 		ADDAUX(aux, AT_NULL, 0)
@@ -896,6 +1002,8 @@
 	if (error == 0)
 		error = ENOEXEC;
 out:
+	if (dynuphdr)
+		kmem_free(uphdr, sizeof (Phdr));
 	if (phdrbase != NULL)
 		kmem_free(phdrbase, phdrsize);
 	if (cap != NULL)
@@ -1182,7 +1290,7 @@
 	size_t *brksize)
 {
 	Phdr *phdr;
-	int i, prot, error;
+	int i, prot, error, lastprot = 0;
 	caddr_t addr = NULL;
 	size_t zfodsz;
 	int ptload = 0;
@@ -1190,6 +1298,7 @@
 	off_t offset;
 	int hsize = ehdr->e_phentsize;
 	caddr_t mintmp = (caddr_t)-1;
+	uintptr_t lastaddr = NULL;
 	extern int use_brk_lpg;
 
 	if (ehdr->e_type == ET_DYN) {
@@ -1220,13 +1329,11 @@
 	} else {
 		*voffset = 0;
 	}
+
 	phdr = (Phdr *)phdrbase;
 	for (i = nphdrs; i > 0; i--) {
 		switch (phdr->p_type) {
 		case PT_LOAD:
-			if ((*dyphdr != NULL) && (*uphdr == NULL))
-				return (0);
-
 			ptload = 1;
 			prot = PROT_USER;
 			if (phdr->p_flags & PF_R)
@@ -1238,6 +1345,34 @@
 
 			addr = (caddr_t)((uintptr_t)phdr->p_vaddr + *voffset);
 
+			if ((*dyphdr != NULL) && uphdr != NULL &&
+			    (*uphdr == NULL)) {
+				/*
+				 * The PT_PHDR program header is, strictly
+				 * speaking, optional.  If we find that this
+				 * is missing, we will determine the location
+				 * of the program headers based on the address
+				 * of the lowest PT_LOAD segment (namely, this
+				 * one):  we subtract the p_offset to get to
+				 * the ELF header and then add back the program
+				 * header offset to get to the program headers.
+				 * We then cons up a Phdr that corresponds to
+				 * the (missing) PT_PHDR, setting the flags
+				 * to 0 to denote that this is artificial and
+				 * should (must) be freed by the caller.
+				 */
+				Phdr *cons;
+
+				cons = kmem_zalloc(sizeof (Phdr), KM_SLEEP);
+
+				cons->p_flags = 0;
+				cons->p_type = PT_PHDR;
+				cons->p_vaddr = ((uintptr_t)addr -
+				    phdr->p_offset) + ehdr->e_phoff;
+
+				*uphdr = cons;
+			}
+
 			/*
 			 * Keep track of the segment with the lowest starting
 			 * address.
@@ -1245,6 +1380,41 @@
 			if (addr < mintmp)
 				mintmp = addr;
 
+			/*
+			 * Segments need not correspond to page boundaries:
+			 * they are permitted to share a page.  If two PT_LOAD
+			 * segments share the same page, and the permissions
+			 * of the segments differ, the behavior is historically
+			 * that the permissions of the latter segment are used
+			 * for the page that the two segments share.  This is
+			 * also historically a non-issue:  binaries generated
+			 * by most anything will make sure that two PT_LOAD
+			 * segments with differing permissions don't actually
+			 * share any pages.  However, there exist some crazy
+			 * things out there (including at least an obscure
+			 * Portuguese teaching language called G-Portugol) that
+			 * actually do the wrong thing and expect it to work:
+			 * they have a segment with execute permission share
+			 * a page with a subsequent segment that does not
+			 * have execute permissions and expect the resulting
+			 * shared page to in fact be executable.  To accommodate
+			 * such broken link editors, we take advantage of a
+			 * latitude explicitly granted to the loader:  it is
+			 * permitted to make _any_ PT_LOAD segment executable
+			 * (provided that it is readable or writable).  If we
+			 * see that we're sharing a page and that the previous
+			 * page was executable, we will add execute permissions
+			 * to our segment.
+			 */
+			if (btop(lastaddr) == btop((uintptr_t)addr) &&
+			    (phdr->p_flags & (PF_R | PF_W)) &&
+			    (lastprot & PROT_EXEC)) {
+				prot |= PROT_EXEC;
+			}
+
+			lastaddr = (uintptr_t)addr + phdr->p_filesz;
+			lastprot = prot;
+
 			zfodsz = (size_t)phdr->p_memsz - phdr->p_filesz;
 
 			offset = phdr->p_offset;
@@ -1309,8 +1479,22 @@
 			break;
 
 		case PT_INTERP:
-			if (ptload)
-				goto bad;
+			/*
+			 * The ELF specification is unequivocal about the
+			 * PT_INTERP program header with respect to any PT_LOAD
+			 * program header:  "If it is present, it must precede
+			 * any loadable segment entry." Linux, however, makes
+			 * no attempt to enforce this -- which has allowed some
+			 * binary editing tools to get away with generating
+			 * invalid ELF binaries in the respect that PT_INTERP
+			 * occurs after the first PT_LOAD program header.  This
+			 * is unfortunate (and of course, disappointing) but
+			 * it's no worse than that: there is no reason that we
+			 * can't process the PT_INTERP entry (if present) after
+			 * one or more PT_LOAD entries.  We therefore
+			 * deliberately do not check ptload here and always
+			 * store dyphdr to be the PT_INTERP program header.
+			 */
 			*dyphdr = phdr;
 			break;
 
@@ -1319,9 +1503,12 @@
 			break;
 
 		case PT_PHDR:
-			if (ptload)
+			if (ptload || phdr->p_flags == 0)
 				goto bad;
-			*uphdr = phdr;
+
+			if (uphdr != NULL)
+				*uphdr = phdr;
+
 			break;
 
 		case PT_NULL:
@@ -2170,7 +2357,7 @@
 extern int elf32exec(vnode_t *vp, execa_t *uap, uarg_t *args,
 			intpdata_t *idatap, int level, long *execsz,
 			int setid, caddr_t exec_file, cred_t *cred,
-			int brand_action);
+			int *brand_action);
 extern int elf32core(vnode_t *vp, proc_t *p, cred_t *credp,
 			rlim64_t rlimit, int sig, core_content_t content);
 
usr/src/uts/common/exec/intp/intp.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/exec/intp/intp.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/exec/intp/intp.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  * Copyright 2012 Milan Jurik. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1988 AT&T	*/
@@ -46,6 +47,7 @@
 #include <sys/exec.h>
 #include <sys/kmem.h>
 #include <sys/note.h>
+#include <sys/sdt.h>
 
 /*
  * This is the loadable module wrapper.
@@ -53,7 +55,7 @@
 #include <sys/modctl.h>
 
 extern int intpexec(struct vnode *, struct execa *, struct uarg *,
-    struct intpdata *, int, long *, int, caddr_t, struct cred *, int);
+    struct intpdata *, int, long *, int, caddr_t, struct cred *, int *);
 
 static struct execsw esw = {
 	intpmagicstr,
@@ -137,19 +139,19 @@
 		;
 	if (*cp == '\0')
 		return (ENOEXEC);
-	idatap->intp_name = cp;
+	idatap->intp_name[0] = cp;
 	while (*cp && *cp != ' ')
 		cp++;
-	if (*cp == '\0')
-		idatap->intp_arg = NULL;
-	else {
+	if (*cp == '\0') {
+		idatap->intp_arg[0] = NULL;
+	} else {
 		*cp++ = '\0';
 		while (*cp == ' ')
 			cp++;
 		if (*cp == '\0')
-			idatap->intp_arg = NULL;
+			idatap->intp_arg[0] = NULL;
 		else {
-			idatap->intp_arg = cp;
+			idatap->intp_arg[0] = cp;
 			while (*cp && *cp != ' ')
 				cp++;
 			*cp = '\0';
@@ -158,6 +160,24 @@
 	return (0);
 }
 
+/*
+ * We support nested interpreters up to a depth of INTP_MAXDEPTH (this value
+ * matches the depth on Linux). When a nested interpreter is in use, the
+ * previous name and argument must be passed along. We use the intpdata_t
+ * name and argument arrays for this. In the normal, non-nested case, only the
+ * first element in those arrays will be populated.
+ *
+ * For setid scripts the "script hole" is a security race condition between
+ * when we exec the interpreter and when the interpreter reads the script. We
+ * handle this below for the initial script, but we don't allow setid scripts
+ * when using nested interpreters. Because gexec only modifies the credentials
+ * for a setid script at level 0, then if we come back through for a nested
+ * interpreter we know that args->fname will be set (the first script is setid)
+ * and we can return an error. If an intermediate nested interpreter is setid
+ * then it will not be run with different credentials because of the gexec
+ * handling, so it is effectively no longer setid and we don't have to worry
+ * about the "script hole".
+ */
 int
 intpexec(
 	struct vnode *vp,
@@ -169,9 +189,8 @@
 	int setid,
 	caddr_t exec_file,
 	struct cred *cred,
-	int brand_action)
+	int *brand_action)
 {
-	_NOTE(ARGUNUSED(brand_action))
 	vnode_t *nvp;
 	int error = 0;
 	struct intpdata idata;
@@ -181,13 +200,16 @@
 	char devfd[19]; /* 32-bit int fits in 10 digits + 8 for "/dev/fd/" */
 	int fd = -1;
 
-	if (level) {		/* Can't recurse */
-		error = ENOEXEC;
+	if (level >= INTP_MAXDEPTH) {	/* Can't recurse past maxdepth */
+		error = ELOOP;
 		goto bad;
 	}
 
-	ASSERT(idatap == (struct intpdata *)NULL);
+	if (level == 0)
+		ASSERT(idatap == (struct intpdata *)NULL);
 
+	bzero(&idata, sizeof (intpdata_t));
+
 	/*
 	 * Allocate a buffer to read in the interpreter pathname.
 	 */
@@ -198,7 +220,7 @@
 	/*
 	 * Look the new vnode up.
 	 */
-	if (error = pn_get(idata.intp_name, UIO_SYSSPACE, &intppn))
+	if (error = pn_get(idata.intp_name[0], UIO_SYSSPACE, &intppn))
 		goto fail;
 	pn_alloc(&resolvepn);
 	if (error = lookuppn(&intppn, &resolvepn, FOLLOW, NULLVPP, &nvp)) {
@@ -206,6 +228,28 @@
 		pn_free(&intppn);
 		goto fail;
 	}
+
+	if (level > 0) {
+		/*
+		 * We have a nested interpreter. The previous name(s) and
+		 * argument(s) need to be passed along. We also keep track
+		 * of how often this zone uses nested interpreters.
+		 */
+		int i;
+
+		atomic_inc_32(&curproc->p_zone->zone_nested_intp);
+
+		ASSERT(idatap != NULL);
+		/* since we're shifting up, loop stops one short */
+		for (i = 0; i < (INTP_MAXDEPTH - 1); i++) {
+			idata.intp_name[i + 1] = idatap->intp_name[i];
+			idata.intp_arg[i + 1] = idatap->intp_arg[i];
+		}
+
+		DTRACE_PROBE3(nested__intp, int, level, void *, &idata,
+		    void *, nvp);
+	}
+
 	opath = args->pathname;
 	args->pathname = resolvepn.pn_path;
 	/* don't free resolvepn until we are done with args */
@@ -212,6 +256,15 @@
 	pn_free(&intppn);
 
 	/*
+	 * Disallow setuid or additional privilege execution for nested
+	 * interpreters.
+	 */
+	if (level > 0 && args->fname != NULL) {
+		error = ENOEXEC;
+		goto done;
+	}
+
+	/*
 	 * When we're executing a set-uid script resulting in uids
 	 * mismatching or when we execute with additional privileges,
 	 * we close the "replace script between exec and open by shell"
@@ -228,7 +281,7 @@
 	}
 
 	error = gexec(&nvp, uap, args, &idata, ++level, execsz, exec_file, cred,
-	    EBA_NONE);
+	    brand_action);
 
 	if (!error) {
 		/*
usr/src/uts/common/exec/java/java.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/exec/java/java.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/exec/java/java.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*
@@ -85,7 +86,7 @@
 static int
 javaexec(vnode_t *vp, struct execa *uap, struct uarg *args,
     struct intpdata *idatap, int level, long *execsz, int setid,
-    caddr_t execfile, cred_t *cred, int brand_action)
+    caddr_t execfile, cred_t *cred, int *brand_action)
 {
 	struct intpdata idata;
 	int error;
@@ -145,9 +146,9 @@
 	 * Find and invoke the Java runtime environment on the file
 	 */
 	idata.intp = NULL;
-	idata.intp_name = jexec;
-	idata.intp_arg = jexec_arg;
-	if (error = pn_get(idata.intp_name, UIO_SYSSPACE, &lookpn))
+	idata.intp_name[0] = jexec;
+	idata.intp_arg[0] = jexec_arg;
+	if (error = pn_get(idata.intp_name[0], UIO_SYSSPACE, &lookpn))
 		return (error);
 	pn_alloc(&resolvepn);
 	if (error = lookuppn(&lookpn, &resolvepn, FOLLOW, NULLVPP, &nvp)) {
usr/src/uts/common/exec/shbin/shbin.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/exec/shbin/shbin.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/exec/shbin/shbin.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -58,7 +59,7 @@
 	int setid,
 	caddr_t exec_file,
 	struct cred *cred,
-	int brand_action);
+	int *brand_action);
 
 #define	SHBIN_CNTL(x)	((x)&037)
 #define	SHBINMAGIC_LEN	4
@@ -162,7 +163,7 @@
 	int setid,
 	caddr_t exec_file,
 	struct cred *cred,
-	int brand_action)
+	int *brand_action)
 {
 	_NOTE(ARGUNUSED(brand_action))
 	vnode_t *nvp;
@@ -221,8 +222,8 @@
 	 * a script's name starts with a '-' character.
 	 */
 	idata.intp = NULL;
-	idata.intp_name = shell_list[i];
-	idata.intp_arg = "--";
+	idata.intp_name[0] = shell_list[i];
+	idata.intp_arg[0] = "--";
 
 	opath = args->pathname;
 	args->pathname = resolvepn.pn_path;
usr/src/uts/common/fs/fifofs/fifosubr.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/fifofs/fifosubr.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/fifofs/fifosubr.c	Wed Jun 17 17:43:42 2015
@@ -614,9 +614,12 @@
 	/*
 	 * The other end of the pipe is almost closed so
 	 * reject any other open on this end of the pipe
-	 * This only happens with a pipe mounted under namefs
+	 * This normally only happens with a pipe mounted under namefs, but
+	 * we can also see an open via proc/fd, which should still succeed.
+	 * To indicate the proc/fd case the FKLYR flag is passed.
 	 */
-	if ((fnp->fn_flag & (FIFOCLOSE|ISPIPE)) == (FIFOCLOSE|ISPIPE)) {
+	if ((fnp->fn_flag & (FIFOCLOSE|ISPIPE)) == (FIFOCLOSE|ISPIPE) &&
+	    (flag & FKLYR) == 0) {
 		fifo_cleanup(oldvp, flag);
 		cv_broadcast(&fnp->fn_wait_cv);
 		if (!lockheld)
usr/src/uts/common/fs/fifofs/fifovnops.c
No differences encountered
usr/src/uts/common/fs/lxproc/lxpr_vnops.c
usr/src/uts/common/fs/lxproc/lxproc.h
usr/src/uts/common/fs/proc/prargv.c
usr/src/uts/common/fs/proc/prcontrol.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/proc/prcontrol.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/proc/prcontrol.c	Wed Jan  6 14:59:25 2016
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright (c) 2013, Joyent, Inc.  All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -1481,7 +1481,7 @@
 		} else if (t->t_state == TS_STOPPED && sig == SIGKILL) {
 			/* If SIGKILL, set stopped lwp running */
 			p->p_stopsig = 0;
-			t->t_schedflag |= TS_XSTART | TS_PSTART;
+			t->t_schedflag |= TS_XSTART | TS_PSTART | TS_BSTART;
 			t->t_dtrace_stop = 0;
 			setrun_locked(t);
 		}
usr/src/uts/common/fs/proc/prdata.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/proc/prdata.h	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/proc/prdata.h	Wed Jun 17 17:43:42 2015
@@ -27,7 +27,7 @@
 /*	  All Rights Reserved  	*/
 
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #ifndef _SYS_PROC_PRDATA_H
@@ -123,6 +123,7 @@
 #if defined(__i386) || defined(__amd64)
 	PR_LDT,			/* /proc/<pid>/ldt			*/
 #endif
+	PR_ARGV,		/* /proc/<pid>/argv			*/
 	PR_USAGE,		/* /proc/<pid>/usage			*/
 	PR_LUSAGE,		/* /proc/<pid>/lusage			*/
 	PR_PAGEDATA,		/* /proc/<pid>/pagedata			*/
@@ -347,6 +348,8 @@
 extern	void	pr_sethold(prnode_t *, sigset_t *);
 extern	void	pr_setfault(proc_t *, fltset_t *);
 extern	int	prusrio(proc_t *, enum uio_rw, struct uio *, int);
+extern	int	prreadargv(proc_t *, char *, size_t, size_t *);
+extern	int	prreadenvv(proc_t *, char *, size_t, size_t *);
 extern	int	prwritectl(vnode_t *, struct uio *, cred_t *);
 extern	int	prlock(prnode_t *, int);
 extern	void	prunmark(proc_t *);
usr/src/uts/common/fs/proc/prsubr.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/proc/prsubr.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/proc/prsubr.c	Wed Jan  6 14:59:25 2016
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -201,6 +201,7 @@
 			case PR_SYSEXIT:
 			case PR_SIGNALLED:
 			case PR_FAULTED:
+			case PR_BRAND:
 				/*
 				 * Make an lwp calling exit() be the
 				 * last lwp seen in the process.
usr/src/uts/common/fs/proc/prvnops.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/proc/prvnops.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/proc/prvnops.c	Wed Jan  6 14:59:25 2016
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984,	 1986, 1987, 1988, 1989 AT&T	*/
@@ -96,6 +96,11 @@
 #define	PRSDSIZE	(sizeof (struct prdirect))
 
 /*
+ * Maximum length of the /proc/$$/argv file:
+ */
+int prmaxargvlen = 4096;
+
+/*
  * Directory characteristics.
  */
 typedef struct prdirent {
@@ -166,6 +171,8 @@
 	{ PR_LDT,	27 * sizeof (prdirent_t), sizeof (prdirent_t),
 		"ldt" },
 #endif
+	{ PR_ARGV,	28 * sizeof (prdirent_t), sizeof (prdirent_t),
+		"argv" },
 };
 
 #define	NPIDDIRFILES	(sizeof (piddir) / sizeof (piddir[0]) - 2)
@@ -582,6 +589,7 @@
 #if defined(__x86)
 	pr_read_ldt(),
 #endif
+	pr_read_argv(),
 	pr_read_usage(), pr_read_lusage(), pr_read_pagedata(),
 	pr_read_watch(), pr_read_lwpstatus(), pr_read_lwpsinfo(),
 	pr_read_lwpusage(), pr_read_xregs(), pr_read_priv(),
@@ -610,6 +618,7 @@
 #if defined(__x86)
 	pr_read_ldt,		/* /proc/<pid>/ldt			*/
 #endif
+	pr_read_argv,		/* /proc/<pid>/argv			*/
 	pr_read_usage,		/* /proc/<pid>/usage			*/
 	pr_read_lusage,		/* /proc/<pid>/lusage			*/
 	pr_read_pagedata,	/* /proc/<pid>/pagedata			*/
@@ -672,6 +681,41 @@
 }
 
 static int
+pr_read_argv(prnode_t *pnp, uio_t *uiop)
+{
+	char *args;
+	int error;
+	size_t asz = prmaxargvlen, sz;
+
+	/*
+	 * Allocate a scratch buffer for collection of the process arguments.
+	 */
+	args = kmem_alloc(asz, KM_SLEEP);
+
+	ASSERT(pnp->pr_type == PR_ARGV);
+
+	if ((error = prlock(pnp, ZNO)) != 0) {
+		kmem_free(args, asz);
+		return (error);
+	}
+
+	if ((error = prreadargv(pnp->pr_common->prc_proc, args, asz,
+	    &sz)) != 0) {
+		prunlock(pnp);
+		kmem_free(args, asz);
+		return (error);
+	}
+
+	prunlock(pnp);
+
+	error = pr_uioread(args, sz, uiop);
+
+	kmem_free(args, asz);
+
+	return (error);
+}
+
+static int
 pr_read_as(prnode_t *pnp, uio_t *uiop)
 {
 	int error;
@@ -1767,6 +1811,7 @@
 #if defined(__x86)
 	pr_read_ldt,		/* /proc/<pid>/ldt			*/
 #endif
+	pr_read_argv,		/* /proc/<pid>/argv			*/
 	pr_read_usage_32,	/* /proc/<pid>/usage			*/
 	pr_read_lusage_32,	/* /proc/<pid>/lusage			*/
 	pr_read_pagedata_32,	/* /proc/<pid>/pagedata			*/
@@ -2686,6 +2731,103 @@
 #endif
 }
 
+/*
+ * We make pr_write_psinfo_fname() somewhat simpler by asserting at compile
+ * time that PRFNSZ has the same definition as MAXCOMLEN.
+ */
+#if PRFNSZ != MAXCOMLEN
+#error PRFNSZ/MAXCOMLEN mismatch
+#endif
+
+static int
+pr_write_psinfo_fname(prnode_t *pnp, uio_t *uiop)
+{
+	char fname[PRFNSZ];
+	int offset = offsetof(psinfo_t, pr_fname), error;
+
+#ifdef _SYSCALL32_IMPL
+	if (curproc->p_model != DATAMODEL_LP64)
+		offset = offsetof(psinfo32_t, pr_fname);
+#endif
+
+	/*
+	 * If this isn't a write to pr_fname (or if the size doesn't match
+	 * PRFNSZ) return.
+	 */
+	if (uiop->uio_offset != offset || uiop->uio_resid != PRFNSZ)
+		return (0);
+
+	if ((error = uiomove(fname, PRFNSZ, UIO_WRITE, uiop)) != 0)
+		return (error);
+
+	fname[PRFNSZ - 1] = '\0';
+
+	if ((error = prlock(pnp, ZNO)) != 0)
+		return (error);
+
+	bcopy(fname, pnp->pr_common->prc_proc->p_user.u_comm, PRFNSZ);
+
+	prunlock(pnp);
+
+	return (0);
+}
+
+/*
+ * We make pr_write_psinfo_psargs() somewhat simpler by asserting at compile
+ * time that PRARGSZ has the same definition as PSARGSZ.
+ */
+#if PRARGSZ != PSARGSZ
+#error PRARGSZ/PSARGSZ mismatch
+#endif
+
+static int
+pr_write_psinfo_psargs(prnode_t *pnp, uio_t *uiop)
+{
+	char psargs[PRARGSZ];
+	int offset = offsetof(psinfo_t, pr_psargs), error;
+
+#ifdef _SYSCALL32_IMPL
+	if (curproc->p_model != DATAMODEL_LP64)
+		offset = offsetof(psinfo32_t, pr_psargs);
+#endif
+
+	/*
+	 * If this isn't a write to pr_psargs (or if the size doesn't match
+	 * PRARGSZ) return.
+	 */
+	if (uiop->uio_offset != offset || uiop->uio_resid != PRARGSZ)
+		return (0);
+
+	if ((error = uiomove(psargs, PRARGSZ, UIO_WRITE, uiop)) != 0)
+		return (error);
+
+	psargs[PRARGSZ - 1] = '\0';
+
+	if ((error = prlock(pnp, ZNO)) != 0)
+		return (error);
+
+	bcopy(psargs, pnp->pr_common->prc_proc->p_user.u_psargs, PRARGSZ);
+
+	prunlock(pnp);
+
+	return (0);
+}
+
+int
+pr_write_psinfo(prnode_t *pnp, uio_t *uiop)
+{
+	int error;
+
+	if ((error = pr_write_psinfo_fname(pnp, uiop)) != 0)
+		return (error);
+
+	if ((error = pr_write_psinfo_psargs(pnp, uiop)) != 0)
+		return (error);
+
+	return (0);
+}
+
+
 /* ARGSUSED */
 static int
 prwrite(vnode_t *vp, uio_t *uiop, int ioflag, cred_t *cr, caller_context_t *ct)
@@ -2764,6 +2906,9 @@
 			uiop->uio_resid = resid;
 		return (error);
 
+	case PR_PSINFO:
+		return (pr_write_psinfo(pnp, uiop));
+
 	default:
 		return ((vp->v_type == VDIR)? EISDIR : EBADF);
 	}
@@ -3047,6 +3192,13 @@
 	case PR_AUXV:
 		vap->va_size = __KERN_NAUXV_IMPL * PR_OBJSIZE(auxv32_t, auxv_t);
 		break;
+	case PR_ARGV:
+		if ((p->p_flag & SSYS) || p->p_as == &kas) {
+			vap->va_size = PSARGSZ;
+		} else {
+			vap->va_size = prmaxargvlen;
+		}
+		break;
 #if defined(__x86)
 	case PR_LDT:
 		mutex_exit(&p->p_lock);
@@ -3222,6 +3374,7 @@
 	case PR_USAGE:
 	case PR_LUSAGE:
 	case PR_LWPUSAGE:
+	case PR_ARGV:
 		p = pr_p_lock(pnp);
 		mutex_exit(&pr_pidlock);
 		if (p == NULL)
@@ -3307,6 +3460,7 @@
 #if defined(__x86)
 	pr_lookup_notdir,	/* /proc/<pid>/ldt			*/
 #endif
+	pr_lookup_notdir,	/* /proc/<pid>/argv			*/
 	pr_lookup_notdir,	/* /proc/<pid>/usage			*/
 	pr_lookup_notdir,	/* /proc/<pid>/lusage			*/
 	pr_lookup_notdir,	/* /proc/<pid>/pagedata			*/
@@ -4546,11 +4700,15 @@
 		break;
 
 	case PR_PSINFO:
+		pnp->pr_mode = 0644;	/* readable by all + owner can write */
+		break;
+
 	case PR_LPSINFO:
 	case PR_LWPSINFO:
 	case PR_USAGE:
 	case PR_LUSAGE:
 	case PR_LWPUSAGE:
+	case PR_ARGV:
 		pnp->pr_mode = 0444;	/* read-only by all */
 		break;
 
@@ -4656,6 +4814,7 @@
 #if defined(__x86)
 	pr_readdir_notdir,	/* /proc/<pid>/ldt			*/
 #endif
+	pr_readdir_notdir,	/* /proc/<pid>/argv			*/
 	pr_readdir_notdir,	/* /proc/<pid>/usage			*/
 	pr_readdir_notdir,	/* /proc/<pid>/lusage			*/
 	pr_readdir_notdir,	/* /proc/<pid>/pagedata			*/
@@ -4805,6 +4964,7 @@
 			case PR_PROCDIR:
 			case PR_PSINFO:
 			case PR_USAGE:
+			case PR_ARGV:
 				break;
 			default:
 				continue;
usr/src/uts/common/fs/sockfs/sockcommon_sops.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/sockfs/sockcommon_sops.c	Mon Oct 19 10:48:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/sockfs/sockcommon_sops.c	Mon Dec 14 10:47:45 2015
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/types.h>
@@ -128,7 +128,7 @@
 {
 	int error;
 
-	SO_BLOCK_FALLBACK(so, SOP_BIND(so, name, namelen, flags, cr));
+	SO_BLOCK_FALLBACK_SAFE(so, SOP_BIND(so, name, namelen, flags, cr));
 
 	ASSERT(flags == _SOBIND_XPG4_2 || flags == _SOBIND_SOCKBSD);
 
@@ -305,7 +305,7 @@
 	 * This can happen if a non blocking operation caused an error.
 	 */
 
-	if (so->so_error != 0) {
+	if (so->so_error != 0 && (so->so_mode & SM_DEFERERR) == 0) {
 		mutex_enter(&so->so_lock);
 		error = sogeterr(so, B_TRUE);
 		mutex_exit(&so->so_lock);
@@ -404,7 +404,7 @@
 			break;
 		}
 
-		if (so->so_error != 0) {
+		if (so->so_error != 0 && (so->so_mode & SM_DEFERERR) == 0) {
 			mutex_enter(&so->so_lock);
 			error = sogeterr(so, B_TRUE);
 			mutex_exit(&so->so_lock);
@@ -513,7 +513,7 @@
 			error = EPIPE;
 			break;
 		}
-		if (so->so_error != 0) {
+		if (so->so_error != 0 && (so->so_mode & SM_DEFERERR) == 0) {
 			mutex_enter(&so->so_lock);
 			error = sogeterr(so, B_TRUE);
 			mutex_exit(&so->so_lock);
@@ -586,11 +586,6 @@
 
 	SO_BLOCK_FALLBACK(so, SOP_SENDMBLK(so, msg, fflag, cr, mpp));
 
-	if ((so->so_mode & SM_SENDFILESUPP) == 0) {
-		SO_UNBLOCK_FALLBACK(so);
-		return (EOPNOTSUPP);
-	}
-
 	error = so_sendmblk_impl(so, msg, fflag, cr, mpp, so->so_filter_top,
 	    B_FALSE);
 
@@ -653,7 +648,7 @@
 {
 	int error;
 
-	SO_BLOCK_FALLBACK(so, SOP_GETSOCKNAME(so, addr, addrlen, cr));
+	SO_BLOCK_FALLBACK_SAFE(so, SOP_GETSOCKNAME(so, addr, addrlen, cr));
 
 	if (so->so_filter_active == 0 ||
 	    (error = sof_filter_getsockname(so, addr, addrlen, cr)) < 0)
@@ -702,7 +697,7 @@
 	if (level == SOL_FILTER)
 		return (sof_getsockopt(so, option_name, optval, optlenp, cr));
 
-	SO_BLOCK_FALLBACK(so,
+	SO_BLOCK_FALLBACK_SAFE(so,
 	    SOP_GETSOCKOPT(so, level, option_name, optval, optlenp, flags, cr));
 
 	if ((so->so_filter_active == 0 ||
@@ -791,7 +786,7 @@
 	if (level == SOL_FILTER)
 		return (sof_setsockopt(so, option_name, optval, optlen, cr));
 
-	SO_BLOCK_FALLBACK(so,
+	SO_BLOCK_FALLBACK_SAFE(so,
 	    SOP_SETSOCKOPT(so, level, option_name, optval, optlen, cr));
 
 	/* X/Open requires this check */
@@ -876,7 +871,7 @@
 	 * If there is a pending error, return error
 	 * This can happen if a non blocking operation caused an error.
 	 */
-	if (so->so_error != 0) {
+	if (so->so_error != 0 && (so->so_mode & SM_DEFERERR) == 0) {
 		mutex_enter(&so->so_lock);
 		error = sogeterr(so, B_TRUE);
 		mutex_exit(&so->so_lock);
@@ -1329,6 +1324,26 @@
 		}
 	}
 
+	mutex_enter(&so->so_lock);
+	if (so->so_krecv_cb != NULL) {
+		boolean_t cont;
+		so_krecv_f func = so->so_krecv_cb;
+		void *arg = so->so_krecv_arg;
+
+		mutex_exit(&so->so_lock);
+		cont = func(so, mp, msg_size, flags & MSG_OOB, arg);
+		mutex_enter(&so->so_lock);
+		if (cont == B_TRUE) {
+			space_left = so->so_rcvbuf;
+		} else {
+			so->so_rcv_queued = so->so_rcvlowat;
+			*errorp = ENOSPC;
+			space_left = -1;
+		}
+		goto done_unlock;
+	}
+	mutex_exit(&so->so_lock);
+
 	if (flags & MSG_OOB) {
 		so_queue_oob(so, mp, msg_size);
 		mutex_enter(&so->so_lock);
@@ -1607,6 +1622,13 @@
 		return (ENOTCONN);
 	}
 
+	mutex_enter(&so->so_lock);
+	if (so->so_krecv_cb != NULL) {
+		mutex_exit(&so->so_lock);
+		return (EOPNOTSUPP);
+	}
+	mutex_exit(&so->so_lock);
+
 	if (msg->msg_flags & MSG_PEEK)
 		msg->msg_flags &= ~MSG_WAITALL;
 
usr/src/uts/common/fs/sockfs/sockcommon_subr.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/sockfs/sockcommon_subr.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/sockfs/sockcommon_subr.c	Wed Aug 19 10:40:34 2015
@@ -24,6 +24,7 @@
  */
 /*
  * Copyright 2014, OmniTI Computer Consulting, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -670,10 +671,15 @@
 	int more = 0;
 	int error;
 	ssize_t oobmark;
+	ssize_t copied = 0;
 	sodirect_t *sodp = so->so_direct;
+	xuio_t *xuio = NULL;
 
 	partial_read = B_FALSE;
 	*mctlp = NULL;
+	if ((uiop->uio_extflg & UIO_XUIO) != 0) {
+		xuio = (xuio_t *)uiop;
+	}
 again:
 	mutex_enter(&so->so_lock);
 again1:
@@ -784,8 +790,6 @@
 		 * enabled socket, uio_resid can be 0.
 		 */
 		if (uiop->uio_resid >= 0) {
-			ssize_t copied = 0;
-
 			if (sodp != NULL && (DB_FLAGS(mp) & DBLK_UIOA)) {
 				mutex_enter(&so->so_lock);
 				ASSERT(uiop == (uio_t *)&sodp->sod_uioa);
@@ -843,6 +847,18 @@
 		}
 		if (mp != NULL) { /* more data blocks in msg */
 			more |= MOREDATA;
+
+			/*
+			 * If requested, tally up remaining data along with the
+			 * amount already copied.
+			 */
+			if (xuio != NULL &&
+			    xuio->xu_type == UIOTYPE_PEEKSIZE) {
+				xuio->xu_ext.xu_ps.xu_ps_set = B_TRUE;
+				xuio->xu_ext.xu_ps.xu_ps_size =
+				    copied + msgdsize(mp);
+			}
+
 			if ((flags & (MSG_PEEK|MSG_TRUNC))) {
 				if (flags & MSG_PEEK) {
 					freemsg(mp);
@@ -2276,9 +2292,9 @@
 	fbfunc = sp->sp_smod_info->smod_proto_fallback_func;
 
 	/*
-	 * Cannot fallback if the socket has active filters
+	 * Cannot fallback if the socket has active filters or a krecv callback.
 	 */
-	if (so->so_filter_active > 0)
+	if (so->so_filter_active > 0 || so->so_krecv_cb != NULL)
 		return (EINVAL);
 
 	switch (so->so_family) {
@@ -2455,4 +2471,51 @@
 		freemsg(arg.soqa_urgmark_mp);
 
 	return (error);
+}
+
+int
+so_krecv_set(sonode_t *so, so_krecv_f cb, void *arg)
+{
+	int ret;
+
+	if (cb == NULL && arg != NULL)
+		return (EINVAL);
+
+	SO_BLOCK_FALLBACK(so, so_krecv_set(so, cb, arg));
+
+	mutex_enter(&so->so_lock);
+	if (so->so_state & SS_FALLBACK_COMP) {
+		mutex_exit(&so->so_lock);
+		SO_UNBLOCK_FALLBACK(so);
+		return (ENOTSUP);
+	}
+
+	ret = so_lock_read(so, 0);
+	VERIFY(ret == 0);
+	/*
+	 * Other consumers may actually care about getting extant data delivered
+	 * to them, when they come along, they should figure out the best API
+	 * for that.
+	 */
+	so_rcv_flush(so);
+
+	so->so_krecv_cb = cb;
+	so->so_krecv_arg = arg;
+
+	so_unlock_read(so);
+	mutex_exit(&so->so_lock);
+	SO_UNBLOCK_FALLBACK(so);
+
+	return (0);
+}
+
+void
+so_krecv_unblock(sonode_t *so)
+{
+	mutex_enter(&so->so_lock);
+	VERIFY(so->so_krecv_cb != NULL);
+
+	so->so_rcv_queued = 0;
+	(void) so_check_flow_control(so);
+	mutex_exit(&so->so_lock);
 }
usr/src/uts/common/fs/sockfs/socksubr.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/sockfs/socksubr.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/sockfs/socksubr.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 1995, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015, Joyent, Inc. All rights reserved.
  */
 
 #include <sys/types.h>
@@ -436,10 +437,12 @@
  *
  * The underlying filesystem VSOCK vnode has a v_stream pointer that
  * references the actual stream head (hence indirectly the actual sonode).
+ *
+ * This function is non-static so it can be used by brand emulation.
  */
-static int
+int
 so_ux_lookup(struct sonode *so, struct sockaddr_un *soun, int checkaccess,
-		vnode_t **vpp)
+    vnode_t **vpp)
 {
 	vnode_t		*vp;	/* Underlying filesystem vnode */
 	vnode_t		*rvp;	/* real vnode */
@@ -660,7 +663,7 @@
 	/*
 	 * Use the address of the peer vnode as the address to send
 	 * to. We release the peer vnode here. In case it has been
-	 * closed by the time the T_CONN_REQ or T_UNIDATA_REQ reaches the
+	 * closed by the time the T_CONN_REQ or T_UNITDATA_REQ reaches the
 	 * transport the message will get an error or be dropped.
 	 */
 	sti->sti_ux_faddr.soua_vp = vp;
@@ -1879,7 +1882,7 @@
 soreadfile(file_t *fp, uchar_t *buf, u_offset_t fileoff, int *err, size_t size)
 {
 	struct uio auio;
-	struct iovec aiov[MSG_MAXIOVLEN];
+	struct iovec aiov[1];
 	register vnode_t *vp;
 	int ioflag, rwflag;
 	ssize_t cnt;
usr/src/uts/common/fs/sockfs/socktpi_impl.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/fs/sockfs/socktpi_impl.h	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/fs/sockfs/socktpi_impl.h	Wed Jul 22 10:54:06 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #ifndef _SOCKFS_SOCKTPI_IMPL_H
@@ -56,6 +57,8 @@
 extern int	sogetwrerr(vnode_t *, int, int *);
 extern int	so_addr_verify(struct sonode *, const struct sockaddr *,
 			socklen_t);
+extern int	so_ux_lookup(struct sonode *, struct sockaddr_un *, int,
+		vnode_t **);
 extern int	so_ux_addr_xlate(struct sonode *, struct sockaddr *,
 			socklen_t, int, void **, socklen_t *);
 extern void	so_unix_close(struct sonode *);
usr/src/uts/common/inet/ip/conn_opt.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/ip/conn_opt.c	Tue Jul 21 14:14:27 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/ip/conn_opt.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 /* Copyright (c) 1990 Mentat Inc. */
 
@@ -619,6 +620,9 @@
 		case SO_REUSEADDR:
 			*i1 = connp->conn_reuseaddr ? SO_REUSEADDR : 0;
 			break;	/* goto sizeof (int) option return */
+		case SO_REUSEPORT:
+			*i1 = connp->conn_reuseport;
+			break;	/* goto sizeof (int) option return */
 		case SO_TYPE:
 			*i1 = connp->conn_so_type;
 			break;	/* goto sizeof (int) option return */
usr/src/uts/common/inet/ip/ipclassifier.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/ip/ipclassifier.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/ip/ipclassifier.c	Mon Dec 14 10:47:45 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /*
@@ -868,67 +869,91 @@
 	mutex_exit(&(connfp)->connf_lock);				\
 }
 
-#define	IPCL_HASH_INSERT_BOUND(connfp, connp) {				\
-	conn_t *pconnp = NULL, *nconnp;					\
-	IPCL_HASH_REMOVE((connp));					\
-	mutex_enter(&(connfp)->connf_lock);				\
-	nconnp = (connfp)->connf_head;					\
-	while (nconnp != NULL &&					\
-	    !_IPCL_V4_MATCH_ANY(nconnp->conn_laddr_v6)) {		\
-		pconnp = nconnp;					\
-		nconnp = nconnp->conn_next;				\
-	}								\
-	if (pconnp != NULL) {						\
-		pconnp->conn_next = (connp);				\
-		(connp)->conn_prev = pconnp;				\
-	} else {							\
-		(connfp)->connf_head = (connp);				\
-	}								\
-	if (nconnp != NULL) {						\
-		(connp)->conn_next = nconnp;				\
-		nconnp->conn_prev = (connp);				\
-	}								\
-	(connp)->conn_fanout = (connfp);				\
-	(connp)->conn_flags = ((connp)->conn_flags & ~IPCL_REMOVED) |	\
-	    IPCL_BOUND;							\
-	CONN_INC_REF(connp);						\
-	mutex_exit(&(connfp)->connf_lock);				\
-}
+/*
+ * When inserting bound or wildcard entries into the hash, ordering rules are
+ * used to facilitate timely and correct lookups.  The order is as follows:
+ * 1. Entries bound to a specific address
+ * 2. Entries bound to INADDR_ANY
+ * 3. Entries bound to ADDR_UNSPECIFIED
+ * Entries in a category which share conn_lport (such as those using
+ * SO_REUSEPORT) will be ordered such that the newest inserted is first.
+ */
 
-#define	IPCL_HASH_INSERT_WILDCARD(connfp, connp) {			\
-	conn_t **list, *prev, *next;					\
-	boolean_t isv4mapped =						\
-	    IN6_IS_ADDR_V4MAPPED(&(connp)->conn_laddr_v6);		\
-	IPCL_HASH_REMOVE((connp));					\
-	mutex_enter(&(connfp)->connf_lock);				\
-	list = &(connfp)->connf_head;					\
-	prev = NULL;							\
-	while ((next = *list) != NULL) {				\
-		if (isv4mapped &&					\
-		    IN6_IS_ADDR_UNSPECIFIED(&next->conn_laddr_v6) &&	\
-		    connp->conn_zoneid == next->conn_zoneid) {		\
-			(connp)->conn_next = next;			\
-			if (prev != NULL)				\
-				prev = next->conn_prev;			\
-			next->conn_prev = (connp);			\
-			break;						\
-		}							\
-		list = &next->conn_next;				\
-		prev = next;						\
-	}								\
-	(connp)->conn_prev = prev;					\
-	*list = (connp);						\
-	(connp)->conn_fanout = (connfp);				\
-	(connp)->conn_flags = ((connp)->conn_flags & ~IPCL_REMOVED) |	\
-	    IPCL_BOUND;							\
-	CONN_INC_REF((connp));						\
-	mutex_exit(&(connfp)->connf_lock);				\
+void
+ipcl_hash_insert_bound(connf_t *connfp, conn_t *connp)
+{
+	conn_t *pconnp, *nconnp;
+
+	IPCL_HASH_REMOVE(connp);
+	mutex_enter(&connfp->connf_lock);
+	nconnp = connfp->connf_head;
+	pconnp = NULL;
+	while (nconnp != NULL) {
+		/*
+		 * Walk though entries associated with the fanout until one is
+		 * found which fulfills any of these conditions:
+		 * 1. Listen address of ADDR_ANY/ADDR_UNSPECIFIED
+		 * 2. Listen port the same as connp
+		 */
+		if (_IPCL_V4_MATCH_ANY(nconnp->conn_laddr_v6) ||
+		    connp->conn_lport == nconnp->conn_lport)
+			break;
+		pconnp = nconnp;
+		nconnp = nconnp->conn_next;
+	}
+	if (pconnp != NULL) {
+		pconnp->conn_next = connp;
+		connp->conn_prev = pconnp;
+	} else {
+		connfp->connf_head = connp;
+	}
+	if (nconnp != NULL) {
+		connp->conn_next = nconnp;
+		nconnp->conn_prev = connp;
+	}
+	connp->conn_fanout = connfp;
+	connp->conn_flags = (connp->conn_flags & ~IPCL_REMOVED) | IPCL_BOUND;
+	CONN_INC_REF(connp);
+	mutex_exit(&connfp->connf_lock);
 }
 
 void
 ipcl_hash_insert_wildcard(connf_t *connfp, conn_t *connp)
 {
-	IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+	conn_t **list, *prev, *next;
+	conn_t *pconnp = NULL, *nconnp;
+	boolean_t isv4mapped = IN6_IS_ADDR_V4MAPPED(&connp->conn_laddr_v6);
+
+	IPCL_HASH_REMOVE(connp);
+	mutex_enter(&connfp->connf_lock);
+	nconnp = connfp->connf_head;
+	pconnp = NULL;
+	while (nconnp != NULL) {
+		if (IN6_IS_ADDR_V4MAPPED_ANY(&nconnp->conn_laddr_v6) &&
+		    isv4mapped && connp->conn_lport == nconnp->conn_lport)
+			break;
+		if (IN6_IS_ADDR_UNSPECIFIED(&nconnp->conn_laddr_v6) &&
+		    (isv4mapped ||
+		    connp->conn_lport == nconnp->conn_lport))
+			break;
+
+		pconnp = nconnp;
+		nconnp = nconnp->conn_next;
+	}
+	if (pconnp != NULL) {
+		pconnp->conn_next = connp;
+		connp->conn_prev = pconnp;
+	} else {
+		connfp->connf_head = connp;
+	}
+	if (nconnp != NULL) {
+		connp->conn_next = nconnp;
+		nconnp->conn_prev = connp;
+	}
+	connp->conn_fanout = connfp;
+	connp->conn_flags = (connp->conn_flags & ~IPCL_REMOVED) | IPCL_BOUND;
+	CONN_INC_REF(connp);
+	mutex_exit(&connfp->connf_lock);
 }
 
 /*
@@ -1034,9 +1059,9 @@
 	    IN6_IS_ADDR_V4MAPPED_ANY(&connp->conn_faddr_v6)) {
 		if (IN6_IS_ADDR_UNSPECIFIED(&connp->conn_laddr_v6) ||
 		    IN6_IS_ADDR_V4MAPPED_ANY(&connp->conn_laddr_v6)) {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		}
 	} else {
 		IPCL_HASH_INSERT_CONNECTED(connfp, connp);
@@ -1205,9 +1230,9 @@
 		if (connp->conn_faddr_v4 != INADDR_ANY) {
 			IPCL_HASH_INSERT_CONNECTED(connfp, connp);
 		} else if (connp->conn_laddr_v4 != INADDR_ANY) {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		}
 		if (protocol == IPPROTO_RSVP)
 			ill_set_inputfn_all(ipst);
@@ -1219,9 +1244,9 @@
 		connfp = &ipst->ips_ipcl_bind_fanout[
 		    IPCL_BIND_HASH(lport, ipst)];
 		if (connp->conn_laddr_v4 != INADDR_ANY) {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		}
 		if (cl_inet_listen != NULL) {
 			ASSERT(connp->conn_ipversion == IPV4_VERSION);
@@ -1271,9 +1296,9 @@
 		if (!IN6_IS_ADDR_UNSPECIFIED(&connp->conn_faddr_v6)) {
 			IPCL_HASH_INSERT_CONNECTED(connfp, connp);
 		} else if (!IN6_IS_ADDR_UNSPECIFIED(&connp->conn_laddr_v6)) {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		}
 		break;
 
@@ -1283,9 +1308,9 @@
 		connfp = &ipst->ips_ipcl_bind_fanout[
 		    IPCL_BIND_HASH(lport, ipst)];
 		if (!IN6_IS_ADDR_UNSPECIFIED(&connp->conn_laddr_v6)) {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		}
 		if (cl_inet_listen != NULL) {
 			sa_family_t	addr_family;
@@ -1416,9 +1441,9 @@
 		if (connp->conn_faddr_v4 != INADDR_ANY) {
 			IPCL_HASH_INSERT_CONNECTED(connfp, connp);
 		} else if (connp->conn_laddr_v4 != INADDR_ANY) {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		}
 		break;
 	}
@@ -1504,9 +1529,9 @@
 		if (!IN6_IS_ADDR_UNSPECIFIED(&connp->conn_faddr_v6)) {
 			IPCL_HASH_INSERT_CONNECTED(connfp, connp);
 		} else if (!IN6_IS_ADDR_UNSPECIFIED(&connp->conn_laddr_v6)) {
-			IPCL_HASH_INSERT_BOUND(connfp, connp);
+			ipcl_hash_insert_bound(connfp, connp);
 		} else {
-			IPCL_HASH_INSERT_WILDCARD(connfp, connp);
+			ipcl_hash_insert_wildcard(connfp, connp);
 		}
 		break;
 	}
usr/src/uts/common/inet/ipclassifier.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/ipclassifier.h	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/ipclassifier.h	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #ifndef	_INET_IPCLASSIFIER_H
@@ -293,7 +294,8 @@
 		conn_ipv6_recvpathmtu : 1,	/* IPV6_RECVPATHMTU */
 		conn_mcbc_bind : 1,		/* Bound to multi/broadcast */
 
-		conn_pad_to_bit_31 : 12;
+		conn_reuseport : 1,		/* SO_REUSEPORT state */
+		conn_pad_to_bit_31 : 11;
 
 	boolean_t	conn_blocked;		/* conn is flow-controlled */
 
usr/src/uts/common/inet/tcp.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/tcp.h	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/tcp.h	Mon Dec 14 10:47:45 2015
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, Joyent, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
  * Copyright (c) 2014 by Delphix. All rights reserved.
  */
@@ -134,6 +134,7 @@
 
 struct conn_s;
 struct tcp_listen_cnt_s;
+struct tcp_rg_s;
 
 /*
  * Control structure for each open TCP stream,
@@ -404,6 +405,13 @@
 	struct tcp_s *tcp_bind_hash_port; /* tcp_t's bound to the same lport */
 	struct tcp_s **tcp_ptpbhn;
 
+	/*
+	 * Group of tcp_t entries bound to the same adress and port via
+	 * SO_REUSEPORT.  The pointer itself is protected by tf_lock in the
+	 * containing tcps_bind_fanout slot.
+	 */
+	struct tcp_rg_s	*tcp_rg_bind;
+
 	uint_t		tcp_maxpsz_multiplier;
 
 	uint32_t	tcp_lso_max; /* maximum LSO payload */
usr/src/uts/common/inet/tcp/tcp.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/tcp/tcp.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/tcp/tcp.c	Mon Dec 14 10:47:45 2015
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, Joyent Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
  * Copyright (c) 2013,2014 by Delphix. All rights reserved.
  * Copyright 2014, OmniTI Computer Consulting, Inc. All rights reserved.
@@ -1423,6 +1423,21 @@
 	tcp_close_mpp(&tcp->tcp_conn.tcp_eager_conn_ind);
 
 	/*
+	 * Destroy any association with SO_REUSEPORT group.
+	 */
+	if (tcp->tcp_rg_bind != NULL) {
+		/*
+		 * This is only necessary for connections which enabled
+		 * SO_REUSEPORT but were never bound.  Such connections should
+		 * be the one and only member of the tcp_rg_tp to which they
+		 * have been associated.
+		 */
+		VERIFY(tcp_rg_remove(tcp->tcp_rg_bind, tcp));
+		tcp_rg_destroy(tcp->tcp_rg_bind);
+		tcp->tcp_rg_bind = NULL;
+	}
+
+	/*
 	 * If this is a non-STREAM socket still holding on to an upper
 	 * handle, release it. As a result of fallback we might also see
 	 * STREAMS based conns with upper handles, in which case there is
@@ -2054,8 +2069,7 @@
  * structure!
  */
 static void
-tcp_reinit_values(tcp)
-	tcp_t *tcp;
+tcp_reinit_values(tcp_t *tcp)
 {
 	tcp_stack_t	*tcps = tcp->tcp_tcps;
 	conn_t		*connp = tcp->tcp_connp;
usr/src/uts/common/inet/tcp/tcp_bind.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/tcp/tcp_bind.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/tcp/tcp_bind.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -55,6 +56,7 @@
 static int	tcp_bind_select_lport(tcp_t *, in_port_t *, boolean_t,
 		    cred_t *cr);
 static in_port_t	tcp_get_next_priv_port(const tcp_t *);
+static int tcp_rg_insert(tcp_rg_t *, struct tcp_s *);
 
 /*
  * Hash list insertion routine for tcp_t structures. Each hash bucket
@@ -172,6 +174,16 @@
 
 	ASSERT(lockp != NULL);
 	mutex_enter(lockp);
+
+	/* destroy any association with SO_REUSEPORT group */
+	if (tcp->tcp_rg_bind != NULL) {
+		if (tcp_rg_remove(tcp->tcp_rg_bind, tcp)) {
+			/* Last one out turns off the lights */
+			tcp_rg_destroy(tcp->tcp_rg_bind);
+		}
+		tcp->tcp_rg_bind = NULL;
+	}
+
 	if (tcp->tcp_ptpbhn) {
 		tcpnext = tcp->tcp_bind_hash_port;
 		if (tcpnext != NULL) {
@@ -636,13 +648,12 @@
 }
 
 /*
- * If the "bind_to_req_port_only" parameter is set, if the requested port
- * number is available, return it, If not return 0
+ * If the "bind_to_req_port_only" parameter is set and the requested port
+ * number is available, return it (else return 0).
  *
- * If "bind_to_req_port_only" parameter is not set and
- * If the requested port number is available, return it.  If not, return
- * the first anonymous port we happen across.  If no anonymous ports are
- * available, return 0. addr is the requested local address, if any.
+ * If "bind_to_req_port_only" parameter is not set and the requested port
+ * number is available, return it.  If not, return the first anonymous port we
+ * happen across.  If no anonymous ports are available, return 0.
  *
  * In either case, when succeeding update the tcp_t to record the port number
  * and insert it in the bind hash table.
@@ -662,6 +673,7 @@
 	int loopmax;
 	conn_t *connp = tcp->tcp_connp;
 	tcp_stack_t	*tcps = tcp->tcp_tcps;
+	boolean_t reuseport = connp->conn_reuseport;
 
 	/*
 	 * Lookup for free addresses is done in a loop and "loopmax"
@@ -698,6 +710,7 @@
 		tf_t		*tbf;
 		tcp_t		*ltcp;
 		conn_t		*lconnp;
+		boolean_t	attempt_reuse = B_FALSE;
 
 		lport = htons(port);
 
@@ -724,6 +737,7 @@
 		for (; ltcp != NULL; ltcp = ltcp->tcp_bind_hash_port) {
 			boolean_t not_socket;
 			boolean_t exclbind;
+			boolean_t addrmatch;
 
 			lconnp = ltcp->tcp_connp;
 
@@ -829,22 +843,34 @@
 			    &lconnp->conn_faddr_v6)))
 				continue;
 
+			addrmatch = IN6_ARE_ADDR_EQUAL(laddr,
+			    &lconnp->conn_bound_addr_v6);
+
+			if (addrmatch && reuseport && bind_to_req_port_only &&
+			    (ltcp->tcp_state == TCPS_BOUND ||
+			    ltcp->tcp_state == TCPS_LISTEN)) {
+				/*
+				 * This entry is bound to the exact same
+				 * address and port.  If SO_REUSEPORT is set on
+				 * the calling socket, attempt to reuse this
+				 * binding if it too appears to be willing.
+				 */
+				attempt_reuse = B_TRUE;
+				break;
+			}
+
 			if (!reuseaddr) {
 				/*
-				 * No socket option SO_REUSEADDR.
-				 * If existing port is bound to
-				 * a non-wildcard IP address
-				 * and the requesting stream is
-				 * bound to a distinct
-				 * different IP addresses
-				 * (non-wildcard, also), keep
-				 * going.
+				 * No socket option SO_REUSEADDR.  If an
+				 * existing port is bound to a non-wildcard IP
+				 * address and the requesting stream is bound
+				 * to a distinct different IP address
+				 * (non-wildcard, also), keep going.
 				 */
 				if (!V6_OR_V4_INADDR_ANY(*laddr) &&
 				    !V6_OR_V4_INADDR_ANY(
 				    lconnp->conn_bound_addr_v6) &&
-				    !IN6_ARE_ADDR_EQUAL(laddr,
-				    &lconnp->conn_bound_addr_v6))
+				    !addrmatch)
 					continue;
 				if (ltcp->tcp_state >= TCPS_BOUND) {
 					/*
@@ -859,27 +885,47 @@
 				 * socket option SO_REUSEADDR is set on the
 				 * binding tcp_t.
 				 *
-				 * If two streams are bound to
-				 * same IP address or both addr
-				 * and bound source are wildcards
-				 * (INADDR_ANY), we want to stop
-				 * searching.
-				 * We have found a match of IP source
-				 * address and source port, which is
-				 * refused regardless of the
-				 * SO_REUSEADDR setting, so we break.
+				 * If two streams are bound to the same IP
+				 * address or both addr and bound source are
+				 * wildcards (INADDR_ANY), we want to stop
+				 * searching.  We have found a match of IP
+				 * source address and source port, which is
+				 * refused regardless of the SO_REUSEADDR
+				 * setting, so we break.
 				 */
-				if (IN6_ARE_ADDR_EQUAL(laddr,
-				    &lconnp->conn_bound_addr_v6) &&
+				if (addrmatch &&
 				    (ltcp->tcp_state == TCPS_LISTEN ||
 				    ltcp->tcp_state == TCPS_BOUND))
 					break;
 			}
 		}
-		if (ltcp != NULL) {
+		if (ltcp != NULL && !attempt_reuse) {
 			/* The port number is busy */
 			mutex_exit(&tbf->tf_lock);
 		} else {
+			if (attempt_reuse) {
+				int err;
+
+				ASSERT(ltcp != NULL);
+				ASSERT(ltcp->tcp_rg_bind != NULL);
+				ASSERT(tcp->tcp_rg_bind != NULL);
+				ASSERT(ltcp->tcp_rg_bind != tcp->tcp_rg_bind);
+
+				err = tcp_rg_insert(ltcp->tcp_rg_bind, tcp);
+				if (err != 0) {
+					mutex_exit(&tbf->tf_lock);
+					return (0);
+				}
+				/*
+				 * Now that the newly-binding socket has joined
+				 * the existing reuseport group on ltcp, it
+				 * should clean up its own (empty) group.
+				 */
+				VERIFY(tcp_rg_remove(tcp->tcp_rg_bind, tcp));
+				tcp_rg_destroy(tcp->tcp_rg_bind);
+				tcp->tcp_rg_bind = ltcp->tcp_rg_bind;
+			}
+
 			/*
 			 * This port is ours. Insert in fanout and mark as
 			 * bound to prevent others from getting the port
@@ -943,4 +989,126 @@
 		 */
 	} while (++count < loopmax);
 	return (0);
+}
+
+/* Max number of members in TCP SO_REUSEPORT group */
+#define	TCP_RG_SIZE_MAX		64
+/* Step size when expanding members array */
+#define	TCP_RG_SIZE_STEP	2
+
+
+tcp_rg_t *
+tcp_rg_init(tcp_t *tcp)
+{
+	tcp_rg_t *rg;
+	rg = kmem_alloc(sizeof (tcp_rg_t), KM_NOSLEEP|KM_NORMALPRI);
+	if (rg == NULL)
+		return (NULL);
+	rg->tcprg_members = kmem_zalloc(2 * sizeof (tcp_t *),
+	    KM_NOSLEEP|KM_NORMALPRI);
+	if (rg->tcprg_members == NULL) {
+		kmem_free(rg, sizeof (tcp_rg_t));
+		return (NULL);
+	}
+
+	mutex_init(&rg->tcprg_lock, NULL, MUTEX_DEFAULT, NULL);
+	rg->tcprg_size = 2;
+	rg->tcprg_count = 1;
+	rg->tcprg_active = 1;
+	rg->tcprg_members[0] = tcp;
+	return (rg);
+}
+
+void
+tcp_rg_destroy(tcp_rg_t *rg)
+{
+	mutex_enter(&rg->tcprg_lock);
+	ASSERT(rg->tcprg_count == 0);
+	ASSERT(rg->tcprg_active == 0);
+	kmem_free(rg->tcprg_members, rg->tcprg_size * sizeof (tcp_t *));
+	mutex_destroy(&rg->tcprg_lock);
+	kmem_free(rg, sizeof (struct tcp_rg_s));
+}
+
+static int
+tcp_rg_insert(tcp_rg_t *rg, tcp_t *tcp)
+{
+	mutex_enter(&rg->tcprg_lock);
+
+	VERIFY(rg->tcprg_size > 0);
+	VERIFY(rg->tcprg_count <= rg->tcprg_size);
+	if (rg->tcprg_count != 0) {
+		cred_t *oldcred = rg->tcprg_members[0]->tcp_connp->conn_cred;
+		cred_t *newcred = tcp->tcp_connp->conn_cred;
+
+		if (crgetuid(oldcred) != crgetuid(newcred) ||
+		    crgetzoneid(oldcred) != crgetzoneid(newcred)) {
+			mutex_exit(&rg->tcprg_lock);
+			return (EPERM);
+		}
+	}
+
+	if (rg->tcprg_count == rg->tcprg_size) {
+		unsigned int oldalloc = rg->tcprg_size * sizeof (tcp_t *);
+		unsigned int newsize = rg->tcprg_size + TCP_RG_SIZE_STEP;
+		tcp_t **newmembers;
+
+		if (newsize > TCP_RG_SIZE_MAX) {
+			mutex_exit(&rg->tcprg_lock);
+			return (EINVAL);
+		}
+		newmembers = kmem_zalloc(newsize * sizeof (tcp_t *),
+		    KM_NOSLEEP|KM_NORMALPRI);
+		if (newmembers == NULL) {
+			mutex_exit(&rg->tcprg_lock);
+			return (ENOMEM);
+		}
+		bcopy(rg->tcprg_members, newmembers, oldalloc);
+		kmem_free(rg->tcprg_members, oldalloc);
+		rg->tcprg_members = newmembers;
+		rg->tcprg_size = newsize;
+	}
+
+	rg->tcprg_members[rg->tcprg_count] = tcp;
+	rg->tcprg_count++;
+	rg->tcprg_active++;
+
+	mutex_exit(&rg->tcprg_lock);
+	return (0);
+}
+
+boolean_t
+tcp_rg_remove(tcp_rg_t *rg, tcp_t *tcp)
+{
+	int i;
+	boolean_t is_empty;
+
+	mutex_enter(&rg->tcprg_lock);
+	for (i = 0; i < rg->tcprg_count; i++) {
+		if (rg->tcprg_members[i] == tcp)
+			break;
+	}
+	/* The item should be present */
+	ASSERT(i < rg->tcprg_count);
+	/* Move the last member into this position */
+	rg->tcprg_count--;
+	rg->tcprg_members[i] = rg->tcprg_members[rg->tcprg_count];
+	rg->tcprg_members[rg->tcprg_count] = NULL;
+	if (tcp->tcp_connp->conn_reuseport != 0)
+		rg->tcprg_active--;
+	is_empty = (rg->tcprg_count == 0);
+	mutex_exit(&rg->tcprg_lock);
+	return (is_empty);
+}
+
+void
+tcp_rg_setactive(tcp_rg_t *rg, boolean_t is_active)
+{
+	mutex_enter(&rg->tcprg_lock);
+	if (is_active) {
+		rg->tcprg_active++;
+	} else {
+		rg->tcprg_active--;
+	}
+	mutex_exit(&rg->tcprg_lock);
 }
usr/src/uts/common/inet/tcp/tcp_opt_data.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/tcp/tcp_opt_data.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/tcp/tcp_opt_data.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -62,7 +63,8 @@
 { SO_USELOOPBACK, SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0
 	},
 { SO_BROADCAST,	SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0 },
-{ SO_REUSEADDR, SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0 },
+{ SO_REUSEADDR,	SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0 },
+{ SO_REUSEPORT,	SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0 },
 { SO_OOBINLINE, SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0 },
 { SO_TYPE,	SOL_SOCKET, OA_R, OA_R, OP_NP, 0, sizeof (int), 0 },
 { SO_SNDBUF,	SOL_SOCKET, OA_RW, OA_RW, OP_NP, 0, sizeof (int), 0 },
@@ -483,6 +485,42 @@
 	return (retval);
 }
 
+static int
+tcp_set_reuseport(conn_t *connp, boolean_t do_enable)
+{
+	tcp_t *tcp = connp->conn_tcp;
+	struct tcp_rg_s *rg;
+
+	if (do_enable && !IPCL_IS_NONSTR(connp)) {
+		/*
+		 * SO_REUSEPORT cannot be enabled on sockets which have fallen
+		 * back to the STREAMS API.
+		 */
+		return (EINVAL);
+	}
+	if (connp->conn_reuseport == 0 && do_enable) {
+		/* disabled -> enabled */
+		if (tcp->tcp_rg_bind != NULL) {
+			tcp_rg_setactive(tcp->tcp_rg_bind, do_enable);
+		} else {
+			if (tcp->tcp_state >= TCPS_BOUND ||
+			    tcp->tcp_state <= TCPS_CLOSED)
+				return (EINVAL);
+			if ((rg = tcp_rg_init(tcp)) == NULL)
+				return (ENOMEM);
+			tcp->tcp_rg_bind = rg;
+		}
+		connp->conn_reuseport = 1;
+	} else if (connp->conn_reuseport != 0 && !do_enable) {
+		/* enabled -> disabled */
+		if (tcp->tcp_rg_bind != NULL) {
+			tcp_rg_setactive(tcp->tcp_rg_bind, do_enable);
+		}
+		connp->conn_reuseport = 0;
+	}
+	return (0);
+}
+
 /*
  * We declare as 'int' rather than 'void' to satisfy pfi_t arg requirements.
  * Parameters are assumed to be verified by the caller.
@@ -653,6 +691,11 @@
 			}
 			*outlenp = inlen;
 			return (0);
+		case SO_REUSEPORT:
+			if (!checkonly) {
+				return (tcp_set_reuseport(connp, *i1 != 0));
+			}
+			return (0);
 		}
 		break;
 	case IPPROTO_TCP:
usr/src/uts/common/inet/tcp/tcp_socket.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/tcp/tcp_socket.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/tcp/tcp_socket.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /* This file contains all TCP kernel socket related functions. */
@@ -1021,6 +1022,16 @@
 		return (ENOMEM);
 	}
 
+	/*
+	 * Do not allow fallback on connections making use of SO_REUSEPORT.
+	 */
+	if (tcp->tcp_rg_bind != NULL) {
+		freeb(stropt_mp);
+		freeb(ordrel_mp);
+		squeue_synch_exit(connp);
+		return (EINVAL);
+	}
+
 	/*
 	 * Both endpoints must be of the same type (either STREAMS or
 	 * non-STREAMS) for fusion to be enabled. So if we are fused,
usr/src/uts/common/inet/tcp_impl.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/tcp_impl.h	Mon Aug  3 18:25:08 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/tcp_impl.h	Mon Dec 14 10:47:45 2015
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, Joyent Inc. All rights reserved.
+ * Copyright 2015 Joyent Inc.
  * Copyright (c) 2013, OmniTI Computer Consulting, Inc. All rights reserved.
  * Copyright (c) 2013, 2014 by Delphix. All rights reserved.
  */
@@ -61,9 +61,9 @@
  * by setting it to 0.
  */
 #define	TCP_XMIT_LOWATER	4096
-#define	TCP_XMIT_HIWATER	49152
+#define	TCP_XMIT_HIWATER	128000
 #define	TCP_RECV_LOWATER	2048
-#define	TCP_RECV_HIWATER	128000
+#define	TCP_RECV_HIWATER	1048576
 
 /*
  * Bind hash list size and has function.  It has to be a power of 2 for
@@ -375,6 +375,22 @@
 	uint32_t	tlc_drop;
 } tcp_listen_cnt_t;
 
+/*
+ * Track tcp_t entities bound to the same port/address tuple via SO_REUSEPORT.
+ * - tcprg_lock:	Protects the other fields
+ * - tcprg_size:	Allocated size (in entries) of tcprg_members array
+ * - tcprg_count:	Count of occupied tcprg_members slots
+ * - tcprg_active:	Count of members which still have SO_REUSEPORT set
+ * - tcprg_members:	Connections associated with address/port group
+ */
+typedef struct tcp_rg_s {
+	kmutex_t	tcprg_lock;
+	unsigned int	tcprg_size;
+	unsigned int	tcprg_count;
+	unsigned int	tcprg_active;
+	tcp_t		**tcprg_members;
+} tcp_rg_t;
+
 #define	TCP_TLC_REPORT_INTERVAL	(30 * MINUTES)
 
 #define	TCP_DECR_LISTEN_CNT(tcp)					\
@@ -618,6 +634,10 @@
 			    int, boolean_t, boolean_t, boolean_t);
 extern in_port_t	tcp_update_next_port(in_port_t, const tcp_t *,
 			    boolean_t);
+extern tcp_rg_t *tcp_rg_init(tcp_t *);
+extern boolean_t tcp_rg_remove(tcp_rg_t *, tcp_t *);
+extern void tcp_rg_destroy(tcp_rg_t *);
+extern void tcp_rg_setactive(tcp_rg_t *, boolean_t);
 
 /*
  * Fusion related functions in tcp_fusion.c.
usr/src/uts/common/inet/udp/udp.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/udp/udp.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/udp/udp.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
  * Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  * Copyright 2014, OmniTI Computer Consulting, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 /* Copyright (c) 1990 Mentat Inc. */
 
@@ -76,7 +77,8 @@
 #include <inet/ipclassifier.h>
 #include <sys/squeue_impl.h>
 #include <inet/ipnet.h>
-#include <sys/ethernet.h>
+#include <sys/vxlan.h>
+#include <inet/inet_hash.h>
 
 #include <sys/tsol/label.h>
 #include <sys/tsol/tnet.h>
@@ -346,6 +348,89 @@
 typedef union T_primitives *t_primp_t;
 
 /*
+ * Various protocols that encapsulate UDP have no real use for the source port.
+ * Instead, they want to vary the source port to provide better equal-cost
+ * multipathing and other systems that use fanout. Consider something like
+ * VXLAN. If you're actually sending multiple different streams to a single
+ * host, if you don't vary the source port, then the tuple of ( SRC IP, DST IP,
+ * SRC Port, DST Port) will always be the same.
+ *
+ * Here, we return a port to hash this to, if we know how to hash it. If for
+ * some reason we can't perform an L4 hash, then we just return the default
+ * value, usually the default port. After we determine the hash we transform it
+ * so that it's in the range of [ min, max ].
+ *
+ * We'd like to avoid a pull up for the sake of performing the hash. If the
+ * first mblk_t doesn't have the full protocol header, then we just send it to
+ * the default. If for some reason we have an encapsulated packet that has its
+ * protocol header in different parts of an mblk_t, then we'll go with the
+ * default port. This means that that if a driver isn't consistent about how it
+ * generates the frames for a given flow, it will not always be consistently
+ * hashed. That should be an uncommon event.
+ */
+uint16_t
+udp_srcport_hash(mblk_t *mp, int type, uint16_t min, uint16_t max,
+    uint16_t def)
+{
+	size_t szused = 0;
+	struct ether_header *ether;
+	struct ether_vlan_header *vether;
+	ip6_t *ip6h;
+	ipha_t *ipha;
+	uint16_t sap;
+	uint64_t hash;
+	uint32_t mod;
+
+	ASSERT(min <= max);
+
+	if (type != UDP_HASH_VXLAN)
+		return (def);
+
+	if (!IS_P2ALIGNED(mp->b_rptr, sizeof (uint16_t)))
+		return (def);
+
+	/*
+	 * The following logic is VXLAN specific to get at the header, if we
+	 * have formats, eg. GENEVE, then we should ignore this.
+	 *
+	 * The kernel overlay device often puts a first mblk_t for the data
+	 * which is just the encap. If so, then we're going to use that and try
+	 * to avoid a pull up.
+	 */
+	if (MBLKL(mp) == VXLAN_HDR_LEN) {
+		if (mp->b_cont == NULL)
+			return (def);
+		mp = mp->b_cont;
+		ether = (struct ether_header *)mp->b_rptr;
+	} else if (MBLKL(mp) < VXLAN_HDR_LEN) {
+		return (def);
+	} else {
+		szused = VXLAN_HDR_LEN;
+		ether = (struct ether_header *)((uintptr_t)mp->b_rptr + szused);
+	}
+
+	/* Can we hold a MAC header? */
+	if (MBLKL(mp) + szused < sizeof (struct ether_header))
+		return (def);
+
+	/*
+	 * We need to lie about the starting offset into the message block for
+	 * convenience. Undo it at the end. We know that inet_pkt_hash() won't
+	 * modify the mblk_t.
+	 */
+	mp->b_rptr += szused;
+	hash = inet_pkt_hash(DL_ETHER, mp, INET_PKT_HASH_L2 |
+	    INET_PKT_HASH_L3 | INET_PKT_HASH_L4);
+	mp->b_rptr -= szused;
+
+	if (hash == 0)
+		return (def);
+
+	mod = max - min + 1;
+	return ((hash % mod) + min);
+}
+
+/*
  * Return the next anonymous port in the privileged port range for
  * bind checking.
  *
@@ -1583,6 +1668,16 @@
 			*i1 = udp->udp_rcvhdr ? 1 : 0;
 			mutex_exit(&connp->conn_lock);
 			return (sizeof (int));
+		case UDP_SRCPORT_HASH:
+			mutex_enter(&connp->conn_lock);
+			*i1 = udp->udp_vxlanhash;
+			mutex_exit(&connp->conn_lock);
+			return (sizeof (int));
+		case UDP_SND_TO_CONNECTED:
+			mutex_enter(&connp->conn_lock);
+			*i1 = udp->udp_snd_to_conn ? 1 : 0;
+			mutex_exit(&connp->conn_lock);
+			return (sizeof (int));
 		}
 	}
 	mutex_enter(&connp->conn_lock);
@@ -1718,6 +1813,31 @@
 			udp->udp_rcvhdr = onoff;
 			mutex_exit(&connp->conn_lock);
 			return (0);
+		case UDP_SRCPORT_HASH:
+			/*
+			 * This should have already been verified, but double
+			 * check.
+			 */
+			if ((error = secpolicy_ip_config(cr, B_FALSE)) != 0) {
+				return (error);
+			}
+
+			/* First see if the val is something we understand */
+			if (*i1 != UDP_HASH_DISABLE && *i1 != UDP_HASH_VXLAN)
+				return (EINVAL);
+
+			if (!checkonly) {
+				mutex_enter(&connp->conn_lock);
+				udp->udp_vxlanhash = *i1;
+				mutex_exit(&connp->conn_lock);
+			}
+			/* Fully handled this option. */
+			return (0);
+		case UDP_SND_TO_CONNECTED:
+			mutex_enter(&connp->conn_lock);
+			udp->udp_snd_to_conn = onoff;
+			mutex_exit(&connp->conn_lock);
+			return (0);
 		}
 		break;
 	}
@@ -2001,7 +2121,9 @@
 	uint32_t	cksum;
 	udp_t		*udp = connp->conn_udp;
 	boolean_t	insert_spi = udp->udp_nat_t_endpoint;
+	boolean_t	hash_srcport = udp->udp_vxlanhash;
 	uint_t		ulp_hdr_len;
+	uint16_t	srcport;
 
 	data_len = msgdsize(data_mp);
 	ulp_hdr_len = UDPH_SIZE;
@@ -2008,6 +2130,16 @@
 	if (insert_spi)
 		ulp_hdr_len += sizeof (uint32_t);
 
+	/*
+	 * If we have source port hashing going on, determine the hash before
+	 * we modify the mblk_t.
+	 */
+	if (hash_srcport == B_TRUE) {
+		srcport = udp_srcport_hash(mp, UDP_HASH_VXLAN,
+		    IPPORT_DYNAMIC_MIN, IPPORT_DYNAMIC_MAX,
+		    ntohs(connp->conn_lport));
+	}
+
 	mp = conn_prepend_hdr(ixa, ipp, v6src, v6dst, IPPROTO_UDP, flowinfo,
 	    ulp_hdr_len, data_mp, data_len, us->us_wroff_extra, &cksum, errorp);
 	if (mp == NULL) {
@@ -2019,7 +2151,11 @@
 	ixa->ixa_pktlen = data_len + ixa->ixa_ip_hdr_length;
 
 	udpha = (udpha_t *)(mp->b_rptr + ixa->ixa_ip_hdr_length);
-	udpha->uha_src_port = connp->conn_lport;
+	if (hash_srcport == B_TRUE) {
+		udpha->uha_src_port = htons(srcport);
+	} else {
+		udpha->uha_src_port = connp->conn_lport;
+	}
 	udpha->uha_dst_port = dstport;
 	udpha->uha_checksum = 0;
 	udpha->uha_length = htons(data_len);
@@ -3194,6 +3330,7 @@
 	udp_t		*udp = connp->conn_udp;
 	udp_stack_t	*us = udp->udp_us;
 	boolean_t	insert_spi = udp->udp_nat_t_endpoint;
+	boolean_t	hash_srcport = udp->udp_vxlanhash;
 	uint_t		pktlen;
 	uint_t		alloclen;
 	uint_t		copylen;
@@ -3202,10 +3339,21 @@
 	udpha_t		*udpha;
 	uint32_t	cksum;
 	ip_pkt_t	*ipp;
+	uint16_t	srcport;
 
 	ASSERT(MUTEX_HELD(&connp->conn_lock));
 
 	/*
+	 * If we have source port hashing going on, determine the hash before
+	 * we modify the mblk_t.
+	 */
+	if (hash_srcport == B_TRUE) {
+		srcport = udp_srcport_hash(mp, UDP_HASH_VXLAN,
+		    IPPORT_DYNAMIC_MIN, IPPORT_DYNAMIC_MAX,
+		    ntohs(connp->conn_lport));
+	}
+
+	/*
 	 * Copy the header template and leave space for an SPI
 	 */
 	copylen = connp->conn_ht_iphc_len;
@@ -3303,6 +3451,9 @@
 		*((uint32_t *)(udpha + 1)) = 0;
 
 	udpha->uha_dst_port = dstport;
+	if (hash_srcport == B_TRUE)
+		udpha->uha_src_port = htons(srcport);
+
 	return (mp);
 }
 
@@ -5947,10 +6098,18 @@
 		else
 			return (error);
 	}
-	if (udp->udp_state == TS_DATA_XFER) {
+
+	/*
+	 * Check if we're allowed to send to a connection on which we've
+	 * already called 'connect'. The posix spec. allows both behaviors but
+	 * historically we've returned an error if already connected. The
+	 * client can allow this via a sockopt.
+	 */
+	if (udp->udp_state == TS_DATA_XFER && !udp->udp_snd_to_conn) {
 		UDPS_BUMP_MIB(us, udpOutErrors);
 		return (EISCONN);
 	}
+
 	error = proto_verify_ip_addr(connp->conn_family,
 	    (struct sockaddr *)msg->msg_name, msg->msg_namelen);
 	if (error != 0) {
usr/src/uts/common/inet/udp/udp_opt_data.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/udp/udp_opt_data.c	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/udp/udp_opt_data.c	Wed Oct 14 16:03:01 2015
@@ -21,6 +21,7 @@
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -292,6 +293,9 @@
 	},
 { UDP_NAT_T_ENDPOINT, IPPROTO_UDP, OA_RW, OA_RW, OP_PRIVPORT, 0, sizeof (int),
 	0 },
+{ UDP_SRCPORT_HASH, IPPROTO_UDP, OA_R, OA_RW, OP_CONFIG, 0, sizeof (int), 0 },
+{ UDP_SND_TO_CONNECTED, IPPROTO_UDP, OA_R, OA_RW, OP_CONFIG, 0, sizeof (int),
+	0 }
 };
 
 /*
usr/src/uts/common/inet/udp_impl.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/inet/udp_impl.h	Tue Jul 21 14:14:28 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/inet/udp_impl.h	Wed Oct 14 16:03:01 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #ifndef	_UDP_IMPL_H
@@ -178,8 +179,12 @@
 		udp_issocket : 1,	/* socket mode; sockfs is on top */
 		udp_nat_t_endpoint : 1,	/* UDP_NAT_T_ENDPOINT option */
 		udp_rcvhdr : 1,		/* UDP_RCVHDR option */
+		udp_vxlanhash: 1,	/* UDP_SRCPORT_HASH option */
+					/* Because there's only VXLAN, cheat */
+					/* and only use a single bit */
+		udp_snd_to_conn: 1,	/* UDP_SND_TO_CONNECTED option */
 
-		udp_pad_to_bit_31 : 29;
+		udp_pad_to_bit_31 : 27;
 
 	/* Following 2 fields protected by the uf_lock */
 	struct udp_s	*udp_bind_hash; /* Bind hash chain */
usr/src/uts/common/io/devpoll.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/io/devpoll.c	Mon Oct 19 10:48:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/io/devpoll.c	Mon Dec 14 10:47:45 2015
@@ -670,15 +670,26 @@
 
 	uiosize = uiop->uio_resid;
 	pollfdnum = uiosize / size;
-	mutex_enter(&curproc->p_lock);
-	if (pollfdnum > (uint_t)rctl_enforced_value(
-	    rctlproc_legacy[RLIMIT_NOFILE], curproc->p_rctls, curproc)) {
-		(void) rctl_action(rctlproc_legacy[RLIMIT_NOFILE],
-		    curproc->p_rctls, curproc, RCA_SAFE);
+
+	/*
+	 * We want to make sure that pollfdnum isn't large enough to DoS us,
+	 * but we also don't want to grab p_lock unnecessarily -- so we
+	 * perform the full check against our resource limits if and only if
+	 * pollfdnum is larger than the known-to-be-sane value of UINT8_MAX.
+	 */
+	if (pollfdnum > UINT8_MAX) {
+		mutex_enter(&curproc->p_lock);
+		if (pollfdnum >
+		    (uint_t)rctl_enforced_value(rctlproc_legacy[RLIMIT_NOFILE],
+		    curproc->p_rctls, curproc)) {
+			(void) rctl_action(rctlproc_legacy[RLIMIT_NOFILE],
+			    curproc->p_rctls, curproc, RCA_SAFE);
+			mutex_exit(&curproc->p_lock);
+			return (EINVAL);
+		}
 		mutex_exit(&curproc->p_lock);
-		return (EINVAL);
 	}
-	mutex_exit(&curproc->p_lock);
+
 	/*
 	 * Copy in the pollfd array.  Walk through the array and add
 	 * each polled fd to the cached set.
usr/src/uts/common/io/pseudo.conf
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/io/pseudo.conf	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/io/pseudo.conf	Wed Jun 17 17:43:43 2015
@@ -22,9 +22,8 @@
 #
 # Copyright 2003 Sun Microsystems, Inc.  All rights reserved.
 # Use is subject to license terms.
+# Copyright 2014 Joyent, Inc.  All rights reserved.
 #
-# ident	"%Z%%M%	%I%	%E% SMI"
-#
 # This file is private to the pseudonex driver.  It should not be edited.
 #
 
@@ -38,3 +37,9 @@
 # /pseudo; it has as its children the zone console pseudo nodes.
 #
 name="zconsnex" parent="/pseudo" instance=1 valid-children="zcons";
+
+#
+# zfdnex is an alias for pseudo; this node is instantiated as a child of
+# /pseudo; it has as its children the zone fd pseudo nodes.
+#
+name="zfdnex" parent="/pseudo" instance=2 valid-children="zfd";
usr/src/uts/common/io/ptm.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/io/ptm.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/io/ptm.c	Wed Jun 17 17:43:43 2015
@@ -447,6 +447,18 @@
 	return (0);
 }
 
+static boolean_t
+ptmptsopencb(ptmptsopencb_arg_t arg)
+{
+	struct pt_ttys	*ptmp = (struct pt_ttys *)arg;
+	boolean_t rval;
+
+	PT_ENTER_READ(ptmp);
+	rval = (ptmp->pt_nullmsg != NULL);
+	PT_EXIT_READ(ptmp);
+	return (rval);
+}
+
 /*
  * The wput procedure will only handle ioctl and flush messages.
  */
@@ -574,6 +586,41 @@
 			miocack(qp, mp, 0, 0);
 			break;
 		}
+		case PTMPTSOPENCB:
+		{
+			mblk_t		*dp;	/* ioctl reply data */
+			ptmptsopencb_t	*ppocb;
+
+			/* only allow the kernel to invoke this ioctl */
+			if (iocp->ioc_cr != kcred) {
+				miocnak(qp, mp, 0, EINVAL);
+				break;
+			}
+
+			/* we don't support transparent ioctls */
+			ASSERT(iocp->ioc_count != TRANSPARENT);
+			if (iocp->ioc_count == TRANSPARENT) {
+				miocnak(qp, mp, 0, EINVAL);
+				break;
+			}
+
+			/* allocate a response message */
+			dp = allocb(sizeof (ptmptsopencb_t), BPRI_MED);
+			if (dp == NULL) {
+				miocnak(qp, mp, 0, EAGAIN);
+				break;
+			}
+
+			/* initialize the ioctl results */
+			ppocb = (ptmptsopencb_t *)dp->b_rptr;
+			ppocb->ppocb_func = ptmptsopencb;
+			ppocb->ppocb_arg = (ptmptsopencb_arg_t)ptmp;
+
+			/* send the reply data */
+			mioc2ack(mp, dp, sizeof (ptmptsopencb_t), 0);
+			qreply(qp, mp);
+			break;
+		}
 		}
 		break;
 
usr/src/uts/common/io/signalfd.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/io/signalfd.c	Tue Nov 17 16:20:42 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/io/signalfd.c	Mon Dec 14 10:47:45 2015
@@ -123,6 +123,7 @@
 #include <sys/schedctl.h>
 #include <sys/id_space.h>
 #include <sys/sdt.h>
+#include <sys/brand.h>
 
 typedef struct signalfd_state signalfd_state_t;
 
@@ -405,6 +406,9 @@
 	lwp->lwp_extsig = 0;
 	mutex_exit(&p->p_lock);
 
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sigfd_translate)
+		BROP(p)->b_sigfd_translate(infop);
+
 	/* Convert k_siginfo into external, datamodel independent, struct. */
 	bzero(ssp, sizeof (*ssp));
 	ssp->ssi_signo = infop->si_signo;
usr/src/uts/common/io/tty_pty.c
No differences encountered
usr/src/uts/common/io/zfd.c
usr/src/uts/common/netinet/udp.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/netinet/udp.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/netinet/udp.h	Wed Oct 14 16:03:01 2015
@@ -1,6 +1,7 @@
 /*
  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /*
@@ -17,9 +18,6 @@
 #ifndef	_NETINET_UDP_H
 #define	_NETINET_UDP_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-/* udp.h 1.7 88/08/19 SMI; from UCB 7.1 6/5/86	*/
-
 #ifdef	__cplusplus
 extern "C" {
 #endif
@@ -36,7 +34,17 @@
 #define	UDP_EXCLBIND		0x0101		/* for internal use only */
 #define	UDP_RCVHDR		0x0102		/* for internal use only */
 #define	UDP_NAT_T_ENDPOINT	0x0103		/* for internal use only */
+#define	UDP_SRCPORT_HASH	0x0104		/* for internal use only */
+#define	UDP_SND_TO_CONNECTED	0x0105		/* for internal use only */
+
 /*
+ * Hash definitions for UDP_SRCPORT_HASH that effectively tell UDP how to go
+ * handle UDP_SRCPORT_HASH.
+ */
+#define	UDP_HASH_DISABLE	0x0000		/* for internal use only */
+#define	UDP_HASH_VXLAN		0x0001		/* for internal use only */
+
+/*
  * Following option in UDP_ namespace required to be exposed through
  * <xti.h> (It also requires exposing options not implemented). The options
  * with potential for conflicts use #ifndef guards.
usr/src/uts/common/os/brand.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/brand.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/brand.c	Mon Dec 14 10:47:45 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 #include <sys/kmem.h>
@@ -45,7 +46,7 @@
 };
 #else /* !__sparcv9 */
 struct brand_mach_ops native_mach_ops  = {
-		NULL, NULL, NULL, NULL
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 #endif /* !__sparcv9 */
 
@@ -53,7 +54,8 @@
 		BRAND_VER_1,
 		"native",
 		NULL,
-		&native_mach_ops
+		&native_mach_ops,
+		0
 };
 
 /*
@@ -310,46 +312,112 @@
 	mutex_exit(&brand_list_lock);
 }
 
-void
-brand_setbrand(proc_t *p)
+int
+brand_setbrand(proc_t *p, boolean_t lwps_ok)
 {
 	brand_t *bp = p->p_zone->zone_brand;
+	void *brand_data = NULL;
 
-	ASSERT(bp != NULL);
-	ASSERT(p->p_brand == &native_brand);
+	VERIFY(MUTEX_NOT_HELD(&p->p_lock));
+	VERIFY(bp != NULL);
 
 	/*
-	 * We should only be called from exec(), when we know the process
-	 * is single-threaded.
+	 * Process branding occurs during fork() and exec().  When it happens
+	 * during fork(), the LWP count will always be 0 since branding is
+	 * performed as part of getproc(), before LWPs have been associated.
+	 * The same is not true during exec(), where a multi-LWP process may
+	 * undergo branding just prior to gexec(). This is to ensure
+	 * exec-related brand hooks are available.  While it may seem
+	 * complicated to brand a multi-LWP process, the two possible outcomes
+	 * simplify things:
+	 *
+	 * 1. The exec() succeeds:  LWPs besides the caller will be killed and
+	 *    any further branding will occur in a single-LWP context.
+	 * 2. The exec() fails: The process will be promptly unbranded since
+	 *    the hooks are no longer needed.
+	 *
+	 * To prevent inconsistent brand state from being encountered during
+	 * the exec(), LWPs beyond the caller which are associated with this
+	 * process must be held temporarily.  They will be released either when
+	 * they are killed in the exec() success, or when the brand is cleared
+	 * after exec() failure.
 	 */
-	ASSERT(p->p_tlist == p->p_tlist->t_forw);
+	if (lwps_ok) {
+		/*
+		 * We've been called from a exec() context tolerating the
+		 * existence of multiple LWPs during branding is necessary.
+		 */
+		VERIFY(p == curproc);
+		VERIFY(p->p_tlist != NULL);
 
+		if (p->p_tlist != p->p_tlist->t_forw) {
+			/*
+			 * Multiple LWPs are present.  Hold all but the caller.
+			 */
+			if (!holdlwps(SHOLDFORK1)) {
+				return (-1);
+			}
+		}
+	} else {
+		/*
+		 * Processes branded during fork() should not have LWPs at all.
+		 */
+		VERIFY(p->p_tlist == NULL);
+	}
+
+	if (bp->b_data_size > 0) {
+		brand_data = kmem_zalloc(bp->b_data_size, KM_SLEEP);
+	}
+
+	mutex_enter(&p->p_lock);
+	ASSERT(!PROC_IS_BRANDED(p));
 	p->p_brand = bp;
+	p->p_brand_data = brand_data;
 	ASSERT(PROC_IS_BRANDED(p));
 	BROP(p)->b_setbrand(p);
+	mutex_exit(&p->p_lock);
+	return (0);
 }
 
 void
-brand_clearbrand(proc_t *p, boolean_t no_lwps)
+brand_clearbrand(proc_t *p, boolean_t lwps_ok)
 {
 	brand_t *bp = p->p_zone->zone_brand;
-	klwp_t *lwp = NULL;
-	ASSERT(bp != NULL);
-	ASSERT(!no_lwps || (p->p_tlist == NULL));
+	void *brand_data;
 
-	/*
-	 * If called from exec_common() or proc_exit(),
-	 * we know the process is single-threaded.
-	 * If called from fork_fail, p_tlist is NULL.
-	 */
-	if (!no_lwps) {
-		ASSERT(p->p_tlist == p->p_tlist->t_forw);
-		lwp = p->p_tlist->t_lwp;
-	}
+	VERIFY(MUTEX_NOT_HELD(&p->p_lock));
+	VERIFY(bp != NULL);
+	VERIFY(PROC_IS_BRANDED(p));
 
-	ASSERT(PROC_IS_BRANDED(p));
-	BROP(p)->b_proc_exit(p, lwp);
+	mutex_enter(&p->p_lock);
 	p->p_brand = &native_brand;
+	brand_data = p->p_brand_data;
+	p->p_brand_data = NULL;
+
+	if (lwps_ok) {
+		VERIFY(p == curproc);
+		/*
+		 * A process with multiple LWPs is being de-branded after
+		 * failing an exec.  The other LWPs were held as part of the
+		 * procedure, so they must be resumed now.
+		 */
+		if (p->p_tlist != NULL && p->p_tlist != p->p_tlist->t_forw) {
+			continuelwps(p);
+		}
+	} else {
+		/*
+		 * While clearing the brand, it's ok for one LWP to be present.
+		 * This happens when a native binary is executed inside a
+		 * branded zone, since the brand will be removed during the
+		 * course of a successful exec.
+		 */
+		VERIFY(p->p_tlist == NULL || p->p_tlist == p->p_tlist->t_forw);
+	}
+	mutex_exit(&p->p_lock);
+
+	if (brand_data != NULL) {
+		kmem_free(brand_data, bp->b_data_size);
+	}
 }
 
 #if defined(__sparcv9)
@@ -483,7 +551,7 @@
 		return (ENOSYS);
 
 	/* For all other operations this must be a branded process. */
-	if (p->p_brand == &native_brand)
+	if (!PROC_IS_BRANDED(p))
 		return (ENOSYS);
 
 	ASSERT(p->p_brand == pbrand);
@@ -601,8 +669,8 @@
 int
 brand_solaris_elfexec(vnode_t *vp, execa_t *uap, uarg_t *args,
     intpdata_t *idatap, int level, long *execsz, int setid, caddr_t exec_file,
-    cred_t *cred, int brand_action, struct brand *pbrand, char *bname,
-    char *brandlib, char *brandlib32, char *brandlinker, char *brandlinker32)
+    cred_t *cred, int *brand_action, struct brand *pbrand, char *bname,
+    char *brandlib, char *brandlib32)
 {
 
 	vnode_t		*nvp;
@@ -609,7 +677,7 @@
 	Ehdr		ehdr;
 	Addr		uphdr_vaddr;
 	intptr_t	voffset;
-	int		interp;
+	char		*interp;
 	int		i, err;
 	struct execenv	env;
 	struct execenv	origenv;
@@ -619,7 +687,6 @@
 	klwp_t		*lwp = ttolwp(curthread);
 	brand_proc_data_t	*spd;
 	brand_elf_data_t sed, *sedp;
-	char		*linker;
 	uintptr_t	lddata; /* lddata of executable's linker */
 
 	ASSERT(curproc->p_brand == pbrand);
@@ -636,12 +703,10 @@
 	 */
 	if (args->to_model == DATAMODEL_NATIVE) {
 		args->emulator = brandlib;
-		linker = brandlinker;
 	}
 #if defined(_LP64)
 	else {
 		args->emulator = brandlib32;
-		linker = brandlinker32;
 	}
 #endif  /* _LP64 */
 
@@ -672,13 +737,13 @@
 	orig_sigaltstack.ss_flags = lwp->lwp_sigaltstack.ss_flags;
 
 	if (args->to_model == DATAMODEL_NATIVE) {
-		err = elfexec(nvp, uap, args, idatap, level + 1, execsz,
+		err = elfexec(nvp, uap, args, idatap, INTP_MAXDEPTH + 1, execsz,
 		    setid, exec_file, cred, brand_action);
 	}
 #if defined(_LP64)
 	else {
-		err = elf32exec(nvp, uap, args, idatap, level + 1, execsz,
-		    setid, exec_file, cred, brand_action);
+		err = elf32exec(nvp, uap, args, idatap, INTP_MAXDEPTH + 1,
+		    execsz, setid, exec_file, cred, brand_action);
 	}
 #endif  /* _LP64 */
 	VN_RELE(nvp);
@@ -725,7 +790,7 @@
 	if (args->to_model == DATAMODEL_NATIVE) {
 		err = mapexec_brand(vp, args, &ehdr, &uphdr_vaddr,
 		    &voffset, exec_file, &interp, &env.ex_bssbase,
-		    &env.ex_brkbase, &env.ex_brksize, NULL);
+		    &env.ex_brkbase, &env.ex_brksize, NULL, NULL);
 	}
 #if defined(_LP64)
 	else {
@@ -733,7 +798,7 @@
 		Elf32_Addr uphdr_vaddr32;
 		err = mapexec32_brand(vp, args, &ehdr32, &uphdr_vaddr32,
 		    &voffset, exec_file, &interp, &env.ex_bssbase,
-		    &env.ex_brkbase, &env.ex_brksize, NULL);
+		    &env.ex_brkbase, &env.ex_brksize, NULL, NULL);
 		Ehdr32to64(&ehdr32, &ehdr);
 
 		if (uphdr_vaddr32 == (Elf32_Addr)-1)
@@ -744,6 +809,10 @@
 #endif  /* _LP64 */
 	if (err != 0) {
 		restoreexecenv(&origenv, &orig_sigaltstack);
+
+		if (interp != NULL)
+			kmem_free(interp, MAXPATHLEN);
+
 		return (err);
 	}
 
@@ -761,7 +830,7 @@
 	sedp->sed_phent = ehdr.e_phentsize;
 	sedp->sed_phnum = ehdr.e_phnum;
 
-	if (interp) {
+	if (interp != NULL) {
 		if (ehdr.e_type == ET_DYN) {
 			/*
 			 * This is a shared object executable, so we
@@ -777,16 +846,20 @@
 		 * it in and store relevant information about it in the
 		 * aux vector, where the brand library can find it.
 		 */
-		if ((err = lookupname(linker, UIO_SYSSPACE,
+		if ((err = lookupname(interp, UIO_SYSSPACE,
 		    FOLLOW, NULLVPP, &nvp)) != 0) {
-			uprintf("%s: not found.", brandlinker);
+			uprintf("%s: not found.", interp);
 			restoreexecenv(&origenv, &orig_sigaltstack);
+			kmem_free(interp, MAXPATHLEN);
 			return (err);
 		}
+
+		kmem_free(interp, MAXPATHLEN);
+
 		if (args->to_model == DATAMODEL_NATIVE) {
 			err = mapexec_brand(nvp, args, &ehdr,
 			    &uphdr_vaddr, &voffset, exec_file, &interp,
-			    NULL, NULL, NULL, &lddata);
+			    NULL, NULL, NULL, &lddata, NULL);
 		}
 #if defined(_LP64)
 		else {
@@ -794,7 +867,7 @@
 			Elf32_Addr uphdr_vaddr32;
 			err = mapexec32_brand(nvp, args, &ehdr32,
 			    &uphdr_vaddr32, &voffset, exec_file, &interp,
-			    NULL, NULL, NULL, &lddata);
+			    NULL, NULL, NULL, &lddata, NULL);
 			Ehdr32to64(&ehdr32, &ehdr);
 
 			if (uphdr_vaddr32 == (Elf32_Addr)-1)
@@ -934,9 +1007,9 @@
 
 	/*
 	 * Third, the /proc aux vectors set up by elfexec() point to
-	 * brand emulation library and it's linker.  Copy these to the
+	 * brand emulation library and its linker.  Copy these to the
 	 * /proc brand specific aux vector, and update the regular
-	 * /proc aux vectors to point to the executable (and it's
+	 * /proc aux vectors to point to the executable (and its
 	 * linker).  This will enable debuggers to access the
 	 * executable via the usual /proc or elf notes aux vectors.
 	 *
@@ -1078,7 +1151,7 @@
 }
 
 /*ARGSUSED*/
-int
+void
 brand_solaris_initlwp(klwp_t *l, struct brand *pbrand)
 {
 	ASSERT(l->lwp_procp->p_brand == pbrand);
@@ -1085,7 +1158,6 @@
 	ASSERT(l->lwp_procp->p_brand_data != NULL);
 	ASSERT(l->lwp_brand == NULL);
 	l->lwp_brand = (void *)-1;
-	return (0);
 }
 
 /*ARGSUSED*/
@@ -1092,41 +1164,18 @@
 void
 brand_solaris_lwpexit(klwp_t *l, struct brand *pbrand)
 {
-	proc_t  *p = l->lwp_procp;
-
 	ASSERT(l->lwp_procp->p_brand == pbrand);
 	ASSERT(l->lwp_procp->p_brand_data != NULL);
 	ASSERT(l->lwp_brand != NULL);
-
-	/*
-	 * We should never be called for the last thread in a process.
-	 * (That case is handled by brand_solaris_proc_exit().)
-	 * Therefore this lwp must be exiting from a multi-threaded
-	 * process.
-	 */
-	ASSERT(p->p_tlist != p->p_tlist->t_forw);
-
-	l->lwp_brand = NULL;
 }
 
 /*ARGSUSED*/
 void
-brand_solaris_proc_exit(struct proc *p, klwp_t *l, struct brand *pbrand)
+brand_solaris_proc_exit(struct proc *p, struct brand *pbrand)
 {
 	ASSERT(p->p_brand == pbrand);
 	ASSERT(p->p_brand_data != NULL);
 
-	/*
-	 * When called from proc_exit(), we know that process is
-	 * single-threaded and free our lwp brand data.
-	 * otherwise just free p_brand_data and return.
-	 */
-	if (l != NULL) {
-		ASSERT(p->p_tlist == p->p_tlist->t_forw);
-		ASSERT(p->p_tlist->t_lwp == l);
-		(void) brand_solaris_freelwp(l, pbrand);
-	}
-
 	/* upon exit, free our proc brand data */
 	kmem_free(p->p_brand_data, sizeof (brand_proc_data_t));
 	p->p_brand_data = NULL;
@@ -1145,5 +1194,4 @@
 	ASSERT(p->p_tlist == p->p_tlist->t_forw);
 
 	p->p_brand_data = kmem_zalloc(sizeof (brand_proc_data_t), KM_SLEEP);
-	(void) brand_solaris_initlwp(p->p_tlist->t_lwp, pbrand);
 }
usr/src/uts/common/os/exec.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/exec.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/exec.c	Wed Jan  6 14:59:25 2016
@@ -26,7 +26,7 @@
 /*	Copyright (c) 1988 AT&T	*/
 /*	  All Rights Reserved  	*/
 /*
- * Copyright 2014, Joyent, Inc.  All rights reserved.
+ * Copyright 2015, Joyent, Inc.  All rights reserved.
  */
 
 #include <sys/types.h>
@@ -69,6 +69,7 @@
 #include <sys/sdt.h>
 #include <sys/brand.h>
 #include <sys/klpd.h>
+#include <sys/random.h>
 
 #include <c2/audit.h>
 
@@ -97,6 +98,7 @@
 #endif
 
 #define	PSUIDFLAGS		(SNOCD|SUGID)
+#define	RANDOM_LEN	16	/* 16 bytes for AT_RANDOM aux entry */
 
 /*
  * exece() - system call wrapper around exec_common()
@@ -297,14 +299,43 @@
 	ua.argp = argp;
 	ua.envp = envp;
 
-	/* If necessary, brand this process before we start the exec. */
-	if (brandme)
-		brand_setbrand(p);
+	/* If necessary, brand this process/lwp before we start the exec. */
+	if (brandme) {
+		void *brand_data = NULL;
 
+		/*
+		 * Process branding may fail if multiple LWPs are present and
+		 * holdlwps() cannot complete successfully.
+		 */
+		error = brand_setbrand(p, B_TRUE);
+
+		if (error == 0 && BROP(p)->b_lwpdata_alloc != NULL) {
+			brand_data = BROP(p)->b_lwpdata_alloc(p);
+			if (brand_data == NULL) {
+				error = 1;
+			}
+		}
+
+		if (error == 0) {
+			mutex_enter(&p->p_lock);
+			BROP(p)->b_initlwp(lwp, brand_data);
+			mutex_exit(&p->p_lock);
+		} else {
+			VN_RELE(vp);
+			if (dir != NULL) {
+				VN_RELE(dir);
+			}
+			pn_free(&resolvepn);
+			goto fail;
+		}
+	}
+
 	if ((error = gexec(&vp, &ua, &args, NULL, 0, &execsz,
-	    exec_file, p->p_cred, brand_action)) != 0) {
-		if (brandme)
-			brand_clearbrand(p, B_FALSE);
+	    exec_file, p->p_cred, &brand_action)) != 0) {
+		if (brandme) {
+			BROP(p)->b_freelwp(lwp);
+			brand_clearbrand(p, B_TRUE);
+		}
 		VN_RELE(vp);
 		if (dir != NULL)
 			VN_RELE(dir);
@@ -336,7 +367,7 @@
 	/*
 	 * Clear contract template state
 	 */
-	lwp_ctmpl_clear(lwp);
+	lwp_ctmpl_clear(lwp, B_TRUE);
 
 	/*
 	 * Save the directory in which we found the executable for expanding
@@ -360,6 +391,8 @@
 	 * pending held signals remain held, so don't clear t_hold.
 	 */
 	mutex_enter(&p->p_lock);
+	DTRACE_PROBE3(oldcontext__set, klwp_t *, lwp,
+	    uintptr_t, lwp->lwp_oldcontext, uintptr_t, 0);
 	lwp->lwp_oldcontext = 0;
 	lwp->lwp_ustack = 0;
 	lwp->lwp_old_stk_ctl = 0;
@@ -419,8 +452,10 @@
 	TRACE_2(TR_FAC_PROC, TR_PROC_EXEC, "proc_exec:p %p up %p", p, up);
 
 	/* Unbrand ourself if necessary. */
-	if (PROC_IS_BRANDED(p) && (brand_action == EBA_NATIVE))
+	if (PROC_IS_BRANDED(p) && (brand_action == EBA_NATIVE)) {
+		BROP(p)->b_freelwp(lwp);
 		brand_clearbrand(p, B_FALSE);
+	}
 
 	setregs(&args);
 
@@ -544,7 +579,7 @@
 	long *execsz,
 	caddr_t exec_file,
 	struct cred *cred,
-	int brand_action)
+	int *brand_action)
 {
 	struct vnode *vp, *execvp = NULL;
 	proc_t *pp = ttoproc(curthread);
@@ -858,8 +893,14 @@
 			if (pp->p_plist || (pp->p_proc_flag & P_PR_TRACE))
 				args->traceinval = 1;
 		}
-		if (pp->p_proc_flag & P_PR_PTRACE)
+
+		/*
+		 * If legacy ptrace is enabled, generate the SIGTRAP.
+		 */
+		if (pp->p_proc_flag & P_PR_PTRACE) {
 			psignal(pp, SIGTRAP);
+		}
+
 		if (args->traceinval)
 			prinvalidate(&pp->p_user);
 	}
@@ -1517,7 +1558,28 @@
 	return (0);
 }
 
+/*
+ * Add a fixed size byte array to the stack (only from kernel space).
+ */
 static int
+stk_byte_add(uarg_t *args, const uint8_t *sp, size_t len)
+{
+	int error;
+
+	if (STK_AVAIL(args) < sizeof (int))
+		return (E2BIG);
+	*--args->stk_offp = args->stk_strp - args->stk_base;
+
+	if (len > STK_AVAIL(args))
+		return (E2BIG);
+	bcopy(sp, args->stk_strp, len);
+
+	args->stk_strp += len;
+
+	return (0);
+}
+
+static int
 stk_getptr(uarg_t *args, char *src, char **dst)
 {
 	int error;
@@ -1553,16 +1615,30 @@
 	size_t size, pad;
 	char *argv = (char *)uap->argp;
 	char *envp = (char *)uap->envp;
+	uint8_t rdata[RANDOM_LEN];
 
 	/*
 	 * Copy interpreter's name and argument to argv[0] and argv[1].
+	 * In the rare case that we have nested interpreters then those names
+	 * and arguments are also copied to the subsequent slots in argv.
 	 */
-	if (intp != NULL && intp->intp_name != NULL) {
-		if ((error = stk_add(args, intp->intp_name, UIO_SYSSPACE)) != 0)
-			return (error);
-		if (intp->intp_arg != NULL &&
-		    (error = stk_add(args, intp->intp_arg, UIO_SYSSPACE)) != 0)
-			return (error);
+	if (intp != NULL && intp->intp_name[0] != NULL) {
+		int i;
+
+		for (i = 0; i < INTP_MAXDEPTH; i++) {
+			if (intp->intp_name[i] == NULL)
+				break;
+			error = stk_add(args, intp->intp_name[i], UIO_SYSSPACE);
+			if (error != 0)
+				return (error);
+			if (intp->intp_arg[i] != NULL) {
+				error = stk_add(args, intp->intp_arg[i],
+				    UIO_SYSSPACE);
+				if (error != 0)
+					return (error);
+			}
+		}
+
 		if (args->fname != NULL)
 			error = stk_add(args, args->fname, UIO_SYSSPACE);
 		else
@@ -1622,8 +1698,9 @@
 	args->ne = args->na - argc;
 
 	/*
-	 * Add AT_SUN_PLATFORM, AT_SUN_EXECNAME, AT_SUN_BRANDNAME, and
-	 * AT_SUN_EMULATOR strings to the stack.
+	 * Add AT_SUN_PLATFORM, AT_SUN_EXECNAME, AT_SUN_BRANDNAME,
+	 * AT_SUN_BRAND_NROOT, and AT_SUN_EMULATOR strings, as well as AT_RANDOM
+	 * array, to the stack.
 	 */
 	if (auxvpp != NULL && *auxvpp != NULL) {
 		if ((error = stk_add(args, platform, UIO_SYSSPACE)) != 0)
@@ -1636,6 +1713,20 @@
 		if (args->emulator != NULL &&
 		    (error = stk_add(args, args->emulator, UIO_SYSSPACE)) != 0)
 			return (error);
+
+		/*
+		 * For the AT_RANDOM aux vector we provide 16 bytes of random
+		 * data.
+		 */
+		(void) random_get_pseudo_bytes(rdata, sizeof (rdata));
+
+		if ((error = stk_byte_add(args, rdata, sizeof (rdata))) != 0)
+			return (error);
+
+		if (args->brand_nroot != NULL &&
+		    (error = stk_add(args, args->brand_nroot,
+		    UIO_SYSSPACE)) != 0)
+			return (error);
 	}
 
 	/*
@@ -1742,7 +1833,7 @@
 	/*
 	 * Fill in the aux vector now that we know the user stack addresses
 	 * for the AT_SUN_PLATFORM, AT_SUN_EXECNAME, AT_SUN_BRANDNAME and
-	 * AT_SUN_EMULATOR strings.
+	 * AT_SUN_EMULATOR strings, as well as the AT_RANDOM array.
 	 */
 	if (auxvpp != NULL && *auxvpp != NULL) {
 		if (args->to_model == DATAMODEL_NATIVE) {
@@ -1755,6 +1846,11 @@
 			if (args->emulator != NULL)
 				ADDAUX(*a,
 				    AT_SUN_EMULATOR, (long)&ustrp[*--offp])
+			ADDAUX(*a, AT_RANDOM, (long)&ustrp[*--offp])
+			if (args->brand_nroot != NULL) {
+				ADDAUX(*a,
+				    AT_SUN_BRAND_NROOT, (long)&ustrp[*--offp])
+			}
 		} else {
 			auxv32_t **a = (auxv32_t **)auxvpp;
 			ADDAUX(*a,
@@ -1767,6 +1863,11 @@
 			if (args->emulator != NULL)
 				ADDAUX(*a, AT_SUN_EMULATOR,
 				    (int)(uintptr_t)&ustrp[*--offp])
+			ADDAUX(*a, AT_RANDOM, (int)(uintptr_t)&ustrp[*--offp])
+			if (args->brand_nroot != NULL) {
+				ADDAUX(*a, AT_SUN_BRAND_NROOT,
+				    (int)(uintptr_t)&ustrp[*--offp])
+			}
 		}
 	}
 
@@ -1855,6 +1956,9 @@
 		usrstack = (char *)USRSTACK32;
 	}
 
+	if (args->maxstack != 0 && (uintptr_t)usrstack > args->maxstack)
+		usrstack = (char *)args->maxstack;
+
 	ASSERT(P2PHASE((uintptr_t)usrstack, args->stk_align) == 0);
 
 #if defined(__sparc)
usr/src/uts/common/os/exit.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/exit.c	Tue Nov 17 16:20:42 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/exit.c	Wed Oct 14 16:03:01 2015
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2011, Joyent, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc. All rights reserved.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -230,7 +230,7 @@
 		siginfofree(lwp->lwp_curinfo);
 		lwp->lwp_curinfo = NULL;
 	}
-	lwp_ctmpl_clear(lwp);
+	lwp_ctmpl_clear(lwp, B_FALSE);
 
 	/*
 	 * Reset both the process root directory and the current working
@@ -366,20 +366,7 @@
 	}
 	mutex_exit(&p->p_lock);
 
-	DTRACE_PROC(lwp__exit);
-	DTRACE_PROC1(exit, int, why);
-
 	/*
-	 * Will perform any brand specific proc exit processing, since this
-	 * is always the last lwp, will also perform lwp_exit and free brand
-	 * data
-	 */
-	if (PROC_IS_BRANDED(p)) {
-		lwp_detach_brand_hdlrs(lwp);
-		brand_clearbrand(p, B_FALSE);
-	}
-
-	/*
 	 * Don't let init exit unless zone_start_init() failed its exec, or
 	 * we are shutting down the zone or the machine.
 	 *
@@ -390,12 +377,35 @@
 		if (z->zone_boot_err == 0 &&
 		    zone_status_get(z) < ZONE_IS_SHUTTING_DOWN &&
 		    zone_status_get(global_zone) < ZONE_IS_SHUTTING_DOWN) {
-			if (z->zone_restart_init == B_TRUE) {
-				if (restart_init(what, why) == 0)
-					return (0);
+
+			/*
+			 * If the init process should be restarted, the
+			 * "zone_restart_init" member will be set.  Some init
+			 * programs in branded zones do not tolerate a restart
+			 * in the traditional manner; setting the
+			 * "zone_reboot_on_init_exit" member will cause the
+			 * entire zone to be rebooted instead.  If neither of
+			 * these flags is set the zone will shut down.
+			 */
+			if (z->zone_reboot_on_init_exit == B_TRUE &&
+			    z->zone_restart_init == B_TRUE) {
+				/*
+				 * Trigger a zone reboot and continue
+				 * with exit processing.
+				 */
+				z->zone_init_status = wstat(why, what);
+				(void) zone_kadmin(A_REBOOT, 0, NULL,
+				    zone_kcred());
+
 			} else {
+				if (z->zone_restart_init == B_TRUE) {
+					if (restart_init(what, why) == 0)
+						return (0);
+				}
+
+				z->zone_init_status = wstat(why, what);
 				(void) zone_kadmin(A_SHUTDOWN, AD_HALT, NULL,
-				    CRED());
+				    zone_kcred());
 			}
 		}
 
@@ -407,6 +417,32 @@
 		z->zone_proc_initpid = -1;
 	}
 
+	/*
+	 * Delay firing probes (and performing brand cleanup) until after the
+	 * zone_proc_initpid check. Cases which result in zone shutdown or
+	 * restart via zone_kadmin eventually result in a call back to
+	 * proc_exit.
+	 */
+	DTRACE_PROC(lwp__exit);
+	DTRACE_PROC1(exit, int, why);
+
+	/*
+	 * Will perform any brand specific proc exit processing. Since this
+	 * is always the last lwp, will also perform lwp exit/free and proc
+	 * exit. Brand data will be freed when the process is reaped.
+	 */
+	if (PROC_IS_BRANDED(p)) {
+		BROP(p)->b_lwpexit(lwp);
+		BROP(p)->b_proc_exit(p);
+		/*
+		 * To ensure that b_proc_exit has access to brand-specific data
+		 * contained by the one remaining lwp, call the freelwp hook as
+		 * the last part of this clean-up process.
+		 */
+		BROP(p)->b_freelwp(lwp);
+		lwp_detach_brand_hdlrs(lwp);
+	}
+
 	lwp_pcb_exit();
 
 	/*
@@ -658,11 +694,23 @@
 	if ((q = p->p_child) != NULL && p != proc_init) {
 		struct proc	*np;
 		struct proc	*initp = proc_init;
+		pid_t		zone_initpid = 1;
+		struct proc	*zoneinitp = NULL;
 		boolean_t	setzonetop = B_FALSE;
 
-		if (!INGLOBALZONE(curproc))
-			setzonetop = B_TRUE;
+		if (!INGLOBALZONE(curproc)) {
+			zone_initpid = curproc->p_zone->zone_proc_initpid;
 
+			ASSERT(MUTEX_HELD(&pidlock));
+			zoneinitp = prfind(zone_initpid);
+			if (zoneinitp != NULL) {
+				initp = zoneinitp;
+			} else {
+				zone_initpid = 1;
+				setzonetop = B_TRUE;
+			}
+		}
+
 		pgdetach(p);
 
 		do {
@@ -673,7 +721,8 @@
 			 */
 			delete_ns(q->p_parent, q);
 
-			q->p_ppid = 1;
+			q->p_ppid = zone_initpid;
+
 			q->p_pidflag &= ~(CLDNOSIGCHLD | CLDWAITPID);
 			if (setzonetop) {
 				mutex_enter(&q->p_lock);
@@ -847,8 +896,50 @@
 
 	mutex_exit(&p->p_lock);
 	if (!evaporate) {
-		p->p_pidflag &= ~CLDPEND;
-		sigcld(p, sqp);
+		/*
+		 * The brand specific code only happens when the brand has a
+		 * function to call in place of sigcld and the parent of the
+		 * exiting process is not the global zone init. If the parent
+		 * is the global zone init, then the process was reparented,
+		 * and we don't want brand code delivering possibly strange
+		 * signals to init. Also, init is not branded, so any brand
+		 * specific exit data will not be picked up by init anyway.
+		 */
+		if (PROC_IS_BRANDED(p) &&
+		    BROP(p)->b_exit_with_sig != NULL &&
+		    p->p_ppid != 1) {
+			/*
+			 * The code for _fini that could unload the brand_t
+			 * blocks until the count of zones using the module
+			 * reaches zero. Zones decrement the refcount on their
+			 * brands only after all user tasks in that zone have
+			 * exited and been waited on. The decrement on the
+			 * brand's refcount happen in zone_destroy(). That
+			 * depends on zone_shutdown() having been completed.
+			 * zone_shutdown() includes a call to zone_empty(),
+			 * where the zone waits for itself to reach the state
+			 * ZONE_IS_EMPTY. This state is only set in either
+			 * zone_shutdown(), when there are no user processes as
+			 * the zone enters this function, or in
+			 * zone_task_rele(). zone_task_rele() is called from
+			 * code triggered by waiting on processes, not by the
+			 * processes exiting through proc_exit().  This means
+			 * all the branded processes that could exist for a
+			 * specific brand_t must exit and get reaped before the
+			 * refcount on the brand_t can reach 0. _fini will
+			 * never unload the corresponding brand module before
+			 * proc_exit finishes execution for all processes
+			 * branded with a particular brand_t, which makes the
+			 * operation below safe to do. Brands that wish to use
+			 * this mechanism must wait in _fini as described
+			 * above.
+			 */
+			BROP(p)->b_exit_with_sig(p, sqp);
+		} else {
+			p->p_pidflag &= ~CLDPEND;
+			sigcld(p, sqp);
+		}
+
 	} else {
 		/*
 		 * Do what sigcld() would do if the disposition
@@ -927,10 +1018,9 @@
 int
 waitid(idtype_t idtype, id_t id, k_siginfo_t *ip, int options)
 {
-	int found;
 	proc_t *cp, *pp;
-	int proc_gone;
 	int waitflag = !(options & WNOWAIT);
+	boolean_t have_brand_helper = B_FALSE;
 
 	/*
 	 * Obsolete flag, defined here only for binary compatibility
@@ -958,7 +1048,8 @@
 	pp = ttoproc(curthread);
 
 	/*
-	 * lock parent mutex so that sibling chain can be searched.
+	 * Anytime you are looking for a process, you take pidlock to prevent
+	 * things from changing as you look.
 	 */
 	mutex_enter(&pidlock);
 
@@ -978,10 +1069,37 @@
 		return (ECHILD);
 	}
 
-	while (pp->p_child != NULL) {
+	if (PROC_IS_BRANDED(pp) && BROP(pp)->b_waitid_helper != NULL) {
+		have_brand_helper = B_TRUE;
+	}
 
-		proc_gone = 0;
+	while (pp->p_child != NULL || have_brand_helper) {
+		boolean_t brand_wants_wait = B_FALSE;
+		int proc_gone = 0;
+		int found = 0;
 
+		/*
+		 * Give the brand a chance to return synthetic results from
+		 * this waitid() call before we do the real thing.
+		 */
+		if (have_brand_helper) {
+			int ret;
+
+			if (BROP(pp)->b_waitid_helper(idtype, id, ip, options,
+			    &brand_wants_wait, &ret) == 0) {
+				mutex_exit(&pidlock);
+				return (ret);
+			}
+
+			if (pp->p_child == NULL) {
+				goto no_real_children;
+			}
+		}
+
+		/*
+		 * Look for interesting children in the newstate list.
+		 */
+		VERIFY(pp->p_child != NULL);
 		for (cp = pp->p_child_ns; cp != NULL; cp = cp->p_sibling_ns) {
 			if (idtype != P_PID && (cp->p_pidflag & CLDWAITPID))
 				continue;
@@ -989,6 +1107,11 @@
 				continue;
 			if (idtype == P_PGID && id != cp->p_pgrp)
 				continue;
+			if (PROC_IS_BRANDED(pp)) {
+				if (BROP(pp)->b_wait_filter != NULL &&
+				    BROP(pp)->b_wait_filter(pp, cp) == B_FALSE)
+					continue;
+			}
 
 			switch (cp->p_wcode) {
 
@@ -1033,12 +1156,16 @@
 		 * Wow! None of the threads on the p_sibling_ns list were
 		 * interesting threads. Check all the kids!
 		 */
-		found = 0;
 		for (cp = pp->p_child; cp != NULL; cp = cp->p_sibling) {
 			if (idtype == P_PID && id != cp->p_pid)
 				continue;
 			if (idtype == P_PGID && id != cp->p_pgrp)
 				continue;
+			if (PROC_IS_BRANDED(pp)) {
+				if (BROP(pp)->b_wait_filter != NULL &&
+				    BROP(pp)->b_wait_filter(pp, cp) == B_FALSE)
+					continue;
+			}
 
 			switch (cp->p_wcode) {
 			case CLD_TRAPPED:
@@ -1107,11 +1234,12 @@
 				break;
 		}
 
+no_real_children:
 		/*
 		 * If we found no interesting processes at all,
 		 * break out and return ECHILD.
 		 */
-		if (found + proc_gone == 0)
+		if (!brand_wants_wait && (found + proc_gone == 0))
 			break;
 
 		if (options & WNOHANG) {
@@ -1130,7 +1258,7 @@
 		 * change state while we wait, we don't wait at all.
 		 * Get out with ECHILD according to SVID.
 		 */
-		if (found == proc_gone)
+		if (!brand_wants_wait && (found == proc_gone))
 			break;
 
 		if (!cv_wait_sig_swap(&pp->p_cv, &pidlock)) {
@@ -1226,6 +1354,12 @@
 		p->p_killsqp = NULL;
 	}
 
+	/* Clear any remaining brand data */
+	if (PROC_IS_BRANDED(p)) {
+		brand_clearbrand(p, B_FALSE);
+	}
+
+
 	prfree(p);	/* inform /proc */
 
 	/*
usr/src/uts/common/os/fork.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/fork.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/fork.c	Wed Jan  6 14:59:25 2016
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -696,7 +696,7 @@
 	if (PTOU(curproc)->u_cwd)
 		refstr_rele(PTOU(curproc)->u_cwd);
 	if (PROC_IS_BRANDED(cp)) {
-		brand_clearbrand(cp, B_TRUE);
+		brand_clearbrand(cp, B_FALSE);
 	}
 }
 
@@ -745,7 +745,7 @@
 			kmem_free(t->t_door, sizeof (door_data_t));
 			t->t_door = NULL;
 		}
-		lwp_ctmpl_clear(ttolwp(t));
+		lwp_ctmpl_clear(ttolwp(t), B_FALSE);
 
 		/*
 		 * Remove the thread from the all threads list.
@@ -1004,6 +1004,9 @@
 	cp->p_t1_lgrpid = LGRP_NONE;
 	cp->p_tr_lgrpid = LGRP_NONE;
 
+	/* Default to native brand initially */
+	cp->p_brand = &native_brand;
+
 	if ((newpid = pid_allocate(cp, pid, PID_ALLOC_PROC)) == -1) {
 		if (nproc == v.v_proc) {
 			CPU_STATS_ADDQ(CPU, sys, procovf, 1);
@@ -1071,9 +1074,6 @@
 	cp->p_flag = pp->p_flag & (SJCTL|SNOWAIT|SNOCD);
 	cp->p_sessp = pp->p_sessp;
 	sess_hold(pp);
-	cp->p_brand = pp->p_brand;
-	if (PROC_IS_BRANDED(pp))
-		BROP(pp)->b_copy_procdata(cp, pp);
 	cp->p_bssbase = pp->p_bssbase;
 	cp->p_brkbase = pp->p_brkbase;
 	cp->p_brksize = pp->p_brksize;
@@ -1153,6 +1153,18 @@
 	mutex_exit(&cp->p_lock);
 	mutex_exit(&pidlock);
 
+	if (PROC_IS_BRANDED(pp)) {
+		/*
+		 * The only reason why process branding should fail is when
+		 * the procedure is complicated by multiple LWPs on the scene.
+		 * With an LWP count of 0, this newly allocated process has no
+		 * reason to fail branding.
+		 */
+		VERIFY0(brand_setbrand(cp, B_FALSE));
+
+		BROP(pp)->b_copy_procdata(cp, pp);
+	}
+
 	avl_create(&cp->p_ct_held, contract_compar, sizeof (contract_t),
 	    offsetof(contract_t, ct_ctlist));
 
usr/src/uts/common/os/grow.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/grow.c	Tue Jan  5 17:20:21 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/grow.c	Wed Jun 17 17:43:43 2015
@@ -19,7 +19,10 @@
  * CDDL HEADER END
  */
 
-/* Copyright 2013 OmniTI Computer Consulting, Inc. All rights reserved. */
+/*
+ * Copyright 2013 OmniTI Computer Consulting, Inc. All rights reserved.
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ */
 
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
@@ -52,6 +55,7 @@
 #include <sys/fcntl.h>
 #include <sys/lwpchan_impl.h>
 #include <sys/nbmlock.h>
+#include <sys/brand.h>
 
 #include <vm/hat.h>
 #include <vm/as.h>
@@ -499,30 +503,10 @@
 choose_addr(struct as *as, caddr_t *addrp, size_t len, offset_t off,
     int vacalign, uint_t flags)
 {
-#if defined(__amd64)
-	proc_t *p = curproc;
-#endif
 	caddr_t basep = (caddr_t)(uintptr_t)((uintptr_t)*addrp & PAGEMASK);
-	size_t lenp;
+	size_t lenp = len;
 
 	ASSERT(AS_ISCLAIMGAP(as));	/* searches should be serialized */
-
-	/*
-	 * If we have been provided a hint, we should still expand the lenp
-	 * to be the rest of the address space.  This will allow us to
-	 * treat the hint as a strong desire to be "nearby" the provided
-	 * address.  If we can't satisfy the hint, as_gap() will walk forward.
-	 */
-	if (flags & _MAP_LOW32)
-		lenp = (caddr_t)USERLIMIT32 - basep;
-#if defined(__amd64)
-	else if (p->p_model == DATAMODEL_NATIVE)
-		lenp = p->p_usrstack - basep -
-		    ((p->p_stk_ctl + PAGEOFFSET) & PAGEMASK);
-#endif
-	else
-		lenp = as->a_userlimit - basep;
-
 	if (flags & MAP_FIXED) {
 		(void) as_unmap(as, *addrp, len);
 		return (0);
@@ -542,7 +526,21 @@
 	return (0);
 }
 
+caddr_t
+map_userlimit(proc_t *pp, struct as *as, int flags)
+{
+	if (flags & _MAP_LOW32) {
+		if (PROC_IS_BRANDED(pp) && BROP(pp)->b_map32limit != NULL) {
+			return ((caddr_t)(uintptr_t)BROP(pp)->b_map32limit(pp));
+		} else {
+			return ((caddr_t)_userlimit32);
+		}
+	}
 
+	return (as->a_userlimit);
+}
+
+
 /*
  * Used for MAP_ANON - fast way to get anonymous pages
  */
@@ -557,8 +555,6 @@
 		return (EACCES);
 
 	if ((flags & MAP_FIXED) != 0) {
-		caddr_t userlimit;
-
 		/*
 		 * Use the user address.  First verify that
 		 * the address to be used is page aligned.
@@ -567,9 +563,8 @@
 		if (((uintptr_t)*addrp & PAGEOFFSET) != 0)
 			return (EINVAL);
 
-		userlimit = flags & _MAP_LOW32 ?
-		    (caddr_t)USERLIMIT32 : as->a_userlimit;
-		switch (valid_usr_range(*addrp, len, uprot, as, userlimit)) {
+		switch (valid_usr_range(*addrp, len, uprot, as,
+		    map_userlimit(as->a_proc, as, flags))) {
 		case RANGE_OKAY:
 			break;
 		case RANGE_BADPROT:
@@ -737,8 +732,6 @@
 	 * If the user specified an address, do some simple checks here
 	 */
 	if ((flags & MAP_FIXED) != 0) {
-		caddr_t userlimit;
-
 		/*
 		 * Use the user address.  First verify that
 		 * the address to be used is page aligned.
@@ -746,10 +739,8 @@
 		 */
 		if (((uintptr_t)*addrp & PAGEOFFSET) != 0)
 			return (EINVAL);
-
-		userlimit = flags & _MAP_LOW32 ?
-		    (caddr_t)USERLIMIT32 : as->a_userlimit;
-		switch (valid_usr_range(*addrp, len, uprot, as, userlimit)) {
+		switch (valid_usr_range(*addrp, len, uprot, as,
+		    map_userlimit(curproc, as, flags))) {
 		case RANGE_OKAY:
 			break;
 		case RANGE_BADPROT:
usr/src/uts/common/os/lwp.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/lwp.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/lwp.c	Mon Dec 14 10:47:45 2015
@@ -25,7 +25,7 @@
  */
 
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #include <sys/param.h>
@@ -57,6 +57,8 @@
 #include <sys/lgrp.h>
 #include <sys/rctl.h>
 #include <sys/contract_impl.h>
+#include <sys/contract/process.h>
+#include <sys/contract/process_impl.h>
 #include <sys/cpc_impl.h>
 #include <sys/sdt.h>
 #include <sys/cmn_err.h>
@@ -115,7 +117,7 @@
 	ret_tidhash_t *ret_tidhash = NULL;
 	int i;
 	int rctlfail = 0;
-	boolean_t branded = 0;
+	void *brand_data = NULL;
 	struct ctxop *ctx = NULL;
 
 	ASSERT(cid != sysdccid);	/* system threads must start in SYS */
@@ -283,6 +285,19 @@
 	 */
 	lep = kmem_zalloc(sizeof (*lep), KM_SLEEP);
 
+	/*
+	 * If necessary, speculatively allocate lwp brand data.  This is done
+	 * ahead of time so p_lock need not be dropped during lwp branding.
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_lwpdata_alloc != NULL) {
+		if ((brand_data = BROP(p)->b_lwpdata_alloc(p)) == NULL) {
+			mutex_enter(&p->p_lock);
+			err = 1;
+			atomic_inc_32(&p->p_zone->zone_ffmisc);
+			goto error;
+		}
+	}
+
 	mutex_enter(&p->p_lock);
 grow:
 	/*
@@ -630,18 +645,6 @@
 		} while (lwp_hash_lookup(p, t->t_tid) != NULL);
 	}
 
-	/*
-	 * If this is a branded process, let the brand do any necessary lwp
-	 * initialization.
-	 */
-	if (PROC_IS_BRANDED(p)) {
-		if (BROP(p)->b_initlwp(lwp)) {
-			err = 1;
-			atomic_inc_32(&p->p_zone->zone_ffmisc);
-			goto error;
-		}
-		branded = 1;
-	}
 
 	if (t->t_tid == 1) {
 		kpreempt_disable();
@@ -654,7 +657,6 @@
 		}
 	}
 
-	p->p_lwpcnt++;
 	t->t_waitfor = -1;
 
 	/*
@@ -696,8 +698,27 @@
 	t->t_post_sys = 1;
 
 	/*
+	 * Perform lwp branding
+	 *
+	 * The b_initlwp hook is _not_ allowed to drop p->p_lock as it must be
+	 * continuously held between when the tidhash is sized and when the lwp
+	 * is inserted into it.  Operations requiring p->p_lock to be
+	 * temporarily dropped can be performed in b_initlwp_post.
+	 */
+	if (PROC_IS_BRANDED(p)) {
+		BROP(p)->b_initlwp(lwp, brand_data);
+		/*
+		 * The b_initlwp hook is expected to consume any preallocated
+		 * brand_data in a way that prepares it for deallocation by the
+		 * b_freelwp hook.
+		 */
+		brand_data = NULL;
+	}
+
+	/*
 	 * Insert the new thread into the list of all threads.
 	 */
+	p->p_lwpcnt++;
 	if ((tx = p->p_tlist) == NULL) {
 		t->t_back = t;
 		t->t_forw = t;
@@ -718,6 +739,13 @@
 	lep->le_start = t->t_start;
 	lwp_hash_in(p, lep, p->p_tidhash, p->p_tidhash_sz, 1);
 
+	/*
+	 * Complete lwp branding
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_initlwp_post != NULL) {
+		BROP(p)->b_initlwp_post(lwp);
+	}
+
 	if (state == TS_RUN) {
 		/*
 		 * We set the new lwp running immediately.
@@ -753,8 +781,9 @@
 		if (cid != NOCLASS && bufp != NULL)
 			CL_FREE(cid, bufp);
 
-		if (branded)
-			BROP(p)->b_freelwp(lwp);
+		if (brand_data != NULL) {
+			BROP(p)->b_lwpdata_free(brand_data);
+		}
 
 		mutex_exit(&p->p_lock);
 		t->t_state = TS_FREE;
@@ -827,8 +856,25 @@
 	int i;
 
 	for (i = 0; i < ct_ntypes; i++) {
-		dst->lwp_ct_active[i] = ctmpl_dup(src->lwp_ct_active[i]);
+		ct_template_t *tmpl = src->lwp_ct_active[i];
+
+		/*
+		 * If the process contract template is setup to be preserved
+		 * across exec, then perform an implicit template_clear now
+		 * since we're forking. This ensures that future children of
+		 * this child will remain in the same contract unless they're
+		 * explicitly setup differently.
+		 */
+		if (i == CTT_PROCESS && tmpl != NULL) {
+			ctmpl_process_t *ctp = tmpl->ctmpl_data;
+
+			if ((ctp->ctp_params & CT_PR_KEEP_EXEC) != 0)
+				tmpl = NULL;
+		}
+
+		dst->lwp_ct_active[i] = ctmpl_dup(tmpl);
 		dst->lwp_ct_latest[i] = NULL;
+
 	}
 }
 
@@ -836,21 +882,33 @@
  * Clear an LWP's contract template state.
  */
 void
-lwp_ctmpl_clear(klwp_t *lwp)
+lwp_ctmpl_clear(klwp_t *lwp, boolean_t is_exec)
 {
 	ct_template_t *tmpl;
 	int i;
 
 	for (i = 0; i < ct_ntypes; i++) {
-		if ((tmpl = lwp->lwp_ct_active[i]) != NULL) {
-			ctmpl_free(tmpl);
-			lwp->lwp_ct_active[i] = NULL;
-		}
-
 		if (lwp->lwp_ct_latest[i] != NULL) {
 			contract_rele(lwp->lwp_ct_latest[i]);
 			lwp->lwp_ct_latest[i] = NULL;
 		}
+
+		if ((tmpl = lwp->lwp_ct_active[i]) != NULL) {
+			/*
+			 * If we're exec-ing a new program and the process
+			 * contract template is setup to be preserved across
+			 * exec, then don't clear it.
+			 */
+			if (is_exec && i == CTT_PROCESS) {
+				ctmpl_process_t *ctp = tmpl->ctmpl_data;
+
+				if ((ctp->ctp_params & CT_PR_KEEP_EXEC) != 0)
+					continue;
+			}
+
+			ctmpl_free(tmpl);
+			lwp->lwp_ct_active[i] = NULL;
+		}
 	}
 }
 
@@ -891,13 +949,6 @@
 	if (t->t_upimutex != NULL)
 		upimutex_cleanup();
 
-	/*
-	 * Perform any brand specific exit processing, then release any
-	 * brand data associated with the lwp
-	 */
-	if (PROC_IS_BRANDED(p))
-		BROP(p)->b_lwpexit(lwp);
-
 	lwp_pcb_exit();
 
 	mutex_enter(&p->p_lock);
@@ -941,6 +992,18 @@
 	DTRACE_PROC(lwp__exit);
 
 	/*
+	 * Perform any brand specific exit processing, then release any
+	 * brand data associated with the lwp
+	 */
+	if (PROC_IS_BRANDED(p)) {
+		mutex_exit(&p->p_lock);
+		BROP(p)->b_lwpexit(lwp);
+		BROP(p)->b_freelwp(lwp);
+		mutex_enter(&p->p_lock);
+		prbarrier(p);
+	}
+
+	/*
 	 * If the lwp is a detached lwp or if the process is exiting,
 	 * remove (lwp_hash_out()) the lwp from the lwp directory.
 	 * Otherwise null out the lwp's le_thread pointer in the lwp
@@ -1101,7 +1164,7 @@
 	}
 	kpreempt_enable();
 
-	lwp_ctmpl_clear(ttolwp(t));
+	lwp_ctmpl_clear(ttolwp(t), B_FALSE);
 }
 
 int
usr/src/uts/common/os/pid.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/pid.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/pid.c	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -112,6 +113,18 @@
 	return (pidp);
 }
 
+struct pid *
+pid_find(pid_t pid)
+{
+	struct pid *pidp;
+
+	mutex_enter(&pidlinklock);
+	pidp = pid_lookup(pid);
+	mutex_exit(&pidlinklock);
+
+	return (pidp);
+}
+
 void
 pid_setmin(void)
 {
@@ -521,6 +534,20 @@
 	mutex_exit(&p->p_lock);
 	THREAD_KPRI_RELEASE();
 }
+
+/*
+ * Undo effects of sprlock but without dropping p->p_lock
+ */
+void
+sprunprlock(proc_t *p)
+{
+	ASSERT(p->p_proc_flag & P_PR_LOCK);
+	ASSERT(MUTEX_HELD(&p->p_lock));
+
+	cv_signal(&pr_pid_cv[p->p_slot]);
+	p->p_proc_flag &= ~P_PR_LOCK;
+	THREAD_KPRI_RELEASE();
+}
 
 void
 pid_init(void)
usr/src/uts/common/os/policy.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/policy.c	Thu Nov  5 11:10:04 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/policy.c	Wed Jun 17 17:43:43 2015
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -55,6 +55,7 @@
 #include <sys/mntent.h>
 #include <sys/contract_impl.h>
 #include <sys/dld_ioc.h>
+#include <sys/brand.h>
 
 /*
  * There are two possible layers of privilege routines and two possible
@@ -1243,6 +1244,22 @@
 void
 secpolicy_setid_clear(vattr_t *vap, cred_t *cr)
 {
+	proc_t *p = curproc;
+
+	/*
+	 * Allow the brand to override this behaviour.
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_setid_clear != NULL) {
+		/*
+		 * This brand hook will return 0 if handling is complete, or
+		 * some other value if the brand would like us to fall back to
+		 * the usual behaviour.
+		 */
+		if (BROP(p)->b_setid_clear(vap, cr) == 0) {
+			return;
+		}
+	}
+
 	if ((vap->va_mode & (S_ISUID | S_ISGID)) != 0 &&
 	    secpolicy_vnode_setid_retain(cr,
 	    (vap->va_mode & S_ISUID) != 0 &&
@@ -2078,6 +2095,13 @@
 }
 
 int
+secpolicy_fs_import(const cred_t *cr)
+{
+	return (PRIV_POLICY(cr, PRIV_SYS_FS_IMPORT, B_FALSE, EPERM, NULL));
+}
+
+
+int
 secpolicy_pfexec_register(const cred_t *cr)
 {
 	return (PRIV_POLICY(cr, PRIV_SYS_ADMIN, B_TRUE, EPERM, NULL));
@@ -2580,4 +2604,12 @@
 	if (PRIV_POLICY_ONLY(cr, PRIV_SYS_NET_CONFIG, B_FALSE))
 		return (secpolicy_net_config(cr, B_FALSE));
 	return (PRIV_POLICY(cr, PRIV_SYS_PPP_CONFIG, B_FALSE, EPERM, NULL));
+}
+
+int
+secpolicy_hyprlofs_control(const cred_t *cr)
+{
+	if (PRIV_POLICY(cr, PRIV_HYPRLOFS_CONTROL, B_FALSE, EPERM, NULL))
+		return (EPERM);
+	return (0);
 }
usr/src/uts/common/os/sig.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/sig.c	Tue Nov 17 16:20:42 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/sig.c	Wed Aug 19 10:40:34 2015
@@ -22,7 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
- * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -60,6 +60,7 @@
 #include <sys/cyclic.h>
 #include <sys/dtrace.h>
 #include <sys/sdt.h>
+#include <sys/brand.h>
 #include <sys/signalfd.h>
 
 const k_sigset_t nullsmask = {0, 0, 0};
@@ -148,6 +149,21 @@
 }
 
 /*
+ * Return true if the signal can safely be ignored.
+ * That is, if the signal is included in the p_ignore mask and doing so is not
+ * forbidden by any process branding.
+ */
+static int
+sig_ignorable(proc_t *p, klwp_t *lwp, int sig)
+{
+	return (sigismember(&p->p_ignore, sig) &&	/* sig in ignore mask */
+	    !(PROC_IS_BRANDED(p) &&			/* allowed by brand */
+	    BROP(p)->b_sig_ignorable != NULL &&
+	    BROP(p)->b_sig_ignorable(p, lwp, sig) == B_FALSE));
+
+}
+
+/*
  * Return true if the signal can safely be discarded on generation.
  * That is, if there is no need for the signal on the receiving end.
  * The answer is true if the process is a zombie or
@@ -159,12 +175,13 @@
  *	the signal is not being accepted via sigwait()
  */
 static int
-sig_discardable(proc_t *p, int sig)
+sig_discardable(proc_t *p, kthread_t *tp, int sig)
 {
 	kthread_t *t = p->p_tlist;
+	klwp_t *lwp = (tp == NULL) ? NULL : tp->t_lwp;
 
 	return (t == NULL ||		/* if zombie or ... */
-	    (sigismember(&p->p_ignore, sig) &&	/* signal is ignored */
+	    (sig_ignorable(p, lwp, sig) &&		/* signal is ignored */
 	    t->t_forw == t &&			/* and single-threaded */
 	    !tracing(p, sig) &&			/* and no /proc tracing */
 	    !signal_is_blocked(t, sig) &&	/* and signal not blocked */
@@ -200,7 +217,7 @@
 		    !(ttoproc(t)->p_proc_flag & P_PR_LOCK)) {
 			ttoproc(t)->p_stopsig = 0;
 			t->t_dtrace_stop = 0;
-			t->t_schedflag |= TS_XSTART | TS_PSTART;
+			t->t_schedflag |= TS_XSTART | TS_PSTART | TS_BSTART;
 			setrun_locked(t);
 		} else if (t != curthread && t->t_state == TS_ONPROC) {
 			aston(t);	/* make it do issig promptly */
@@ -297,7 +314,7 @@
 		}
 	}
 
-	if (sig_discardable(p, sig)) {
+	if (sig_discardable(p, t, sig)) {
 		DTRACE_PROC3(signal__discard, kthread_t *, p->p_tlist,
 		    proc_t *, p, int, sig);
 		return;
@@ -497,7 +514,7 @@
 			if (sigismember(&set, sig) &&
 			    (tracing(p, sig) ||
 			    sigismember(&t->t_sigwait, sig) ||
-			    !sigismember(&p->p_ignore, sig))) {
+			    !sig_ignorable(p, lwp, sig))) {
 				/*
 				 * Don't promote a signal that will stop
 				 * the process when lwp_nostop is set.
@@ -623,6 +640,21 @@
 		}
 
 		/*
+		 * Allow the brand the chance to alter (or suppress) delivery
+		 * of this signal.
+		 */
+		if (PROC_IS_BRANDED(p) && BROP(p)->b_issig_stop != NULL) {
+			/*
+			 * The brand hook will return 0 if it would like
+			 * us to drive on, or -1 if we should restart
+			 * the loop to check other conditions.
+			 */
+			if (BROP(p)->b_issig_stop(p, lwp) != 0) {
+				continue;
+			}
+		}
+
+		/*
 		 * Honor requested stop before dealing with the
 		 * current signal; a debugger may change it.
 		 * Do not want to go back to loop here since this is a special
@@ -656,7 +688,7 @@
 			lwp->lwp_cursig = 0;
 			lwp->lwp_extsig = 0;
 			if (sigismember(&t->t_sigwait, sig) ||
-			    (!sigismember(&p->p_ignore, sig) &&
+			    (!sig_ignorable(p, lwp, sig) &&
 			    !isjobstop(sig))) {
 				if (p->p_flag & (SEXITLWPS|SKILLED)) {
 					sig = SIGKILL;
@@ -708,7 +740,7 @@
 				toproc = 0;
 				if (tracing(p, sig) ||
 				    sigismember(&t->t_sigwait, sig) ||
-				    !sigismember(&p->p_ignore, sig)) {
+				    !sig_ignorable(p, lwp, sig)) {
 					if (sigismember(&t->t_extsig, sig))
 						ext = 1;
 					break;
@@ -722,7 +754,7 @@
 				toproc = 1;
 				if (tracing(p, sig) ||
 				    sigismember(&t->t_sigwait, sig) ||
-				    !sigismember(&p->p_ignore, sig)) {
+				    !sig_ignorable(p, lwp, sig)) {
 					if (sigismember(&p->p_extsig, sig))
 						ext = 1;
 					break;
@@ -954,6 +986,16 @@
 		}
 		break;
 
+	case PR_BRAND:
+		/*
+		 * We have been stopped by the brand code for a brand-private
+		 * reason.  This is an asynchronous stop affecting only this
+		 * LWP.
+		 */
+		VERIFY(PROC_IS_BRANDED(p));
+		flags &= ~TS_BSTART;
+		break;
+
 	default:	/* /proc stop */
 		flags &= ~TS_PSTART;
 		/*
@@ -1065,7 +1107,7 @@
 		}
 	}
 
-	if (why != PR_JOBCONTROL && why != PR_CHECKPOINT) {
+	if (why != PR_JOBCONTROL && why != PR_CHECKPOINT && why != PR_BRAND) {
 		/*
 		 * Do process-level notification when all lwps are
 		 * either stopped on events of interest to /proc
@@ -1171,6 +1213,13 @@
 	if (why == PR_CHECKPOINT)
 		del_one_utstop();
 
+	/*
+	 * Allow the brand to post notification of this stop condition.
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_stop_notify != NULL) {
+		BROP(p)->b_stop_notify(p, lwp, why, what);
+	}
+
 	thread_lock(t);
 	ASSERT((t->t_schedflag & TS_ALLSTART) == 0);
 	t->t_schedflag |= flags;
@@ -1192,7 +1241,7 @@
 		    (p->p_flag & (SEXITLWPS|SKILLED))) {
 			p->p_stopsig = 0;
 			thread_lock(t);
-			t->t_schedflag |= TS_XSTART | TS_PSTART;
+			t->t_schedflag |= TS_XSTART | TS_PSTART | TS_BSTART;
 			setrun_locked(t);
 			thread_unlock_nopreempt(t);
 		} else if (why == PR_JOBCONTROL) {
@@ -1327,7 +1376,7 @@
 	 * this signal from pending to current (we dropped p->p_lock).
 	 * This can happen only in a multi-threaded process.
 	 */
-	if (sigismember(&p->p_ignore, sig) ||
+	if (sig_ignorable(p, lwp, sig) ||
 	    (func == SIG_DFL && sigismember(&stopdefault, sig))) {
 		lwp->lwp_cursig = 0;
 		lwp->lwp_extsig = 0;
@@ -1771,9 +1820,12 @@
 			/*
 			 * This can only happen when the parent is init.
 			 * (See call to sigcld(q, NULL) in exit().)
-			 * Use KM_NOSLEEP to avoid deadlock.
+			 * Use KM_NOSLEEP to avoid deadlock. The child procs
+			 * initpid can be 1 for zlogin.
 			 */
-			ASSERT(pp == proc_init);
+			ASSERT(pp->p_pidp->pid_id ==
+			    cp->p_zone->zone_proc_initpid ||
+			    pp->p_pidp->pid_id == 1);
 			winfo(cp, &info, 0);
 			sigaddq(pp, NULL, &info, KM_NOSLEEP);
 		} else {
@@ -1804,6 +1856,15 @@
 
 	sqp = kmem_zalloc(sizeof (sigqueue_t), KM_SLEEP);
 	mutex_enter(&pidlock);
+	if (PROC_IS_BRANDED(pp) && BROP(pp)->b_sigcld_repost != NULL) {
+		/*
+		 * Allow the brand to inject synthetic SIGCLD signals.
+		 */
+		if (BROP(pp)->b_sigcld_repost(pp, sqp) == 0) {
+			mutex_exit(&pidlock);
+			return;
+		}
+	}
 	for (cp = pp->p_child; cp; cp = cp->p_sibling) {
 		if (cp->p_pidflag & CLDPEND) {
 			post_sigcld(cp, sqp);
@@ -2115,7 +2176,7 @@
 	ASSERT(MUTEX_HELD(&p->p_lock));
 	ASSERT(sig >= 1 && sig < NSIG);
 
-	if (sig_discardable(p, sig))
+	if (sig_discardable(p, t, sig))
 		siginfofree(sigqp);
 	else
 		sigaddqins(p, t, sigqp);
@@ -2141,7 +2202,7 @@
 	 * blocking the signal (it *could* change it's mind while
 	 * the signal is pending) then don't bother creating one.
 	 */
-	if (!sig_discardable(p, sig) &&
+	if (!sig_discardable(p, t, sig) &&
 	    (sigismember(&p->p_siginfo, sig) ||
 	    (curproc->p_ct_process != p->p_ct_process) ||
 	    (sig == SIGCLD && SI_FROMKERNEL(infop))) &&
usr/src/uts/common/os/streamio.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/streamio.c	Mon Oct 19 10:48:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/streamio.c	Wed Oct 14 16:03:01 2015
@@ -24,7 +24,7 @@
 
 /*
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ * Copyright 2015, Joyent, Inc. All rights reserved.
  */
 
 #include <sys/types.h>
@@ -77,6 +77,7 @@
 #include <sys/policy.h>
 #include <sys/dld.h>
 #include <sys/zone.h>
+#include <sys/limits.h>
 #include <c2/audit.h>
 
 /*
@@ -985,12 +986,20 @@
 		 * (registered in sd_wakeq).
 		 */
 		struiod_t uiod;
+		struct iovec buf[IOV_MAX_STACK];
+		int iovlen = 0;
 
 		if (first)
 			stp->sd_wakeq &= ~RSLEEP;
 
-		(void) uiodup(uiop, &uiod.d_uio, uiod.d_iov,
-		    sizeof (uiod.d_iov) / sizeof (*uiod.d_iov));
+		if (uiop->uio_iovcnt > IOV_MAX_STACK) {
+			iovlen = uiop->uio_iovcnt * sizeof (iovec_t);
+			uiod.d_iov = kmem_alloc(iovlen, KM_SLEEP);
+		} else {
+			uiod.d_iov = buf;
+		}
+
+		(void) uiodup(uiop, &uiod.d_uio, uiod.d_iov, uiop->uio_iovcnt);
 		uiod.d_mp = 0;
 		/*
 		 * Mark that a thread is in rwnext on the read side
@@ -1029,6 +1038,8 @@
 			if ((bp = uiod.d_mp) != NULL) {
 				*errorp = 0;
 				ASSERT(MUTEX_HELD(&stp->sd_lock));
+				if (iovlen != 0)
+					kmem_free(uiod.d_iov, iovlen);
 				return (bp);
 			}
 			error = 0;
@@ -1048,8 +1059,14 @@
 		} else {
 			*errorp = error;
 			ASSERT(MUTEX_HELD(&stp->sd_lock));
+			if (iovlen != 0)
+				kmem_free(uiod.d_iov, iovlen);
 			return (NULL);
 		}
+
+		if (iovlen != 0)
+			kmem_free(uiod.d_iov, iovlen);
+
 		/*
 		 * Try a getq in case a rwnext() generated mblk
 		 * has bubbled up via strrput().
@@ -2544,6 +2561,8 @@
     int b_flag, int pri, int flags)
 {
 	struiod_t uiod;
+	struct iovec buf[IOV_MAX_STACK];
+	int iovlen = 0;
 	mblk_t *mp;
 	queue_t *wqp = stp->sd_wrq;
 	int error = 0;
@@ -2635,13 +2654,21 @@
 	mp->b_flag |= b_flag;
 	mp->b_band = (uchar_t)pri;
 
-	(void) uiodup(uiop, &uiod.d_uio, uiod.d_iov,
-	    sizeof (uiod.d_iov) / sizeof (*uiod.d_iov));
+	if (uiop->uio_iovcnt > IOV_MAX_STACK) {
+		iovlen = uiop->uio_iovcnt * sizeof (iovec_t);
+		uiod.d_iov = (struct iovec *)kmem_alloc(iovlen, KM_SLEEP);
+	} else {
+		uiod.d_iov = buf;
+	}
+
+	(void) uiodup(uiop, &uiod.d_uio, uiod.d_iov, uiop->uio_iovcnt);
 	uiod.d_uio.uio_offset = 0;
 	uiod.d_mp = mp;
 	error = rwnext(wqp, &uiod);
 	if (! uiod.d_mp) {
 		uioskip(uiop, *iosize);
+		if (iovlen != 0)
+			kmem_free(uiod.d_iov, iovlen);
 		return (error);
 	}
 	ASSERT(mp == uiod.d_mp);
@@ -2659,6 +2686,8 @@
 		error = 0;
 	} else {
 		freemsg(mp);
+		if (iovlen != 0)
+			kmem_free(uiod.d_iov, iovlen);
 		return (error);
 	}
 	/* Have to check canput before consuming data from the uio */
@@ -2665,11 +2694,15 @@
 	if (pri == 0) {
 		if (!canputnext(wqp) && !(flags & MSG_IGNFLOW)) {
 			freemsg(mp);
+			if (iovlen != 0)
+				kmem_free(uiod.d_iov, iovlen);
 			return (EWOULDBLOCK);
 		}
 	} else {
 		if (!bcanputnext(wqp, pri) && !(flags & MSG_IGNFLOW)) {
 			freemsg(mp);
+			if (iovlen != 0)
+				kmem_free(uiod.d_iov, iovlen);
 			return (EWOULDBLOCK);
 		}
 	}
@@ -2677,6 +2710,8 @@
 	/* Copyin data from the uio */
 	if ((error = struioget(wqp, mp, &uiod, 0)) != 0) {
 		freemsg(mp);
+		if (iovlen != 0)
+			kmem_free(uiod.d_iov, iovlen);
 		return (error);
 	}
 	uioskip(uiop, *iosize);
@@ -2693,6 +2728,8 @@
 		putnext(wqp, mp);
 		stream_runservice(stp);
 	}
+	if (iovlen != 0)
+		kmem_free(uiod.d_iov, iovlen);
 	return (0);
 }
 
@@ -3178,6 +3215,7 @@
 	case JAGENT:	/* Obsolete */
 	case JTRUN:	/* Obsolete */
 	case JXTPROTO:	/* Obsolete */
+	case TIOCSETLD:
 		return (JCSETP);
 	}
 
usr/src/uts/common/os/sysent.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/sysent.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/sysent.c	Wed Jun 17 17:43:43 2015
@@ -1093,18 +1093,20 @@
 
 systrace_sysent_t *systrace_sysent;
 void (*systrace_probe)(dtrace_id_t, uintptr_t, uintptr_t,
-    uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+    uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
 
 /*ARGSUSED*/
 void
 systrace_stub(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
-    uintptr_t arg2, uintptr_t arg3, uintptr_t arg4, uintptr_t arg5)
+    uintptr_t arg2, uintptr_t arg3, uintptr_t arg4, uintptr_t arg5,
+    uintptr_t arg6, uintptr_t arg7)
 {}
 
 /*ARGSUSED*/
 int64_t
 dtrace_systrace_syscall(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
-    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5)
+    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6,
+    uintptr_t arg7)
 {
 	systrace_sysent_t *sy = &systrace_sysent[curthread->t_sysnum];
 	dtrace_id_t id;
@@ -1112,7 +1114,8 @@
 	proc_t *p;
 
 	if ((id = sy->stsy_entry) != DTRACE_IDNONE)
-		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5);
+		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5,
+		    arg6, arg7);
 
 	/*
 	 * We want to explicitly allow DTrace consumers to stop a process
@@ -1126,7 +1129,8 @@
 	}
 	mutex_exit(&p->p_lock);
 
-	rval = (*sy->stsy_underlying)(arg0, arg1, arg2, arg3, arg4, arg5);
+	rval = (*sy->stsy_underlying)(arg0, arg1, arg2, arg3, arg4, arg5,
+	    arg6, arg7);
 
 	if (ttolwp(curthread)->lwp_errno != 0)
 		rval = -1;
@@ -1133,7 +1137,7 @@
 
 	if ((id = sy->stsy_return) != DTRACE_IDNONE)
 		(*systrace_probe)(id, (uintptr_t)rval, (uintptr_t)rval,
-		    (uintptr_t)((int64_t)rval >> 32), 0, 0, 0);
+		    (uintptr_t)((int64_t)rval >> 32), 0, 0, 0, 0, 0);
 
 	return (rval);
 }
@@ -1145,7 +1149,8 @@
 /*ARGSUSED*/
 int64_t
 dtrace_systrace_syscall32(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
-    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5)
+    uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6,
+    uintptr_t arg7)
 {
 	systrace_sysent_t *sy = &systrace_sysent32[curthread->t_sysnum];
 	dtrace_id_t id;
@@ -1153,7 +1158,8 @@
 	proc_t *p;
 
 	if ((id = sy->stsy_entry) != DTRACE_IDNONE)
-		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5);
+		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5, arg6,
+		    arg7);
 
 	/*
 	 * We want to explicitly allow DTrace consumers to stop a process
@@ -1167,7 +1173,8 @@
 	}
 	mutex_exit(&p->p_lock);
 
-	rval = (*sy->stsy_underlying)(arg0, arg1, arg2, arg3, arg4, arg5);
+	rval = (*sy->stsy_underlying)(arg0, arg1, arg2, arg3, arg4, arg5, arg6,
+	    arg7);
 
 	if (ttolwp(curthread)->lwp_errno != 0)
 		rval = -1;
@@ -1174,7 +1181,7 @@
 
 	if ((id = sy->stsy_return) != DTRACE_IDNONE)
 		(*systrace_probe)(id, (uintptr_t)rval, (uintptr_t)rval,
-		    (uintptr_t)((uint64_t)rval >> 32), 0, 0, 0);
+		    (uintptr_t)((uint64_t)rval >> 32), 0, 0, 0, 0, 0);
 
 	return (rval);
 }
@@ -1202,5 +1209,5 @@
 	}
 
 	if ((id = sy->stsy_return) != DTRACE_IDNONE)
-		(*systrace_probe)(id, 0, 0, 0, 0, 0, 0);
+		(*systrace_probe)(id, 0, 0, 0, 0, 0, 0, 0, 0);
 }
usr/src/uts/common/os/zone.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/os/zone.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/os/zone.c	Wed Jan  6 14:59:25 2016
@@ -21,7 +21,7 @@
 
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2013, Joyent Inc. All rights reserved.
+ * Copyright 2015, Joyent Inc. All rights reserved.
  */
 
 /*
@@ -250,6 +250,8 @@
 #include <sys/cpucaps.h>
 #include <vm/seg.h>
 #include <sys/mac.h>
+#include <sys/rt.h>
+#include <sys/fx.h>
 
 /*
  * This constant specifies the number of seconds that threads waiting for
@@ -370,8 +372,11 @@
 rctl_hndl_t rc_zone_cpu_shares;
 rctl_hndl_t rc_zone_locked_mem;
 rctl_hndl_t rc_zone_max_swap;
+rctl_hndl_t rc_zone_phys_mem;
 rctl_hndl_t rc_zone_max_lofi;
 rctl_hndl_t rc_zone_cpu_cap;
+rctl_hndl_t rc_zone_cpu_baseline;
+rctl_hndl_t rc_zone_cpu_burst_time;
 rctl_hndl_t rc_zone_zfs_io_pri;
 rctl_hndl_t rc_zone_nlwps;
 rctl_hndl_t rc_zone_nprocs;
@@ -418,8 +423,9 @@
  * Version 5 alters the zone_boot system call, and converts its old
  *     bootargs parameter to be set by the zone_setattr API instead.
  * Version 6 adds the flag argument to zone_create.
+ * Version 7 adds the requested zoneid to zone_create.
  */
-static const int ZONE_SYSCALL_API_VERSION = 6;
+static const int ZONE_SYSCALL_API_VERSION = 7;
 
 /*
  * Certain filesystems (such as NFS and autofs) need to know which zone
@@ -1376,7 +1382,77 @@
 	rcop_no_test
 };
 
+/*ARGSUSED*/
+static rctl_qty_t
+zone_cpu_base_get(rctl_t *rctl, struct proc *p)
+{
+	ASSERT(MUTEX_HELD(&p->p_lock));
+	return (cpucaps_zone_get_base(p->p_zone));
+}
+
 /*
+ * The zone cpu base is used to set the baseline CPU for the zone
+ * so we can track when the zone is bursting.
+ */
+/*ARGSUSED*/
+static int
+zone_cpu_base_set(rctl_t *rctl, struct proc *p, rctl_entity_p_t *e,
+    rctl_qty_t nv)
+{
+	zone_t *zone = e->rcep_p.zone;
+
+	ASSERT(MUTEX_HELD(&p->p_lock));
+	ASSERT(e->rcep_t == RCENTITY_ZONE);
+
+	if (zone == NULL)
+		return (0);
+
+	return (cpucaps_zone_set_base(zone, nv));
+}
+
+static rctl_ops_t zone_cpu_base_ops = {
+	rcop_no_action,
+	zone_cpu_base_get,
+	zone_cpu_base_set,
+	rcop_no_test
+};
+
+/*ARGSUSED*/
+static rctl_qty_t
+zone_cpu_burst_time_get(rctl_t *rctl, struct proc *p)
+{
+	ASSERT(MUTEX_HELD(&p->p_lock));
+	return (cpucaps_zone_get_burst_time(p->p_zone));
+}
+
+/*
+ * The zone cpu burst time is used to set the amount of time CPU(s) can be
+ * bursting for the zone.
+ */
+/*ARGSUSED*/
+static int
+zone_cpu_burst_time_set(rctl_t *rctl, struct proc *p, rctl_entity_p_t *e,
+    rctl_qty_t nv)
+{
+	zone_t *zone = e->rcep_p.zone;
+
+	ASSERT(MUTEX_HELD(&p->p_lock));
+	ASSERT(e->rcep_t == RCENTITY_ZONE);
+
+	if (zone == NULL)
+		return (0);
+
+	return (cpucaps_zone_set_burst_time(zone, nv));
+}
+
+static rctl_ops_t zone_cpu_burst_time_ops = {
+	rcop_no_action,
+	zone_cpu_burst_time_get,
+	zone_cpu_burst_time_set,
+	rcop_no_test
+};
+
+/*
  * zone.zfs-io-pri resource control support (IO priority).
  */
 /*ARGSUSED*/
@@ -1710,6 +1786,39 @@
 
 /*ARGSUSED*/
 static rctl_qty_t
+zone_phys_mem_usage(rctl_t *rctl, struct proc *p)
+{
+	rctl_qty_t q;
+	zone_t *z = p->p_zone;
+
+	ASSERT(MUTEX_HELD(&p->p_lock));
+	/* No additional lock because not enforced in the kernel */
+	q = z->zone_phys_mem;
+	return (q);
+}
+
+/*ARGSUSED*/
+static int
+zone_phys_mem_set(rctl_t *rctl, struct proc *p, rctl_entity_p_t *e,
+    rctl_qty_t nv)
+{
+	ASSERT(MUTEX_HELD(&p->p_lock));
+	ASSERT(e->rcep_t == RCENTITY_ZONE);
+	if (e->rcep_p.zone == NULL)
+		return (0);
+	e->rcep_p.zone->zone_phys_mem_ctl = nv;
+	return (0);
+}
+
+static rctl_ops_t zone_phys_mem_ops = {
+	rcop_no_action,
+	zone_phys_mem_usage,
+	zone_phys_mem_set,
+	rcop_no_test
+};
+
+/*ARGSUSED*/
+static rctl_qty_t
 zone_max_lofi_usage(rctl_t *rctl, struct proc *p)
 {
 	rctl_qty_t q;
@@ -1803,6 +1912,20 @@
 }
 
 static int
+zone_physmem_kstat_update(kstat_t *ksp, int rw)
+{
+	zone_t *zone = ksp->ks_private;
+	zone_kstat_t *zk = ksp->ks_data;
+
+	if (rw == KSTAT_WRITE)
+		return (EACCES);
+
+	zk->zk_usage.value.ui64 = zone->zone_phys_mem;
+	zk->zk_value.value.ui64 = zone->zone_phys_mem_ctl;
+	return (0);
+}
+
+static int
 zone_nprocs_kstat_update(kstat_t *ksp, int rw)
 {
 	zone_t *zone = ksp->ks_private;
@@ -1831,7 +1954,7 @@
 }
 
 static kstat_t *
-zone_kstat_create_common(zone_t *zone, char *name,
+zone_rctl_kstat_create_common(zone_t *zone, char *name,
     int (*updatefunc) (kstat_t *, int))
 {
 	kstat_t *ksp;
@@ -1857,6 +1980,230 @@
 }
 
 static int
+zone_vfs_kstat_update(kstat_t *ksp, int rw)
+{
+	zone_t *zone = ksp->ks_private;
+	zone_vfs_kstat_t *zvp = ksp->ks_data;
+	kstat_io_t *kiop = &zone->zone_vfs_rwstats;
+
+	if (rw == KSTAT_WRITE)
+		return (EACCES);
+
+	/*
+	 * Extract the VFS statistics from the kstat_io_t structure used by
+	 * kstat_runq_enter() and related functions.  Since the slow ops
+	 * counters are updated directly by the VFS layer, there's no need to
+	 * copy those statistics here.
+	 *
+	 * Note that kstat_runq_enter() and the related functions use
+	 * gethrtime_unscaled(), so scale the time here.
+	 */
+	zvp->zv_nread.value.ui64 = kiop->nread;
+	zvp->zv_reads.value.ui64 = kiop->reads;
+	zvp->zv_rtime.value.ui64 = kiop->rtime;
+	zvp->zv_rlentime.value.ui64 = kiop->rlentime;
+	zvp->zv_nwritten.value.ui64 = kiop->nwritten;
+	zvp->zv_writes.value.ui64 = kiop->writes;
+	zvp->zv_wtime.value.ui64 = kiop->wtime;
+	zvp->zv_wlentime.value.ui64 = kiop->wlentime;
+
+	scalehrtime((hrtime_t *)&zvp->zv_rtime.value.ui64);
+	scalehrtime((hrtime_t *)&zvp->zv_rlentime.value.ui64);
+	scalehrtime((hrtime_t *)&zvp->zv_wtime.value.ui64);
+	scalehrtime((hrtime_t *)&zvp->zv_wlentime.value.ui64);
+
+	return (0);
+}
+
+static kstat_t *
+zone_vfs_kstat_create(zone_t *zone)
+{
+	kstat_t *ksp;
+	zone_vfs_kstat_t *zvp;
+
+	if ((ksp = kstat_create_zone("zone_vfs", zone->zone_id,
+	    zone->zone_name, "zone_vfs", KSTAT_TYPE_NAMED,
+	    sizeof (zone_vfs_kstat_t) / sizeof (kstat_named_t),
+	    KSTAT_FLAG_VIRTUAL, zone->zone_id)) == NULL)
+		return (NULL);
+
+	if (zone->zone_id != GLOBAL_ZONEID)
+		kstat_zone_add(ksp, GLOBAL_ZONEID);
+
+	zvp = ksp->ks_data = kmem_zalloc(sizeof (zone_vfs_kstat_t), KM_SLEEP);
+	ksp->ks_data_size += strlen(zone->zone_name) + 1;
+	ksp->ks_lock = &zone->zone_vfs_lock;
+	zone->zone_vfs_stats = zvp;
+
+	/* The kstat "name" field is not large enough for a full zonename */
+	kstat_named_init(&zvp->zv_zonename, "zonename", KSTAT_DATA_STRING);
+	kstat_named_setstr(&zvp->zv_zonename, zone->zone_name);
+	kstat_named_init(&zvp->zv_nread, "nread", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_reads, "reads", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_rtime, "rtime", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_rlentime, "rlentime", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_nwritten, "nwritten", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_writes, "writes", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_wtime, "wtime", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_wlentime, "wlentime", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_10ms_ops, "10ms_ops", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_100ms_ops, "100ms_ops", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_1s_ops, "1s_ops", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_10s_ops, "10s_ops", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_delay_cnt, "delay_cnt", KSTAT_DATA_UINT64);
+	kstat_named_init(&zvp->zv_delay_time, "delay_time", KSTAT_DATA_UINT64);
+
+	ksp->ks_update = zone_vfs_kstat_update;
+	ksp->ks_private = zone;
+
+	kstat_install(ksp);
+	return (ksp);
+}
+
+static int
+zone_zfs_kstat_update(kstat_t *ksp, int rw)
+{
+	zone_t *zone = ksp->ks_private;
+	zone_zfs_kstat_t *zzp = ksp->ks_data;
+	kstat_io_t *kiop = &zone->zone_zfs_rwstats;
+
+	if (rw == KSTAT_WRITE)
+		return (EACCES);
+
+	/*
+	 * Extract the ZFS statistics from the kstat_io_t structure used by
+	 * kstat_runq_enter() and related functions.  Since the I/O throttle
+	 * counters are updated directly by the ZFS layer, there's no need to
+	 * copy those statistics here.
+	 *
+	 * Note that kstat_runq_enter() and the related functions use
+	 * gethrtime_unscaled(), so scale the time here.
+	 */
+	zzp->zz_nread.value.ui64 = kiop->nread;
+	zzp->zz_reads.value.ui64 = kiop->reads;
+	zzp->zz_rtime.value.ui64 = kiop->rtime;
+	zzp->zz_rlentime.value.ui64 = kiop->rlentime;
+	zzp->zz_nwritten.value.ui64 = kiop->nwritten;
+	zzp->zz_writes.value.ui64 = kiop->writes;
+
+	scalehrtime((hrtime_t *)&zzp->zz_rtime.value.ui64);
+	scalehrtime((hrtime_t *)&zzp->zz_rlentime.value.ui64);
+
+	return (0);
+}
+
+static kstat_t *
+zone_zfs_kstat_create(zone_t *zone)
+{
+	kstat_t *ksp;
+	zone_zfs_kstat_t *zzp;
+
+	if ((ksp = kstat_create_zone("zone_zfs", zone->zone_id,
+	    zone->zone_name, "zone_zfs", KSTAT_TYPE_NAMED,
+	    sizeof (zone_zfs_kstat_t) / sizeof (kstat_named_t),
+	    KSTAT_FLAG_VIRTUAL, zone->zone_id)) == NULL)
+		return (NULL);
+
+	if (zone->zone_id != GLOBAL_ZONEID)
+		kstat_zone_add(ksp, GLOBAL_ZONEID);
+
+	zzp = ksp->ks_data = kmem_zalloc(sizeof (zone_zfs_kstat_t), KM_SLEEP);
+	ksp->ks_data_size += strlen(zone->zone_name) + 1;
+	ksp->ks_lock = &zone->zone_zfs_lock;
+	zone->zone_zfs_stats = zzp;
+
+	/* The kstat "name" field is not large enough for a full zonename */
+	kstat_named_init(&zzp->zz_zonename, "zonename", KSTAT_DATA_STRING);
+	kstat_named_setstr(&zzp->zz_zonename, zone->zone_name);
+	kstat_named_init(&zzp->zz_nread, "nread", KSTAT_DATA_UINT64);
+	kstat_named_init(&zzp->zz_reads, "reads", KSTAT_DATA_UINT64);
+	kstat_named_init(&zzp->zz_rtime, "rtime", KSTAT_DATA_UINT64);
+	kstat_named_init(&zzp->zz_rlentime, "rlentime", KSTAT_DATA_UINT64);
+	kstat_named_init(&zzp->zz_nwritten, "nwritten", KSTAT_DATA_UINT64);
+	kstat_named_init(&zzp->zz_writes, "writes", KSTAT_DATA_UINT64);
+	kstat_named_init(&zzp->zz_waittime, "waittime", KSTAT_DATA_UINT64);
+
+	ksp->ks_update = zone_zfs_kstat_update;
+	ksp->ks_private = zone;
+
+	kstat_install(ksp);
+	return (ksp);
+}
+
+static int
+zone_mcap_kstat_update(kstat_t *ksp, int rw)
+{
+	zone_t *zone = ksp->ks_private;
+	zone_mcap_kstat_t *zmp = ksp->ks_data;
+
+	if (rw == KSTAT_WRITE)
+		return (EACCES);
+
+	zmp->zm_rss.value.ui64 = zone->zone_phys_mem;
+	zmp->zm_phys_cap.value.ui64 = zone->zone_phys_mem_ctl;
+	zmp->zm_swap.value.ui64 = zone->zone_max_swap;
+	zmp->zm_swap_cap.value.ui64 = zone->zone_max_swap_ctl;
+	zmp->zm_nover.value.ui64 = zone->zone_mcap_nover;
+	zmp->zm_pagedout.value.ui64 = zone->zone_mcap_pagedout;
+	zmp->zm_pgpgin.value.ui64 = zone->zone_pgpgin;
+	zmp->zm_anonpgin.value.ui64 = zone->zone_anonpgin;
+	zmp->zm_execpgin.value.ui64 = zone->zone_execpgin;
+	zmp->zm_fspgin.value.ui64 = zone->zone_fspgin;
+	zmp->zm_anon_alloc_fail.value.ui64 = zone->zone_anon_alloc_fail;
+	zmp->zm_pf_throttle.value.ui64 = zone->zone_pf_throttle;
+	zmp->zm_pf_throttle_usec.value.ui64 = zone->zone_pf_throttle_usec;
+
+	return (0);
+}
+
+static kstat_t *
+zone_mcap_kstat_create(zone_t *zone)
+{
+	kstat_t *ksp;
+	zone_mcap_kstat_t *zmp;
+
+	if ((ksp = kstat_create_zone("memory_cap", zone->zone_id,
+	    zone->zone_name, "zone_memory_cap", KSTAT_TYPE_NAMED,
+	    sizeof (zone_mcap_kstat_t) / sizeof (kstat_named_t),
+	    KSTAT_FLAG_VIRTUAL, zone->zone_id)) == NULL)
+		return (NULL);
+
+	if (zone->zone_id != GLOBAL_ZONEID)
+		kstat_zone_add(ksp, GLOBAL_ZONEID);
+
+	zmp = ksp->ks_data = kmem_zalloc(sizeof (zone_mcap_kstat_t), KM_SLEEP);
+	ksp->ks_data_size += strlen(zone->zone_name) + 1;
+	ksp->ks_lock = &zone->zone_mcap_lock;
+	zone->zone_mcap_stats = zmp;
+
+	/* The kstat "name" field is not large enough for a full zonename */
+	kstat_named_init(&zmp->zm_zonename, "zonename", KSTAT_DATA_STRING);
+	kstat_named_setstr(&zmp->zm_zonename, zone->zone_name);
+	kstat_named_init(&zmp->zm_rss, "rss", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_phys_cap, "physcap", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_swap, "swap", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_swap_cap, "swapcap", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_nover, "nover", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_pagedout, "pagedout", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_pgpgin, "pgpgin", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_anonpgin, "anonpgin", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_execpgin, "execpgin", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_fspgin, "fspgin", KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_anon_alloc_fail, "anon_alloc_fail",
+	    KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_pf_throttle, "n_pf_throttle",
+	    KSTAT_DATA_UINT64);
+	kstat_named_init(&zmp->zm_pf_throttle_usec, "n_pf_throttle_usec",
+	    KSTAT_DATA_UINT64);
+
+	ksp->ks_update = zone_mcap_kstat_update;
+	ksp->ks_private = zone;
+
+	kstat_install(ksp);
+	return (ksp);
+}
+
+static int
 zone_misc_kstat_update(kstat_t *ksp, int rw)
 {
 	zone_t *zone = ksp->ks_private;
@@ -1885,6 +2232,11 @@
 	zmp->zm_ffnomem.value.ui32 = zone->zone_ffnomem;
 	zmp->zm_ffmisc.value.ui32 = zone->zone_ffmisc;
 
+	zmp->zm_nested_intp.value.ui32 = zone->zone_nested_intp;
+
+	zmp->zm_init_pid.value.ui32 = zone->zone_proc_initpid;
+	zmp->zm_boot_time.value.ui64 = (uint64_t)zone->zone_boot_time;
+
 	return (0);
 }
 
@@ -1923,8 +2275,11 @@
 	    KSTAT_DATA_UINT32);
 	kstat_named_init(&zmp->zm_ffnomem, "forkfail_nomem", KSTAT_DATA_UINT32);
 	kstat_named_init(&zmp->zm_ffmisc, "forkfail_misc", KSTAT_DATA_UINT32);
+	kstat_named_init(&zmp->zm_nested_intp, "nested_interp",
+	    KSTAT_DATA_UINT32);
+	kstat_named_init(&zmp->zm_init_pid, "init_pid", KSTAT_DATA_UINT32);
+	kstat_named_init(&zmp->zm_boot_time, "boot_time", KSTAT_DATA_UINT64);
 
-
 	ksp->ks_update = zone_misc_kstat_update;
 	ksp->ks_private = zone;
 
@@ -1935,13 +2290,30 @@
 static void
 zone_kstat_create(zone_t *zone)
 {
-	zone->zone_lockedmem_kstat = zone_kstat_create_common(zone,
+	zone->zone_lockedmem_kstat = zone_rctl_kstat_create_common(zone,
 	    "lockedmem", zone_lockedmem_kstat_update);
-	zone->zone_swapresv_kstat = zone_kstat_create_common(zone,
+	zone->zone_swapresv_kstat = zone_rctl_kstat_create_common(zone,
 	    "swapresv", zone_swapresv_kstat_update);
-	zone->zone_nprocs_kstat = zone_kstat_create_common(zone,
+	zone->zone_physmem_kstat = zone_rctl_kstat_create_common(zone,
+	    "physicalmem", zone_physmem_kstat_update);
+	zone->zone_nprocs_kstat = zone_rctl_kstat_create_common(zone,
 	    "nprocs", zone_nprocs_kstat_update);
 
+	if ((zone->zone_vfs_ksp = zone_vfs_kstat_create(zone)) == NULL) {
+		zone->zone_vfs_stats = kmem_zalloc(
+		    sizeof (zone_vfs_kstat_t), KM_SLEEP);
+	}
+
+	if ((zone->zone_zfs_ksp = zone_zfs_kstat_create(zone)) == NULL) {
+		zone->zone_zfs_stats = kmem_zalloc(
+		    sizeof (zone_zfs_kstat_t), KM_SLEEP);
+	}
+
+	if ((zone->zone_mcap_ksp = zone_mcap_kstat_create(zone)) == NULL) {
+		zone->zone_mcap_stats = kmem_zalloc(
+		    sizeof (zone_mcap_kstat_t), KM_SLEEP);
+	}
+
 	if ((zone->zone_misc_ksp = zone_misc_kstat_create(zone)) == NULL) {
 		zone->zone_misc_stats = kmem_zalloc(
 		    sizeof (zone_misc_kstat_t), KM_SLEEP);
@@ -1968,8 +2340,17 @@
 	    sizeof (zone_kstat_t));
 	zone_kstat_delete_common(&zone->zone_swapresv_kstat,
 	    sizeof (zone_kstat_t));
+	zone_kstat_delete_common(&zone->zone_physmem_kstat,
+	    sizeof (zone_kstat_t));
 	zone_kstat_delete_common(&zone->zone_nprocs_kstat,
 	    sizeof (zone_kstat_t));
+
+	zone_kstat_delete_common(&zone->zone_vfs_ksp,
+	    sizeof (zone_vfs_kstat_t));
+	zone_kstat_delete_common(&zone->zone_zfs_ksp,
+	    sizeof (zone_zfs_kstat_t));
+	zone_kstat_delete_common(&zone->zone_mcap_ksp,
+	    sizeof (zone_mcap_kstat_t));
 	zone_kstat_delete_common(&zone->zone_misc_ksp,
 	    sizeof (zone_misc_kstat_t));
 }
@@ -2005,6 +2386,8 @@
 	zone0.zone_locked_mem_ctl = UINT64_MAX;
 	ASSERT(zone0.zone_max_swap == 0);
 	zone0.zone_max_swap_ctl = UINT64_MAX;
+	zone0.zone_phys_mem = 0;
+	zone0.zone_phys_mem_ctl = UINT64_MAX;
 	zone0.zone_max_lofi = 0;
 	zone0.zone_max_lofi_ctl = UINT64_MAX;
 	zone0.zone_shmmax = 0;
@@ -2028,9 +2411,9 @@
 	zone0.zone_initname = initname;
 	zone0.zone_lockedmem_kstat = NULL;
 	zone0.zone_swapresv_kstat = NULL;
+	zone0.zone_physmem_kstat = NULL;
 	zone0.zone_nprocs_kstat = NULL;
 	zone0.zone_zfs_io_pri = 1;
-
 	zone0.zone_stime = 0;
 	zone0.zone_utime = 0;
 	zone0.zone_wtime = 0;
@@ -2141,10 +2524,20 @@
 	    RCTL_GLOBAL_INFINITE,
 	    MAXCAP, MAXCAP, &zone_cpu_cap_ops);
 
+	rc_zone_cpu_baseline = rctl_register("zone.cpu-baseline",
+	    RCENTITY_ZONE, RCTL_GLOBAL_SIGNAL_NEVER | RCTL_GLOBAL_DENY_NEVER |
+	    RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_COUNT | RCTL_GLOBAL_SYSLOG_NEVER,
+	    MAXCAP, MAXCAP, &zone_cpu_base_ops);
+
+	rc_zone_cpu_burst_time = rctl_register("zone.cpu-burst-time",
+	    RCENTITY_ZONE, RCTL_GLOBAL_SIGNAL_NEVER | RCTL_GLOBAL_DENY_NEVER |
+	    RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_COUNT | RCTL_GLOBAL_SYSLOG_NEVER,
+	    INT_MAX, INT_MAX, &zone_cpu_burst_time_ops);
+
 	rc_zone_zfs_io_pri = rctl_register("zone.zfs-io-priority",
 	    RCENTITY_ZONE, RCTL_GLOBAL_SIGNAL_NEVER | RCTL_GLOBAL_DENY_NEVER |
 	    RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_COUNT | RCTL_GLOBAL_SYSLOG_NEVER,
-	    1024, 1024, &zone_zfs_io_pri_ops);
+	    16384, 16384, &zone_zfs_io_pri_ops);
 
 	rc_zone_nlwps = rctl_register("zone.max-lwps", RCENTITY_ZONE,
 	    RCTL_GLOBAL_NOACTION | RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_COUNT,
@@ -2187,6 +2580,20 @@
 	rde = rctl_dict_lookup("zone.cpu-shares");
 	(void) rctl_val_list_insert(&rde->rcd_default_value, dval);
 
+	/*
+	 * Create a rctl_val with PRIVILEGED, NOACTION, value = 1.  Then attach
+	 * this at the head of the rctl_dict_entry for ``zone.zfs-io-priority'.
+	 */
+	dval = kmem_cache_alloc(rctl_val_cache, KM_SLEEP);
+	bzero(dval, sizeof (rctl_val_t));
+	dval->rcv_value = 1;
+	dval->rcv_privilege = RCPRIV_PRIVILEGED;
+	dval->rcv_flagaction = RCTL_LOCAL_NOACTION;
+	dval->rcv_action_recip_pid = -1;
+
+	rde = rctl_dict_lookup("zone.zfs-io-priority");
+	(void) rctl_val_list_insert(&rde->rcd_default_value, dval);
+
 	rc_zone_locked_mem = rctl_register("zone.max-locked-memory",
 	    RCENTITY_ZONE, RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_BYTES |
 	    RCTL_GLOBAL_DENY_ALWAYS, UINT64_MAX, UINT64_MAX,
@@ -2197,6 +2604,11 @@
 	    RCTL_GLOBAL_DENY_ALWAYS, UINT64_MAX, UINT64_MAX,
 	    &zone_max_swap_ops);
 
+	rc_zone_phys_mem = rctl_register("zone.max-physical-memory",
+	    RCENTITY_ZONE, RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_BYTES |
+	    RCTL_GLOBAL_DENY_ALWAYS, UINT64_MAX, UINT64_MAX,
+	    &zone_phys_mem_ops);
+
 	rc_zone_max_lofi = rctl_register("zone.max-lofi",
 	    RCENTITY_ZONE, RCTL_GLOBAL_NOBASIC | RCTL_GLOBAL_COUNT |
 	    RCTL_GLOBAL_DENY_ALWAYS, UINT64_MAX, UINT64_MAX,
@@ -2218,6 +2630,8 @@
 	zone0.zone_ntasks = 1;
 	mutex_exit(&p0.p_lock);
 	zone0.zone_restart_init = B_TRUE;
+	zone0.zone_reboot_on_init_exit = B_FALSE;
+	zone0.zone_init_status = -1;
 	zone0.zone_brand = &native_brand;
 	rctl_prealloc_destroy(gp);
 	/*
@@ -2297,6 +2711,8 @@
 static void
 zone_free(zone_t *zone)
 {
+	zone_dl_t *zdl;
+
 	ASSERT(zone != global_zone);
 	ASSERT(zone->zone_ntasks == 0);
 	ASSERT(zone->zone_nlwps == 0);
@@ -2325,6 +2741,19 @@
 	list_destroy(&zone->zone_ref_list);
 	zone_free_zsd(zone);
 	zone_free_datasets(zone);
+
+	/*
+	 * While dlmgmtd should have removed all of these, it could have left
+	 * something behind or crashed. In which case it's not safe for us to
+	 * assume that the list is empty which list_destroy() will ASSERT. We
+	 * clean up for our userland comrades which may have crashed, or worse,
+	 * been disabled by SMF.
+	 */
+	while ((zdl = list_remove_head(&zone->zone_dl_list)) != NULL) {
+		if (zdl->zdl_net != NULL)
+			nvlist_free(zdl->zdl_net);
+		kmem_free(zdl, sizeof (zone_dl_t));
+	}
 	list_destroy(&zone->zone_dl_list);
 
 	if (zone->zone_rootvp != NULL)
@@ -2369,6 +2798,8 @@
 static void
 zone_status_set(zone_t *zone, zone_status_t status)
 {
+	timestruc_t now;
+	uint64_t t;
 
 	nvlist_t *nvl = NULL;
 	ASSERT(MUTEX_HELD(&zone_status_lock));
@@ -2375,6 +2806,10 @@
 	ASSERT(status > ZONE_MIN_STATE && status <= ZONE_MAX_STATE &&
 	    status >= zone_status_get(zone));
 
+	/* Current time since Jan 1 1970 but consumers expect NS */
+	gethrestime(&now);
+	t = (now.tv_sec * NANOSEC) + now.tv_nsec;
+
 	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, KM_SLEEP) ||
 	    nvlist_add_string(nvl, ZONE_CB_NAME, zone->zone_name) ||
 	    nvlist_add_string(nvl, ZONE_CB_NEWSTATE,
@@ -2382,7 +2817,7 @@
 	    nvlist_add_string(nvl, ZONE_CB_OLDSTATE,
 	    zone_status_table[zone->zone_status]) ||
 	    nvlist_add_int32(nvl, ZONE_CB_ZONEID, zone->zone_id) ||
-	    nvlist_add_uint64(nvl, ZONE_CB_TIMESTAMP, (uint64_t)gethrtime()) ||
+	    nvlist_add_uint64(nvl, ZONE_CB_TIMESTAMP, t) ||
 	    sysevent_evc_publish(zone_event_chan, ZONE_EVENT_STATUS_CLASS,
 	    ZONE_EVENT_STATUS_SUBCLASS, "sun.com", "kernel", nvl, EVCH_SLEEP)) {
 #ifdef DEBUG
@@ -2508,19 +2943,70 @@
 	return (0);
 }
 
+/*
+ * The zone_set_mcap_nover and zone_set_mcap_pageout functions are used
+ * to provide the physical memory capping kstats.  Since physical memory
+ * capping is currently implemented in userland, that code uses the setattr
+ * entry point to increment the kstats.  We always simply increment nover
+ * every time that setattr is called and we always add in the input value
+ * to zone_mcap_pagedout every time that is called.
+ */
+/*ARGSUSED*/
 static int
-zone_set_phys_mcap(zone_t *zone, const uint64_t *zone_mcap)
+zone_set_mcap_nover(zone_t *zone, const uint64_t *zone_nover)
 {
-	uint64_t mcap;
-	int err = 0;
+	zone->zone_mcap_nover++;
 
-	if ((err = copyin(zone_mcap, &mcap, sizeof (uint64_t))) == 0)
-		zone->zone_phys_mcap = mcap;
+	return (0);
+}
 
+static int
+zone_set_mcap_pageout(zone_t *zone, const uint64_t *zone_pageout)
+{
+	uint64_t pageout;
+	int err;
+
+	if ((err = copyin(zone_pageout, &pageout, sizeof (uint64_t))) == 0)
+		zone->zone_mcap_pagedout += pageout;
+
 	return (err);
 }
 
+/*
+ * The zone_set_page_fault_delay function is used to set the number of usecs
+ * to throttle page faults.  This is normally 0 but can be set to a non-0 value
+ * by the user-land memory capping code when the zone is over its physcial
+ * memory cap.
+ */
 static int
+zone_set_page_fault_delay(zone_t *zone, const uint32_t *pfdelay)
+{
+	uint32_t dusec;
+	int err;
+
+	if ((err = copyin(pfdelay, &dusec, sizeof (uint32_t))) == 0)
+		zone->zone_pg_flt_delay = dusec;
+
+	return (err);
+}
+
+/*
+ * The zone_set_rss function is used to set the zone's RSS when we do the
+ * fast, approximate calculation in user-land.
+ */
+static int
+zone_set_rss(zone_t *zone, const uint64_t *prss)
+{
+	uint64_t rss;
+	int err;
+
+	if ((err = copyin(prss, &rss, sizeof (uint64_t))) == 0)
+		zone->zone_phys_mem = rss;
+
+	return (err);
+}
+
+static int
 zone_set_sched_class(zone_t *zone, const char *new_class)
 {
 	char sched_class[PC_CLNMSZ];
@@ -2927,6 +3413,12 @@
 	return (curproc->p_zone->zone_id);
 }
 
+zoneid_t
+getzonedid(void)
+{
+	return (curproc->p_zone->zone_did);
+}
+
 /*
  * Internal versions of zone_find_by_*().  These don't zone_hold() or
  * check the validity of a zone's state.
@@ -3670,6 +4162,17 @@
 	 */
 	z->zone_proc_initpid = p->p_pid;
 
+	if (z->zone_setup_app_contract == B_TRUE) {
+		/*
+		 * Normally a process cannot modify its own contract, but we're
+		 * just starting the zone's init process and its contract is
+		 * always initialized from the sys_process_tmpl template, so
+		 * this is the simplest way to setup init's contract to kill
+		 * the process if any other process in the contract exits.
+		 */
+		p->p_ct_process->conp_ev_fatal |= CT_PR_EV_EXIT;
+	}
+
 	/*
 	 * We maintain zone_boot_err so that we can return the cause of the
 	 * failure back to the caller of the zone_boot syscall.
@@ -3698,9 +4201,54 @@
 			lwp_exit();
 		}
 	} else {
+		id_t cid = curthread->t_cid;
+
 		if (zone_status_get(z) == ZONE_IS_BOOTING)
 			zone_status_set(z, ZONE_IS_RUNNING);
 		mutex_exit(&zone_status_lock);
+
+		mutex_enter(&class_lock);
+		ASSERT(cid < loaded_classes);
+		if (strcmp(sclass[cid].cl_name, "FX") == 0 &&
+		    z->zone_fixed_hipri) {
+			/*
+			 * If the zone is using FX then by default all
+			 * processes start at the lowest priority and stay
+			 * there. We provide a mechanism for the zone to
+			 * indicate that it should run at "high priority". In
+			 * this case we setup init to run at the highest FX
+			 * priority (which is one level higher than the
+			 * non-fixed scheduling classes can use).
+			 */
+			pcparms_t pcparms;
+
+			pcparms.pc_cid = cid;
+			((fxkparms_t *)pcparms.pc_clparms)->fx_upri = FXMAXUPRI;
+			((fxkparms_t *)pcparms.pc_clparms)->fx_uprilim =
+			    FXMAXUPRI;
+			((fxkparms_t *)pcparms.pc_clparms)->fx_cflags =
+			    FX_DOUPRILIM | FX_DOUPRI;
+
+			mutex_enter(&pidlock);
+			mutex_enter(&curproc->p_lock);
+
+			(void) parmsset(&pcparms, curthread);
+
+			mutex_exit(&curproc->p_lock);
+			mutex_exit(&pidlock);
+		} else if (strcmp(sclass[cid].cl_name, "RT") == 0) {
+			/*
+			 * zsched always starts the init lwp at priority
+			 * minclsyspri - 1. This priority gets set in t_pri and
+			 * is invalid for RT, but RT never uses t_pri. However
+			 * t_pri is used by procfs, so we always see processes
+			 * within an RT zone with an invalid priority value.
+			 * We fix that up now.
+			 */
+			curthread->t_pri = RTGPPRIO0;
+		}
+		mutex_exit(&class_lock);
+
 		/* cause the process to return to userland. */
 		lwp_rtt();
 	}
@@ -4184,8 +4732,9 @@
 
 		error = EINVAL;
 		name = nvpair_name(nvp);
-		if (strncmp(nvpair_name(nvp), "zone.", sizeof ("zone.") - 1)
-		    != 0 || nvpair_type(nvp) != DATA_TYPE_NVLIST_ARRAY) {
+		if ((strncmp(name, "zone.", sizeof ("zone.") - 1) != 0 &&
+		    strncmp(name, "project.", sizeof ("project.") - 1) != 0) ||
+		    nvpair_type(nvp) != DATA_TYPE_NVLIST_ARRAY) {
 			goto out;
 		}
 		if ((hndl = rctl_hndl_lookup(name)) == -1) {
@@ -4303,7 +4852,7 @@
     caddr_t rctlbuf, size_t rctlbufsz,
     caddr_t zfsbuf, size_t zfsbufsz, int *extended_error,
     int match, uint32_t doi, const bslabel_t *label,
-    int flags)
+    int flags, zoneid_t zone_did)
 {
 	struct zsched_arg zarg;
 	nvlist_t *rctls = NULL;
@@ -4326,6 +4875,7 @@
 
 	zone = kmem_zalloc(sizeof (zone_t), KM_SLEEP);
 	zoneid = zone->zone_id = id_alloc(zoneid_space);
+	zone->zone_did = zone_did;
 	zone->zone_status = ZONE_IS_UNINITIALIZED;
 	zone->zone_pool = pool_default;
 	zone->zone_pool_mod = gethrtime();
@@ -4333,6 +4883,8 @@
 	zone->zone_ncpus = 0;
 	zone->zone_ncpus_online = 0;
 	zone->zone_restart_init = B_TRUE;
+	zone->zone_reboot_on_init_exit = B_FALSE;
+	zone->zone_init_status = -1;
 	zone->zone_brand = &native_brand;
 	zone->zone_initname = NULL;
 	mutex_init(&zone->zone_lock, NULL, MUTEX_DEFAULT, NULL);
@@ -4394,10 +4946,13 @@
 	zone->zone_locked_mem_ctl = UINT64_MAX;
 	zone->zone_max_swap = 0;
 	zone->zone_max_swap_ctl = UINT64_MAX;
+	zone->zone_phys_mem = 0;
+	zone->zone_phys_mem_ctl = UINT64_MAX;
 	zone->zone_max_lofi = 0;
 	zone->zone_max_lofi_ctl = UINT64_MAX;
 	zone->zone_lockedmem_kstat = NULL;
 	zone->zone_swapresv_kstat = NULL;
+	zone->zone_physmem_kstat = NULL;
 	zone->zone_zfs_io_pri = 1;
 
 	/*
@@ -4555,8 +5110,8 @@
 	/*
 	 * The process, task, and project rctls are probably wrong;
 	 * we need an interface to get the default values of all rctls,
-	 * and initialize zsched appropriately.  I'm not sure that that
-	 * makes much of a difference, though.
+	 * and initialize zsched appropriately. However, we allow zoneadmd
+	 * to pass down both zone and project rctls for the zone's init.
 	 */
 	error = newproc(zsched, (void *)&zarg, syscid, minclsyspri, NULL, 0);
 	if (error != 0) {
@@ -4697,6 +5252,7 @@
 static int
 zone_empty(zone_t *zone)
 {
+	int cnt = 0;
 	int waitstatus;
 
 	/*
@@ -4707,7 +5263,16 @@
 	ASSERT(MUTEX_NOT_HELD(&zonehash_lock));
 	while ((waitstatus = zone_status_timedwait_sig(zone,
 	    ddi_get_lbolt() + hz, ZONE_IS_EMPTY)) == -1) {
-		killall(zone->zone_id);
+		boolean_t force = B_FALSE;
+
+		/* Every 30 seconds, try harder */
+		if (cnt++ >= 30) {
+			cmn_err(CE_WARN, "attempt to force kill zone %d\n",
+			    zone->zone_id);
+			force = B_TRUE;
+			cnt = 0;
+		}
+		killall(zone->zone_id, force);
 	}
 	/*
 	 * return EINTR if we were signaled
@@ -5458,14 +6023,6 @@
 				error = EFAULT;
 		}
 		break;
-	case ZONE_ATTR_PHYS_MCAP:
-		size = sizeof (zone->zone_phys_mcap);
-		if (bufsize > size)
-			bufsize = size;
-		if (buf != NULL &&
-		    copyout(&zone->zone_phys_mcap, buf, bufsize) != 0)
-			error = EFAULT;
-		break;
 	case ZONE_ATTR_SCHED_CLASS:
 		mutex_enter(&class_lock);
 
@@ -5520,6 +6077,23 @@
 		}
 		kmem_free(zbuf, bufsize);
 		break;
+	case ZONE_ATTR_DID:
+		size = sizeof (zoneid_t);
+		if (bufsize > size)
+			bufsize = size;
+
+		if (buf != NULL && copyout(&zone->zone_did, buf, bufsize) != 0)
+			error = EFAULT;
+		break;
+	case ZONE_ATTR_SCHED_FIXEDHI:
+		size = sizeof (boolean_t);
+		if (bufsize > size)
+			bufsize = size;
+
+		if (buf != NULL && copyout(&zone->zone_fixed_hipri, buf,
+		    bufsize) != 0)
+			error = EFAULT;
+		break;
 	default:
 		if ((attr >= ZONE_ATTR_BRAND_ATTRS) && ZONE_IS_BRANDED(zone)) {
 			size = bufsize;
@@ -5551,10 +6125,11 @@
 		return (set_errno(EPERM));
 
 	/*
-	 * Only the ZONE_ATTR_PHYS_MCAP attribute can be set on the
-	 * global zone.
+	 * Only the ZONE_ATTR_PMCAP_NOVER and ZONE_ATTR_PMCAP_PAGEOUT
+	 * attributes can be set on the global zone.
 	 */
-	if (zoneid == GLOBAL_ZONEID && attr != ZONE_ATTR_PHYS_MCAP) {
+	if (zoneid == GLOBAL_ZONEID &&
+	    attr != ZONE_ATTR_PMCAP_NOVER && attr != ZONE_ATTR_PMCAP_PAGEOUT) {
 		return (set_errno(EINVAL));
 	}
 
@@ -5571,7 +6146,9 @@
 	 * non-global zones.
 	 */
 	zone_status = zone_status_get(zone);
-	if (attr != ZONE_ATTR_PHYS_MCAP && zone_status > ZONE_IS_READY) {
+	if (attr != ZONE_ATTR_PMCAP_NOVER && attr != ZONE_ATTR_PMCAP_PAGEOUT &&
+	    attr != ZONE_ATTR_PG_FLT_DELAY && attr != ZONE_ATTR_RSS &&
+	    zone_status > ZONE_IS_READY) {
 		err = EINVAL;
 		goto done;
 	}
@@ -5593,9 +6170,18 @@
 	case ZONE_ATTR_FS_ALLOWED:
 		err = zone_set_fs_allowed(zone, (const char *)buf);
 		break;
-	case ZONE_ATTR_PHYS_MCAP:
-		err = zone_set_phys_mcap(zone, (const uint64_t *)buf);
+	case ZONE_ATTR_PMCAP_NOVER:
+		err = zone_set_mcap_nover(zone, (const uint64_t *)buf);
 		break;
+	case ZONE_ATTR_PMCAP_PAGEOUT:
+		err = zone_set_mcap_pageout(zone, (const uint64_t *)buf);
+		break;
+	case ZONE_ATTR_PG_FLT_DELAY:
+		err = zone_set_page_fault_delay(zone, (const uint32_t *)buf);
+		break;
+	case ZONE_ATTR_RSS:
+		err = zone_set_rss(zone, (const uint64_t *)buf);
+		break;
 	case ZONE_ATTR_SCHED_CLASS:
 		err = zone_set_sched_class(zone, (const char *)buf);
 		break;
@@ -5623,6 +6209,22 @@
 		err = zone_set_network(zoneid, zbuf);
 		kmem_free(zbuf, bufsize);
 		break;
+	case ZONE_ATTR_APP_SVC_CT:
+		if (bufsize != sizeof (boolean_t)) {
+			err = EINVAL;
+		} else {
+			zone->zone_setup_app_contract = (boolean_t)buf;
+			err = 0;
+		}
+		break;
+	case ZONE_ATTR_SCHED_FIXEDHI:
+		if (bufsize != sizeof (boolean_t)) {
+			err = EINVAL;
+		} else {
+			zone->zone_fixed_hipri = (boolean_t)buf;
+			err = 0;
+		}
+		break;
 	default:
 		if ((attr >= ZONE_ATTR_BRAND_ATTRS) && ZONE_IS_BRANDED(zone))
 			err = ZBROP(zone)->b_setattr(zone, attr, buf, bufsize);
@@ -6315,6 +6917,7 @@
 			zs.doi = zs32.doi;
 			zs.label = (const bslabel_t *)(uintptr_t)zs32.label;
 			zs.flags = zs32.flags;
+			zs.zoneid = zs32.zoneid;
 #else
 			panic("get_udatamodel() returned bogus result\n");
 #endif
@@ -6325,7 +6928,7 @@
 		    (caddr_t)zs.rctlbuf, zs.rctlbufsz,
 		    (caddr_t)zs.zfsbuf, zs.zfsbufsz,
 		    zs.extended_error, zs.match, zs.doi,
-		    zs.label, zs.flags));
+		    zs.label, zs.flags, zs.zoneid));
 	case ZONE_BOOT:
 		return (zone_boot((zoneid_t)(uintptr_t)arg1));
 	case ZONE_DESTROY:
@@ -6426,6 +7029,7 @@
 	bcopy(zone->zone_name, zone_name, zone_namelen);
 	zoneid = zone->zone_id;
 	uniqid = zone->zone_uniqid;
+	arg.status = zone->zone_init_status;
 	/*
 	 * zoneadmd may be down, but at least we can empty out the zone.
 	 * We can ignore the return value of zone_empty() since we're called
@@ -6603,7 +7207,7 @@
 	 * zone_ki_call_zoneadmd() will do a more thorough job of this
 	 * later.
 	 */
-	killall(zone->zone_id);
+	killall(zone->zone_id, B_FALSE);
 	/*
 	 * Now, create the thread to contact zoneadmd and do the rest of the
 	 * work.  This thread can't be created in our zone otherwise
usr/src/uts/common/sys/Makefile
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/Makefile	Tue Nov 17 16:20:42 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/Makefile	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 # Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
 # Copyright 2014, Joyent, Inc. All rights reserved.
 # Copyright 2013 Garrett D'Amore <garrett@damore.org>
+# Copyright 2015, Joyent, Inc. All rights reserved.
 # Copyright 2013 Saso Kiselkov. All rights reserved.
 # Copyright 2015 Nexenta Systems, Inc. All rights reserved.
 # Copyright 2015 Igor Kozhukhov <ikozhukhov@gmail.com>
@@ -249,6 +250,7 @@
 	flock.h			\
 	flock_impl.h		\
 	fork.h			\
+	frameio.h		\
 	fss.h			\
 	fsspriocntl.h		\
 	fsid.h			\
@@ -274,6 +276,7 @@
 	idmap.h 		\
 	ieeefp.h		\
 	id_space.h		\
+	inotify.h		\
 	instance.h		\
 	int_const.h		\
 	int_fmtio.h		\
@@ -342,6 +345,7 @@
 	lgrp.h			\
 	lgrp_user.h		\
 	libc_kernel.h		\
+	limits.h		\
 	link.h			\
 	list.h			\
 	list_impl.h		\
@@ -422,6 +426,9 @@
 	ontrap.h		\
 	open.h			\
 	openpromio.h		\
+	overlay.h		\
+	overlay_common.h	\
+	overlay_target.h	\
 	panic.h			\
 	param.h			\
 	pathconf.h		\
@@ -644,6 +651,8 @@
 	vmem.h			\
 	vmem_impl.h		\
 	vmsystm.h		\
+	vnd.h			\
+	vnd_errno.h		\
 	vnic.h			\
 	vnic_impl.h		\
 	vnode.h			\
@@ -655,6 +664,7 @@
 	vuid_queue.h		\
 	vuid_state.h		\
 	vuid_store.h		\
+	vxlan.h			\
 	wait.h			\
 	waitq.h			\
 	wanboot_impl.h		\
@@ -661,6 +671,7 @@
 	watchpoint.h		\
 	winlockio.h		\
 	zcons.h			\
+	zfd.h			\
 	zone.h			\
 	xti_inet.h		\
 	xti_osi.h		\
@@ -854,7 +865,6 @@
 	autofs.h		\
 	decomp.h		\
 	dv_node.h		\
-	sdev_impl.h		\
 	fifonode.h		\
 	hsfs_isospec.h		\
 	hsfs_node.h		\
@@ -861,6 +871,8 @@
 	hsfs_rrip.h		\
 	hsfs_spec.h		\
 	hsfs_susp.h		\
+	hyprlofs.h		\
+	hyprlofs_info.h		\
 	lofs_info.h		\
 	lofs_node.h		\
 	mntdata.h		\
@@ -870,6 +882,8 @@
 	pc_label.h		\
 	pc_node.h		\
 	pxfs_ki.h		\
+	sdev_impl.h		\
+	sdev_plugin.h		\
 	snode.h			\
 	swapnode.h		\
 	tmp.h			\
@@ -993,6 +1007,7 @@
 
 SYSEVENTHDRS=		\
 	ap_driver.h     \
+	datalink.h	\
 	dev.h		\
 	domain.h        \
 	dr.h            \
usr/src/uts/common/sys/auxv.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/auxv.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/auxv.h	Wed Jun 17 17:43:43 2015
@@ -29,7 +29,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright (c) 2012, Joyent, Inc.  All rights reserved.
+ * Copyright (c) 2014, Joyent, Inc.  All rights reserved.
  */
 
 #ifndef	_SYS_AUXV_H
@@ -78,6 +78,9 @@
 #define	AT_FLAGS	8	/* processor flags */
 #define	AT_ENTRY	9	/* a.out entry point */
 
+/* First introduced on Linux */
+#define	AT_RANDOM	25	/* address of 16 random bytes */
+
 /*
  * These relate to the original PPC ABI document; Linux reused
  * the values for other things (see below), so disambiguation of
@@ -110,6 +113,16 @@
  * AT_UCACHEBSIZE	21	(moved from 12)
  *
  * AT_IGNOREPPC		22
+ *
+ * On Linux:
+ * AT_* values 18 through 22 are reserved
+ * AT_SECURE		23	secure mode boolean
+ * AT_BASE_PLATFORM	24	string identifying real platform, may
+ *				differ from AT_PLATFORM.
+ * AT_HWCAP2		26	extension of AT_HWCAP
+ * AT_EXECFN		31	filename of program
+ * AT_SYSINFO		32
+ * AT_SYSINFO_EHDR	33	The vDSO location
  */
 
 /*
@@ -186,6 +199,8 @@
 #define	AT_SUN_BRAND_AUX1	2020
 #define	AT_SUN_BRAND_AUX2	2021
 #define	AT_SUN_BRAND_AUX3	2022
+#define	AT_SUN_BRAND_AUX4	2025
+#define	AT_SUN_BRAND_NROOT	2024
 
 /*
  * Note that 2023 is reserved for the AT_SUN_HWCAP2 word defined above.
usr/src/uts/common/sys/brand.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/brand.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/brand.h	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #ifndef _SYS_BRAND_H
@@ -102,19 +103,68 @@
 struct intpdata;
 struct execa;
 
+/*
+ * Common structure to define hooks for brand operation.
+ *
+ * Required Fields:
+ * b_init_brand_data - Setup zone brand data during zone_setbrand
+ * b_free_brand_data - Free zone brand data during zone_destroy
+ * b_brandsys - Syscall handler for brandsys
+ * b_setbrand - Initialize process brand data
+ * b_getattr - Get brand-custom zone attribute
+ * b_setattr - Set brand-custom zone attribute
+ * b_copy_procdata - Copy process brand data during fork
+ * b_proc_exit - Perform process brand exit processing
+ * b_exec - Reset branded process state on exec
+ * b_lwp_setrval - Set return code for forked child
+ * b_initlwp - Initialize lwp brand data (cannot drop p->p_lock)
+ * b_forklwp - Copy lwp brand data during fork
+ * b_freelwp - Free lwp brand data
+ * b_lwpexit - Perform lwp-specific brand exit processing
+ * b_elfexec - Load and execute ELF binary
+ * b_sigset_native_to_brand - Convert sigset native->brand
+ * b_sigset_brand_to_native - Convert sigset brand->native
+ * b_nsig - Maxiumum signal number
+ * b_sendsig - Update process state after sendsig
+ *
+ * Optional Fields:
+ * b_lwpdata_alloc - Speculatively allocate data for use in b_initlwp
+ * b_lwpdata_free - Free data from allocated by b_lwpdata_alloc if errors occur
+ *                  during lwp creation before b_initlwp could be called.
+ * b_initlwp_post - Complete lwp branding (can temporarily drop p->p_lock)
+ * b_exit_with_sig - Instead of sending SIGCLD, exit with custom behavior
+ * b_psig_to_proc - Custom additional behavior during psig
+ * b_wait_filter - Filter processes from being matched by waitid
+ * b_native_exec - Provide interpreter path prefix for executables
+ * b_ptrace_exectrap - Custom behavior for legacy ptrace traps
+ * b_map32limit - Specify alternate limit for MAP_32BIT mappings
+ * b_stop_notify - Hook process stop events
+ * b_waitid_helper - Generate synthetic results for waitid
+ * b_sigcld_repost - Post synthetic SIGCLD signals
+ * b_issig_stop - Alter/suppress signal delivery during issig
+ * b_sig_ignorable - Disallow discarding of signals
+ * b_savecontext - Alter context during savecontext
+ * b_restorecontext - Alter context during restorecontext
+ * b_sendsig_stack - Override stack used for signal delivery
+ * b_setid_clear - Override setid_clear behavior
+ * b_pagefault - Trap pagefault events
+ */
 struct brand_ops {
 	void	(*b_init_brand_data)(zone_t *);
 	void	(*b_free_brand_data)(zone_t *);
 	int	(*b_brandsys)(int, int64_t *, uintptr_t, uintptr_t, uintptr_t,
-		uintptr_t, uintptr_t, uintptr_t);
+		uintptr_t, uintptr_t);
 	void	(*b_setbrand)(struct proc *);
 	int	(*b_getattr)(zone_t *, int, void *, size_t *);
 	int	(*b_setattr)(zone_t *, int, void *, size_t);
 	void	(*b_copy_procdata)(struct proc *, struct proc *);
-	void	(*b_proc_exit)(struct proc *, klwp_t *);
+	void	(*b_proc_exit)(struct proc *);
 	void	(*b_exec)();
 	void	(*b_lwp_setrval)(klwp_t *, int, int);
-	int	(*b_initlwp)(klwp_t *);
+	void	*(*b_lwpdata_alloc)(struct proc *);
+	void	(*b_lwpdata_free)(void *);
+	void	(*b_initlwp)(klwp_t *, void *);
+	void	(*b_initlwp_post)(klwp_t *);
 	void	(*b_forklwp)(klwp_t *, klwp_t *);
 	void	(*b_freelwp)(klwp_t *);
 	void	(*b_lwpexit)(klwp_t *);
@@ -121,10 +171,31 @@
 	int	(*b_elfexec)(struct vnode *vp, struct execa *uap,
 	    struct uarg *args, struct intpdata *idata, int level,
 	    long *execsz, int setid, caddr_t exec_file,
-	    struct cred *cred, int brand_action);
+	    struct cred *cred, int *brand_action);
 	void	(*b_sigset_native_to_brand)(sigset_t *);
 	void	(*b_sigset_brand_to_native)(sigset_t *);
+	void	(*b_sigfd_translate)(k_siginfo_t *);
 	int	b_nsig;
+	void	(*b_exit_with_sig)(proc_t *, sigqueue_t *);
+	boolean_t (*b_wait_filter)(proc_t *, proc_t *);
+	boolean_t (*b_native_exec)(uint8_t, const char **);
+	uint32_t (*b_map32limit)(proc_t *);
+	void	(*b_stop_notify)(proc_t *, klwp_t *, ushort_t, ushort_t);
+	int	(*b_waitid_helper)(idtype_t, id_t, k_siginfo_t *, int,
+	    boolean_t *, int *);
+	int	(*b_sigcld_repost)(proc_t *, sigqueue_t *);
+	int	(*b_issig_stop)(proc_t *, klwp_t *);
+	boolean_t (*b_sig_ignorable)(proc_t *, klwp_t *, int);
+	void	(*b_savecontext)(ucontext_t *);
+#if defined(_SYSCALL32_IMPL)
+	void	(*b_savecontext32)(ucontext32_t *);
+#endif
+	void	(*b_restorecontext)(ucontext_t *);
+	caddr_t	(*b_sendsig_stack)(int);
+	void	(*b_sendsig)(int);
+	int	(*b_setid_clear)(vattr_t *vap, cred_t *cr);
+	int	(*b_pagefault)(proc_t *, klwp_t *, caddr_t, enum fault_type,
+	    enum seg_rw);
 };
 
 /*
@@ -135,6 +206,7 @@
 	char    		*b_name;
 	struct brand_ops	*b_ops;
 	struct brand_mach_ops	*b_machops;
+	size_t			b_data_size;
 } brand_t;
 
 extern brand_t native_brand;
@@ -165,7 +237,7 @@
 extern brand_t	*brand_find_name(char *);
 extern void	brand_unregister_zone(brand_t *);
 extern int	brand_zone_count(brand_t *);
-extern void	brand_setbrand(proc_t *);
+extern int	brand_setbrand(proc_t *, boolean_t);
 extern void	brand_clearbrand(proc_t *, boolean_t);
 
 /*
@@ -178,17 +250,16 @@
 extern void	brand_solaris_copy_procdata(proc_t *, proc_t *,
 		    struct brand *);
 extern int	brand_solaris_elfexec(vnode_t *, execa_t *, uarg_t *,
-		    intpdata_t *, int, long *, int, caddr_t, cred_t *, int,
-		    struct brand *, char *, char *, char *, char *, char *);
+		    intpdata_t *, int, long *, int, caddr_t, cred_t *, int *,
+		    struct brand *, char *, char *, char *);
 extern void	brand_solaris_exec(struct brand *);
 extern int	brand_solaris_fini(char **, struct modlinkage *,
 		    struct brand *);
 extern void	brand_solaris_forklwp(klwp_t *, klwp_t *, struct brand *);
 extern void	brand_solaris_freelwp(klwp_t *, struct brand *);
-extern int	brand_solaris_initlwp(klwp_t *, struct brand *);
+extern void	brand_solaris_initlwp(klwp_t *, struct brand *);
 extern void	brand_solaris_lwpexit(klwp_t *, struct brand *);
-extern void	brand_solaris_proc_exit(struct proc *, klwp_t *,
-		    struct brand *);
+extern void	brand_solaris_proc_exit(struct proc *, struct brand *);
 extern void	brand_solaris_setbrand(proc_t *, struct brand *);
 
 #if defined(_SYSCALL32)
usr/src/uts/common/sys/devpoll.h
No differences encountered
usr/src/uts/common/sys/exec.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/exec.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/exec.h	Mon Dec 14 10:47:45 2015
@@ -26,6 +26,10 @@
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
 /*	  All Rights Reserved  	*/
 
+/*
+ * Copyright 2015, Joyent, Inc.
+ */
+
 #ifndef _SYS_EXEC_H
 #define	_SYS_EXEC_H
 
@@ -102,10 +106,12 @@
 	vnode_t	*ex_vp;
 	char	*emulator;
 	char	*brandname;
+	const char *brand_nroot;
 	char	*auxp_auxflags; /* addr of auxflags auxv on the user stack */
 	char	*auxp_brand; /* address of first brand auxv on user stack */
 	cred_t	*pfcred;
 	boolean_t scrubenv;
+	uintptr_t maxstack;
 } uarg_t;
 
 /*
@@ -157,10 +163,11 @@
 #endif
 
 #define	INTPSZ	MAXPATHLEN
+#define	INTP_MAXDEPTH	5	/* Nested interpreter depth matches Linux */
 typedef struct intpdata {
 	char	*intp;
-	char	*intp_name;
-	char	*intp_arg;
+	char	*intp_name[INTP_MAXDEPTH];
+	char	*intp_arg[INTP_MAXDEPTH];
 } intpdata_t;
 
 #define	EXECSETID_SETID		0x1 /* setid exec */
@@ -174,7 +181,7 @@
 	int	(*exec_func)(struct vnode *vp, struct execa *uap,
 		    struct uarg *args, struct intpdata *idata, int level,
 		    long *execsz, int setid, caddr_t exec_file,
-		    struct cred *cred, int brand_action);
+		    struct cred *cred, int *brand_action);
 	int	(*exec_core)(struct vnode *vp, struct proc *p,
 		    struct cred *cred, rlim64_t rlimit, int sig,
 		    core_content_t content);
@@ -212,7 +219,7 @@
     const char **envp, int brand_action);
 extern int gexec(vnode_t **vp, struct execa *uap, struct uarg *args,
     struct intpdata *idata, int level, long *execsz, caddr_t exec_file,
-    struct cred *cred, int brand_action);
+    struct cred *cred, int *brand_action);
 extern struct execsw *allocate_execsw(char *name, char *magic,
     size_t magic_size);
 extern struct execsw *findexecsw(char *magic);
@@ -237,16 +244,18 @@
  * when compiling the 32-bit compatability elf code in the elfexec module.
  */
 extern int elfexec(vnode_t *, execa_t *, uarg_t *, intpdata_t *, int,
-    long *, int, caddr_t, cred_t *, int);
+    long *, int, caddr_t, cred_t *, int *);
 extern int mapexec_brand(vnode_t *, uarg_t *, Ehdr *, Addr *,
-    intptr_t *, caddr_t, int *, caddr_t *, caddr_t *, size_t *, uintptr_t *);
+    intptr_t *, caddr_t, char **, caddr_t *, caddr_t *, size_t *,
+    uintptr_t *, uintptr_t *);
 #endif /* !_ELF32_COMPAT */
 
 #if defined(_LP64)
 extern int elf32exec(vnode_t *, execa_t *, uarg_t *, intpdata_t *, int,
-    long *, int, caddr_t, cred_t *, int);
+    long *, int, caddr_t, cred_t *, int *);
 extern int mapexec32_brand(vnode_t *, uarg_t *, Elf32_Ehdr *, Elf32_Addr *,
-    intptr_t *, caddr_t, int *, caddr_t *, caddr_t *, size_t *, uintptr_t *);
+    intptr_t *, caddr_t, char **, caddr_t *, caddr_t *, size_t *,
+    uintptr_t *, uintptr_t *);
 #endif  /* _LP64 */
 
 /*
usr/src/uts/common/sys/iso/signal_iso.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/iso/signal_iso.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/iso/signal_iso.h	Wed Jun 17 17:43:44 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -95,7 +96,7 @@
 
 /* insert new signals here, and move _SIGRTM* appropriately */
 #define	_SIGRTMIN 42	/* first (highest-priority) realtime signal */
-#define	_SIGRTMAX 73	/* last (lowest-priority) realtime signal */
+#define	_SIGRTMAX 74	/* last (lowest-priority) realtime signal */
 extern long _sysconf(int);	/* System Private interface to sysconf() */
 #define	SIGRTMIN ((int)_sysconf(_SC_SIGRT_MIN))	/* first realtime signal */
 #define	SIGRTMAX ((int)_sysconf(_SC_SIGRT_MAX))	/* last realtime signal */
usr/src/uts/common/sys/klwp.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/klwp.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/klwp.h	Mon Dec 14 10:47:45 2015
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #ifndef	_SYS_KLWP_H
@@ -191,7 +191,19 @@
 	struct ct_template *lwp_ct_active[CTT_MAXTYPE]; /* active templates */
 	struct contract	*lwp_ct_latest[CTT_MAXTYPE]; /* last created contract */
 
-	void	*lwp_brand;		/* per-lwp brand data */
+	/*
+	 * Branding:
+	 * lwp_brand			- per-lwp brand data
+	 * lwp_brand_syscall		- brand syscall interposer
+	 * lwp_brand_syscall_fast	- brand "fast path" syscall interposer
+	 *
+	 * The lwp_brand_syscall_fast handler should only be used if an
+	 * lwp_brand_syscall handler is also in place.
+	 */
+	void	*lwp_brand;
+	int	(*lwp_brand_syscall)(void);
+	int	(*lwp_brand_syscall_fast)(void);
+
 	struct psinfo *lwp_spymaster;	/* if an agent LWP, our spymaster */
 } klwp_t;
 
usr/src/uts/common/sys/netconfig.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/netconfig.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/netconfig.h	Wed Jun 17 17:43:44 2015
@@ -28,6 +28,7 @@
  *
  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #ifndef	_SYS_NETCONFIG_H
@@ -147,6 +148,8 @@
 extern struct netconfig *getnetpath(void *);
 extern void		nc_perror(const char *);
 extern char		*nc_sperror(void);
+extern void		_nsl_brand_set_hooks(int (*)(void),
+			    struct netconfig *(*)(int));
 
 #ifdef	__cplusplus
 }
usr/src/uts/common/sys/poll.h
No differences encountered
usr/src/uts/common/sys/poll_impl.h
No differences encountered
usr/src/uts/common/sys/proc.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/proc.h	Tue Nov 17 16:20:42 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/proc.h	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015 Joyent, Inc.  All rights reserved.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -348,8 +349,10 @@
 	struct zone	*p_zone;	/* zone in which process lives */
 	struct vnode	*p_execdir;	/* directory that p_exec came from */
 	struct brand	*p_brand;	/* process's brand  */
-	void		*p_brand_data;	/* per-process brand state */
 
+	/* per-process brand state */
+	void		*p_brand_data;
+
 	/* additional lock to protect p_sessp (but not its contents) */
 	kmutex_t p_splock;
 	rctl_qty_t	p_locked_mem;	/* locked memory charged to proc */
@@ -363,7 +366,6 @@
 	 */
 	struct user p_user;		/* (see sys/user.h) */
 } proc_t;
-
 #define	PROC_T				/* headers relying on proc_t are OK */
 
 #ifdef _KERNEL
@@ -629,6 +631,7 @@
 extern int sigcheck(proc_t *, kthread_t *);
 extern void sigdefault(proc_t *);
 
+extern struct pid *pid_find(pid_t pid);
 extern void pid_setmin(void);
 extern pid_t pid_allocate(proc_t *, pid_t, int);
 extern int pid_rele(struct pid *);
@@ -644,6 +647,7 @@
 extern void sprwaitlock_proc(proc_t *);
 extern void sprlock_proc(proc_t *);
 extern void sprunlock(proc_t *);
+extern void sprunprlock(proc_t *);
 extern void pid_init(void);
 extern proc_t *pid_entry(int);
 extern int pid_slot(proc_t *);
@@ -718,6 +722,10 @@
 extern	void	thread_init(void);
 extern	void	thread_load(kthread_t *, void (*)(), caddr_t, size_t);
 
+extern	void	thread_splitstack(void (*)(void *), void *, size_t);
+extern	void	thread_splitstack_run(caddr_t, void (*)(void *), void *);
+extern	void	thread_splitstack_cleanup(void);
+
 extern	void	tsd_create(uint_t *, void (*)(void *));
 extern	void	tsd_destroy(uint_t *);
 extern	void	*tsd_getcreate(uint_t *, void (*)(void *), void *(*)(void));
@@ -759,7 +767,7 @@
 extern	void	continuelwps(proc_t *);
 extern	int	exitlwps(int);
 extern	void	lwp_ctmpl_copy(klwp_t *, klwp_t *);
-extern	void	lwp_ctmpl_clear(klwp_t *);
+extern	void	lwp_ctmpl_clear(klwp_t *, boolean_t);
 extern	klwp_t	*forklwp(klwp_t *, proc_t *, id_t);
 extern	void	lwp_load(klwp_t *, gregset_t, uintptr_t);
 extern	void	lwp_setrval(klwp_t *, int, int);
usr/src/uts/common/sys/procfs.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/procfs.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/procfs.h	Wed Jun 17 17:43:44 2015
@@ -25,6 +25,7 @@
  */
 /*
  * Copyright 2012 DEY Storage Systems, Inc.  All rights reserved.
+ * Copyright 2015, Joyent, Inc.
  */
 
 #ifndef _SYS_PROCFS_H
@@ -233,6 +234,7 @@
 #define	PR_FAULTED	6
 #define	PR_SUSPENDED	7
 #define	PR_CHECKPOINT	8
+#define	PR_BRAND	9
 
 /*
  * lwp ps(1) information file.  /proc/<pid>/lwp/<lwpid>/lwpsinfo
usr/src/uts/common/sys/ptms.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/ptms.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/ptms.h	Wed Jun 17 17:43:44 2015
@@ -126,6 +126,12 @@
 #define	DDBGP(a, b)
 #endif
 
+typedef struct __ptmptsopencb_arg *ptmptsopencb_arg_t;
+typedef struct ptmptsopencb {
+	boolean_t		(*ppocb_func)(ptmptsopencb_arg_t);
+	ptmptsopencb_arg_t	ppocb_arg;
+} ptmptsopencb_t;
+
 #endif /* _KERNEL */
 
 typedef struct pt_own {
@@ -157,6 +163,19 @@
 #define	ZONEPT		(('P'<<8)|4)	/* set zone of master/slave pair */
 #define	OWNERPT		(('P'<<8)|5)	/* set owner/group for slave device */
 
+#ifdef _KERNEL
+/*
+ * kernel ioctl commands
+ *
+ * PTMPTSOPENCB: Returns a callback function pointer and opaque argument.
+ *	      The return value of the callback function when it's invoked
+ *	      with the opaque argument passed to it will indicate if the
+ *	      pts slave device is currently open.
+ */
+#define	PTMPTSOPENCB	(('P'<<8)|6)	/* check if the slave is open */
+
+#endif /* _KERNEL */
+
 #ifdef	__cplusplus
 }
 #endif
usr/src/uts/common/sys/signal.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/signal.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/signal.h	Wed Jun 17 17:43:44 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015, Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -158,8 +159,8 @@
  * use of these symbols by applications is injurious
  *	to binary compatibility
  */
-#define	NSIG	74	/* valid signals range from 1 to NSIG-1 */
-#define	MAXSIG	73	/* size of u_signal[], NSIG-1 <= MAXSIG */
+#define	NSIG	75	/* valid signals range from 1 to NSIG-1 */
+#define	MAXSIG	74	/* size of u_signal[], NSIG-1 <= MAXSIG */
 #endif /* defined(__EXTENSIONS__) || !defined(_XPG4_2) */
 
 #define	MINSIGSTKSZ	2048
usr/src/uts/common/sys/socket.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/socket.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/socket.h	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
  * Copyright 2014 Garrett D'Amore <garrett@damore.org>
  *
  * Copyright (c) 1989, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015, Joyent, Inc. All rights reserved.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -39,6 +40,9 @@
 
 /* Copyright (c) 2013, OmniTI Computer Consulting, Inc. All rights reserved. */
 
+/*
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ */
 #ifndef	_SYS_SOCKET_H
 #define	_SYS_SOCKET_H
 
@@ -194,6 +198,7 @@
 #define	SO_SRCADDR	0x2001		/* Internal: AF_UNIX source address */
 #define	SO_FILEP	0x2002		/* Internal: AF_UNIX file pointer */
 #define	SO_UNIX_CLOSE	0x2003		/* Internal: AF_UNIX peer closed */
+#define	SO_REUSEPORT	0x2004		/* allow simultaneous port reuse */
 #endif	/* _KERNEL */
 
 /*
@@ -293,8 +298,9 @@
 #define	AF_INET_OFFLOAD	30		/* Sun private; do not use */
 #define	AF_TRILL	31		/* TRILL interface */
 #define	AF_PACKET	32		/* PF_PACKET Linux socket interface */
+#define	AF_LX_NETLINK	33		/* Linux-compatible netlink */
 
-#define	AF_MAX		32
+#define	AF_MAX		33
 
 /*
  * Protocol families, same as address families for now.
@@ -334,6 +340,7 @@
 #define	PF_INET_OFFLOAD	AF_INET_OFFLOAD	/* Sun private; do not use */
 #define	PF_TRILL	AF_TRILL
 #define	PF_PACKET	AF_PACKET
+#define	PF_LX_NETLINK	AF_LX_NETLINK
 
 #define	PF_MAX		AF_MAX
 
@@ -420,6 +427,7 @@
 #define	MSG_NOTIFICATION 0x100		/* Notification, not data */
 #define	MSG_XPG4_2	0x8000		/* Private: XPG4.2 flag */
 
+/* Obsolete but kept for compilation compatability. Use IOV_MAX. */
 #define	MSG_MAXIOVLEN	16
 
 #ifdef _KERNEL
usr/src/uts/common/sys/socketvar.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/socketvar.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/socketvar.h	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
@@ -102,6 +103,7 @@
 
 typedef struct sonodeops sonodeops_t;
 typedef struct sonode sonode_t;
+typedef boolean_t (*so_krecv_f)(sonode_t *, mblk_t *, size_t, int, void *);
 
 struct sodirect_s;
 
@@ -244,6 +246,10 @@
 	struct sof_instance	*so_filter_top;		/* top of stack */
 	struct sof_instance	*so_filter_bottom;	/* bottom of stack */
 	clock_t			so_filter_defertime;	/* time when deferred */
+
+	/* Kernel direct receive callbacks */
+	so_krecv_f		so_krecv_cb;		/* recv callback */
+	void			*so_krecv_arg;		/* recv cb arg */
 };
 
 #define	SO_HAVE_DATA(so)						\
@@ -297,15 +303,16 @@
 #define	SS_OOBPEND		0x00002000 /* OOB pending or present - poll */
 #define	SS_HAVEOOBDATA		0x00004000 /* OOB data present */
 #define	SS_HADOOBDATA		0x00008000 /* OOB data consumed */
-#define	SS_CLOSING		0x00010000 /* in process of closing */
 
+#define	SS_CLOSING		0x00010000 /* in process of closing */
 #define	SS_FIL_DEFER		0x00020000 /* filter deferred notification */
 #define	SS_FILOP_OK		0x00040000 /* socket can attach filters */
 #define	SS_FIL_RCV_FLOWCTRL	0x00080000 /* filter asserted rcv flow ctrl */
+
 #define	SS_FIL_SND_FLOWCTRL	0x00100000 /* filter asserted snd flow ctrl */
 #define	SS_FIL_STOP		0x00200000 /* no more filter actions */
-
 #define	SS_SODIRECT		0x00400000 /* transport supports sodirect */
+#define	SS_FILOP_UNSF		0x00800000 /* block attaching unsafe filters */
 
 #define	SS_SENTLASTREADSIG	0x01000000 /* last rx signal has been sent */
 #define	SS_SENTLASTWRITESIG	0x02000000 /* last tx signal has been sent */
@@ -321,7 +328,8 @@
 
 /*
  * Sockets that can fall back to TPI must ensure that fall back is not
- * initiated while a thread is using a socket.
+ * initiated while a thread is using a socket. Otherwise this disables all
+ * future filter attachment.
  */
 #define	SO_BLOCK_FALLBACK(so, fn)				\
 	ASSERT(MUTEX_NOT_HELD(&(so)->so_lock));			\
@@ -337,6 +345,24 @@
 		}						\
 	}
 
+/*
+ * Sockets that can fall back to TPI must ensure that fall back is not
+ * initiated while a thread is using a socket. Otherwise this disables all
+ * future unsafe filter attachment. Safe filters can still attach after
+ * we execute the function in which this macro is used.
+ */
+#define	SO_BLOCK_FALLBACK_SAFE(so, fn)				\
+	ASSERT(MUTEX_NOT_HELD(&(so)->so_lock));			\
+	rw_enter(&(so)->so_fallback_rwlock, RW_READER);		\
+	if ((so)->so_state & SS_FALLBACK_COMP) {		\
+		rw_exit(&(so)->so_fallback_rwlock);		\
+		return (fn);					\
+	} else if (((so)->so_state & SS_FILOP_UNSF) == 0) {	\
+		mutex_enter(&(so)->so_lock);			\
+		(so)->so_state |= SS_FILOP_UNSF;		\
+		mutex_exit(&(so)->so_lock);			\
+	}
+
 #define	SO_UNBLOCK_FALLBACK(so)	{			\
 	rw_exit(&(so)->so_fallback_rwlock);		\
 }
@@ -368,6 +394,7 @@
 /* The modes below are only for non-streams sockets */
 #define	SM_ACCEPTSUPP		0x400	/* can handle accept() */
 #define	SM_SENDFILESUPP		0x800	/* Private: proto supp sendfile  */
+#define	SM_DEFERERR		0x1000	/* Private: defer so_error delivery */
 
 /*
  * Socket versions. Used by the socket library when calling _so_socket().
@@ -946,6 +973,15 @@
 extern int	so_copyin(const void *, void *, size_t, int);
 extern int	so_copyout(const void *, void *, size_t, int);
 
+/*
+ * Functions to manipulate the use of direct receive callbacks. This should not
+ * be used outside of sockfs and ksocket. These are generally considered a use
+ * once interface for a socket and will cause all outstanding data on the socket
+ * to be flushed.
+ */
+extern int	so_krecv_set(sonode_t *, so_krecv_f, void *);
+extern void	so_krecv_unblock(sonode_t *);
+
 #endif
 
 /*
usr/src/uts/common/sys/termios.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/termios.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/termios.h	Wed Jun 17 17:43:44 2015
@@ -361,6 +361,24 @@
 #define	TCSETSF		(_TIOC|16)
 
 /*
+ * linux terminal ioctls we need to be aware of
+ */
+#define	TIOCSETLD	(_TIOC|123)	/* set line discipline parms */
+#define	TIOCGETLD	(_TIOC|124)	/* get line discipline parms */
+
+/*
+ * The VMIN and VTIME and solaris overlap with VEOF and VEOL - This is
+ * perfectly legal except, linux expects them to be separate. So we keep
+ * them separately.
+ */
+struct lx_cc {
+	unsigned char veof;	/* veof value */
+	unsigned char veol;	/* veol value */
+	unsigned char vmin;	/* vmin value */
+	unsigned char vtime;	/* vtime value */
+};
+
+/*
  * NTP PPS ioctls
  */
 #define	TIOCGPPS	(_TIOC|125)
usr/src/uts/common/sys/thread.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/thread.h	Tue Nov 17 16:20:42 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/thread.h	Mon Dec 14 10:47:45 2015
@@ -24,6 +24,10 @@
  * Use is subject to license terms.
  */
 
+/*
+ * Copyright (c) 2015, Joyent, Inc.  All rights reserved.
+ */
+
 #ifndef	_SYS_THREAD_H
 #define	_SYS_THREAD_H
 
@@ -68,6 +72,8 @@
 	void	(*free_op)(void *, int); /* function which frees the context */
 	void	*arg;		/* argument to above functions, ctx pointer */
 	struct ctxop *next;	/* next context ops */
+	hrtime_t save_ts;		/* timestamp of last save */
+	hrtime_t restore_ts;		/* timestamp of last restore */
 } ctxop_t;
 
 /*
@@ -339,6 +345,7 @@
 	uintptr_t	t_dtrace_astpc;	/* DTrace return sequence location */
 #ifdef __amd64
 	uint64_t	t_dtrace_regv;	/* DTrace saved reg from fasttrap */
+	uint64_t	t_useracc;	/* SMAP state saved across swtch() */
 #endif
 	hrtime_t	t_hrtime;	/* high-res last time on cpu */
 	kmutex_t	t_ctx_lock;	/* protects t_ctx in removectx() */
@@ -365,7 +372,7 @@
 #define	T_WOULDBLOCK	0x0020	/* for lockfs */
 #define	T_DONTBLOCK	0x0040	/* for lockfs */
 #define	T_DONTPEND	0x0080	/* for lockfs */
-#define	T_SYS_PROF	0x0100	/* profiling on for duration of system call */
+#define	T_SPLITSTK	0x0100	/* kernel stack is currently split */
 #define	T_WAITCVSEM	0x0200	/* waiting for a lwp_cv or lwp_sema on sleepq */
 #define	T_WATCHPT	0x0400	/* thread undergoing a watchpoint emulation */
 #define	T_PANIC		0x0800	/* thread initiated a system panic */
@@ -413,8 +420,9 @@
 #define	TS_RESUME	0x1000	/* setrun() by CPR resume process */
 #define	TS_CREATE	0x2000	/* setrun() by syslwp_create() */
 #define	TS_RUNQMATCH	0x4000	/* exact run queue balancing by setbackdq() */
+#define	TS_BSTART	0x8000	/* setrun() by brand */
 #define	TS_ALLSTART	\
-	(TS_CSTART|TS_UNPAUSE|TS_XSTART|TS_PSTART|TS_RESUME|TS_CREATE)
+	(TS_CSTART|TS_UNPAUSE|TS_XSTART|TS_PSTART|TS_RESUME|TS_CREATE|TS_BSTART)
 #define	TS_ANYWAITQ	(TS_PROJWAITQ|TS_ZONEWAITQ)
 
 /*
@@ -442,6 +450,10 @@
 #define	ISTOPPED(t) ((t)->t_state == TS_STOPPED && \
 			!((t)->t_schedflag & TS_PSTART))
 
+/* True if thread is stopped for a brand-specific reason */
+#define	BSTOPPED(t)	((t)->t_state == TS_STOPPED && \
+			    !((t)->t_schedflag & TS_BSTART))
+
 /* True if thread is asleep and wakeable */
 #define	ISWAKEABLE(t) (((t)->t_state == TS_SLEEP && \
 			((t)->t_flag & T_WAKEABLE)))
usr/src/uts/common/sys/uio.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/uio.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/uio.h	Wed Aug 19 10:40:34 2015
@@ -145,7 +145,8 @@
  */
 typedef enum xuio_type {
 	UIOTYPE_ASYNCIO,
-	UIOTYPE_ZEROCOPY
+	UIOTYPE_ZEROCOPY,
+	UIOTYPE_PEEKSIZE
 } xuio_type_t;
 
 typedef struct xuio {
@@ -175,6 +176,15 @@
 			int xu_zc_rw;	/* read or write buffer */
 			void *xu_zc_priv;	/* fs specific */
 		} xu_zc;
+
+		/*
+		 * Peek Size Support -- facilitate peeking at the size of a
+		 * waiting message on a socket.
+		 */
+		struct {
+			ssize_t xu_ps_size;	/* size of waiting msg */
+			boolean_t xu_ps_set;	/* was size calculated? */
+		} xu_ps;
 	} xu_ext;
 } xuio_t;
 
usr/src/uts/common/sys/vmsystm.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/vmsystm.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/vmsystm.h	Wed Jun 17 17:43:44 2015
@@ -19,6 +19,9 @@
  * CDDL HEADER END
  */
 /*
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ */
+/*
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -159,6 +162,8 @@
 
 extern	size_t	exec_get_spslew(void);
 
+extern	caddr_t	map_userlimit(proc_t *pp, struct as *as, int flags);
+
 #endif	/* _KERNEL */
 
 #ifdef	__cplusplus
usr/src/uts/common/sys/zfd.h
usr/src/uts/common/sys/zone.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/sys/zone.h	Tue Jan  5 17:20:22 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/sys/zone.h	Mon Dec 14 10:47:45 2015
@@ -23,6 +23,7 @@
  * Copyright 2013, Joyent, Inc. All rights reserved.
  * Copyright 2014 Nexenta Systems, Inc. All rights reserved.
  * Copyright 2014 Igor Kozhukhov <ikozhukhov@gmail.com>.
+ * Copyright 2015, Joyent, Inc. All rights reserved.
  */
 
 #ifndef _SYS_ZONE_H
@@ -97,13 +98,19 @@
 #define	ZONE_ATTR_INITNAME	9
 #define	ZONE_ATTR_BOOTARGS	10
 #define	ZONE_ATTR_BRAND		11
-#define	ZONE_ATTR_PHYS_MCAP	12
+#define	ZONE_ATTR_PMCAP_NOVER	12
 #define	ZONE_ATTR_SCHED_CLASS	13
 #define	ZONE_ATTR_FLAGS		14
 #define	ZONE_ATTR_HOSTID	15
 #define	ZONE_ATTR_FS_ALLOWED	16
 #define	ZONE_ATTR_NETWORK	17
+#define	ZONE_ATTR_DID		18
+#define	ZONE_ATTR_PMCAP_PAGEOUT	19
 #define	ZONE_ATTR_INITNORESTART	20
+#define	ZONE_ATTR_PG_FLT_DELAY	21
+#define	ZONE_ATTR_RSS		22
+#define	ZONE_ATTR_APP_SVC_CT	23
+#define	ZONE_ATTR_SCHED_FIXEDHI	24
 
 /* Start of the brand-specific attribute namespace */
 #define	ZONE_ATTR_BRAND_ATTRS	32768
@@ -184,6 +191,7 @@
 	uint32_t doi;			/* DOI for label */
 	caddr32_t label;		/* label associated with zone */
 	int flags;
+	zoneid_t zoneid;		/* requested zoneid */
 } zone_def32;
 #endif
 typedef struct {
@@ -200,6 +208,7 @@
 	uint32_t doi;			/* DOI for label */
 	const bslabel_t *label;		/* label associated with zone */
 	int flags;
+	zoneid_t zoneid;		/* requested zoneid */
 } zone_def;
 
 /* extended error information */
@@ -244,9 +253,12 @@
 typedef struct zone_cmd_arg {
 	uint64_t	uniqid;		/* unique "generation number" */
 	zone_cmd_t	cmd;		/* requested action */
-	uint32_t	_pad;		/* need consistent 32/64 bit alignmt */
+	int		status;		/* init status on shutdown */
+	uint32_t	debug;		/* enable brand hook debug */
 	char locale[MAXPATHLEN];	/* locale in which to render messages */
 	char bootbuf[BOOTARGS_MAX];	/* arguments passed to zone_boot() */
+	/* Needed for 32/64 zoneadm -> zoneadmd door arg size check. */
+	int		pad;
 } zone_cmd_arg_t;
 
 /*
@@ -372,7 +384,7 @@
 } zone_dataset_t;
 
 /*
- * structure for zone kstats
+ * structure for rctl zone kstats
  */
 typedef struct zone_kstat {
 	kstat_named_t zk_zonename;
@@ -389,6 +401,52 @@
 } sys_zio_cntr_t;
 
 typedef struct {
+	kstat_named_t	zv_zonename;
+	kstat_named_t	zv_nread;
+	kstat_named_t	zv_reads;
+	kstat_named_t	zv_rtime;
+	kstat_named_t	zv_rlentime;
+	kstat_named_t	zv_nwritten;
+	kstat_named_t	zv_writes;
+	kstat_named_t	zv_wtime;
+	kstat_named_t	zv_wlentime;
+	kstat_named_t	zv_10ms_ops;
+	kstat_named_t	zv_100ms_ops;
+	kstat_named_t	zv_1s_ops;
+	kstat_named_t	zv_10s_ops;
+	kstat_named_t 	zv_delay_cnt;
+	kstat_named_t	zv_delay_time;
+} zone_vfs_kstat_t;
+
+typedef struct {
+	kstat_named_t	zz_zonename;
+	kstat_named_t	zz_nread;
+	kstat_named_t	zz_reads;
+	kstat_named_t	zz_rtime;
+	kstat_named_t	zz_rlentime;
+	kstat_named_t	zz_nwritten;
+	kstat_named_t	zz_writes;
+	kstat_named_t	zz_waittime;
+} zone_zfs_kstat_t;
+
+typedef struct {
+	kstat_named_t	zm_zonename;
+	kstat_named_t	zm_rss;
+	kstat_named_t	zm_phys_cap;
+	kstat_named_t	zm_swap;
+	kstat_named_t	zm_swap_cap;
+	kstat_named_t	zm_nover;
+	kstat_named_t	zm_pagedout;
+	kstat_named_t	zm_pgpgin;
+	kstat_named_t	zm_anonpgin;
+	kstat_named_t	zm_execpgin;
+	kstat_named_t	zm_fspgin;
+	kstat_named_t	zm_anon_alloc_fail;
+	kstat_named_t	zm_pf_throttle;
+	kstat_named_t	zm_pf_throttle_usec;
+} zone_mcap_kstat_t;
+
+typedef struct {
 	kstat_named_t	zm_zonename;	/* full name, kstat truncates name */
 	kstat_named_t	zm_utime;
 	kstat_named_t	zm_stime;
@@ -396,15 +454,13 @@
 	kstat_named_t	zm_avenrun1;
 	kstat_named_t	zm_avenrun5;
 	kstat_named_t	zm_avenrun15;
-	kstat_named_t	zm_run_ticks;
-	kstat_named_t	zm_run_wait;
-	kstat_named_t	zm_fss_shr_pct;
-	kstat_named_t	zm_fss_pri_hi;
-	kstat_named_t	zm_fss_pri_avg;
 	kstat_named_t	zm_ffcap;
 	kstat_named_t	zm_ffnoproc;
 	kstat_named_t	zm_ffnomem;
 	kstat_named_t	zm_ffmisc;
+	kstat_named_t	zm_nested_intp;
+	kstat_named_t	zm_init_pid;
+	kstat_named_t	zm_boot_time;
 } zone_misc_kstat_t;
 
 typedef struct zone {
@@ -446,6 +502,7 @@
 	 */
 	list_node_t	zone_linkage;
 	zoneid_t	zone_id;	/* ID of zone */
+	zoneid_t	zone_did;	/* persistent debug ID of zone */
 	uint_t		zone_ref;	/* count of zone_hold()s on zone */
 	uint_t		zone_cred_ref;	/* count of zone_hold_cred()s on zone */
 	/*
@@ -498,10 +555,11 @@
 	kcondvar_t	zone_cv;	/* used to signal state changes */
 	struct proc	*zone_zsched;	/* Dummy kernel "zsched" process */
 	pid_t		zone_proc_initpid; /* pid of "init" for this zone */
-	char		*zone_initname;	/* fs path to 'init' */
+	char		*zone_initname;		/* fs path to 'init' */
+	int		zone_init_status;	/* init's exit status */
 	int		zone_boot_err;  /* for zone_boot() if boot fails */
 	char		*zone_bootargs;	/* arguments passed via zone_boot() */
-	uint64_t	zone_phys_mcap;	/* physical memory cap */
+	rctl_qty_t	zone_phys_mem_ctl;	/* current phys. memory limit */
 	/*
 	 * zone_kthreads is protected by zone_status_lock.
 	 */
@@ -539,9 +597,12 @@
 	tsol_mlp_list_t zone_mlps;	/* MLPs on zone-private addresses */
 
 	boolean_t	zone_restart_init;	/* Restart init if it dies? */
+	boolean_t	zone_reboot_on_init_exit; /* Reboot if init dies? */
+	boolean_t	zone_setup_app_contract; /* setup contract? */
 	struct brand	*zone_brand;		/* zone's brand */
 	void 		*zone_brand_data;	/* store brand specific data */
 	id_t		zone_defaultcid;	/* dflt scheduling class id */
+	boolean_t	zone_fixed_hipri;	/* fixed sched. hi prio */
 	kstat_t		*zone_swapresv_kstat;
 	kstat_t		*zone_lockedmem_kstat;
 	/*
@@ -566,6 +627,22 @@
 	sys_zio_cntr_t	zone_lwr_ops;		/* logical writes. */
 
 	/*
+	 * kstats and counters for VFS ops and bytes.
+	 */
+	kmutex_t	zone_vfs_lock;		/* protects VFS statistics */
+	kstat_t		*zone_vfs_ksp;
+	kstat_io_t	zone_vfs_rwstats;
+	zone_vfs_kstat_t *zone_vfs_stats;
+
+	/*
+	 * kstats for ZFS I/O ops and bytes.
+	 */
+	kmutex_t	zone_zfs_lock;		/* protects ZFS statistics */
+	kstat_t		*zone_zfs_ksp;
+	kstat_io_t	zone_zfs_rwstats;
+	zone_zfs_kstat_t *zone_zfs_stats;
+
+	/*
 	 * Solaris Auditing per-zone audit context
 	 */
 	struct au_kcontext	*zone_audit_kctxt;
@@ -584,6 +661,27 @@
 	kstat_t		*zone_nprocs_kstat;
 
 	/*
+	 * kstats and counters for physical memory capping.
+	 */
+	rctl_qty_t	zone_phys_mem;	/* current bytes of phys. mem. (RSS) */
+	kstat_t		*zone_physmem_kstat;
+	uint64_t	zone_mcap_nover;	/* # of times over phys. cap */
+	uint64_t	zone_mcap_pagedout;	/* bytes of mem. paged out */
+	kmutex_t	zone_mcap_lock;	/* protects mcap statistics */
+	kstat_t		*zone_mcap_ksp;
+	zone_mcap_kstat_t *zone_mcap_stats;
+	uint64_t	zone_pgpgin;		/* pages paged in */
+	uint64_t	zone_anonpgin;		/* anon pages paged in */
+	uint64_t	zone_execpgin;		/* exec pages paged in */
+	uint64_t	zone_fspgin;		/* fs pages paged in */
+	uint64_t	zone_anon_alloc_fail;	/* cnt of anon alloc fails */
+	uint64_t	zone_pf_throttle;	/* cnt of page flt throttles */
+	uint64_t	zone_pf_throttle_usec;	/* time of page flt throttles */
+
+	/* Num usecs to throttle page fault when zone is over phys. mem cap */
+	uint32_t	zone_pg_flt_delay;
+
+	/*
 	 * Misc. kstats and counters for zone cpu-usage aggregation.
 	 * The zone_Xtime values are the sum of the micro-state accounting
 	 * values for all threads that are running or have run in the zone.
@@ -607,6 +705,8 @@
 	uint32_t	zone_ffnomem;		/* as_dup/memory error */
 	uint32_t	zone_ffmisc;		/* misc. other error */
 
+	uint32_t	zone_nested_intp;	/* nested interp. kstat */
+
 	struct loadavg_s zone_loadavg;		/* loadavg for this zone */
 	uint64_t	zone_hp_avenrun[3];	/* high-precision avenrun */
 	int		zone_avenrun[3];	/* FSCALED avg. run queue len */
@@ -661,6 +761,7 @@
 extern zone_t *zone_find_by_any_path(const char *, boolean_t);
 extern zone_t *zone_find_by_path(const char *);
 extern zoneid_t getzoneid(void);
+extern zoneid_t getzonedid(void);
 extern zone_t *zone_find_by_id_nolock(zoneid_t);
 extern int zone_datalink_walk(zoneid_t, int (*)(datalink_id_t, void *), void *);
 extern int zone_check_datalink(zoneid_t *, datalink_id_t);
@@ -855,6 +956,7 @@
 
 extern rctl_hndl_t rc_zone_locked_mem;
 extern rctl_hndl_t rc_zone_max_swap;
+extern rctl_hndl_t rc_zone_phys_mem;
 extern rctl_hndl_t rc_zone_max_lofi;
 
 #endif	/* _KERNEL */
usr/src/uts/common/syscall/brandsys.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/syscall/brandsys.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/syscall/brandsys.c	Wed Jun 17 17:43:44 2015
@@ -23,7 +23,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
+ */
 
 #include <sys/brand.h>
 #include <sys/systm.h>
@@ -35,7 +37,7 @@
  */
 int64_t
 brandsys(int cmd, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3,
-    uintptr_t arg4, uintptr_t arg5, uintptr_t arg6)
+    uintptr_t arg4, uintptr_t arg5)
 {
 	struct proc *p = curthread->t_procp;
 	int64_t rval = 0;
@@ -49,7 +51,7 @@
 		return (set_errno(ENOSYS));
 
 	if ((err = ZBROP(p->p_zone)->b_brandsys(cmd, &rval, arg1, arg2, arg3,
-	    arg4, arg5, arg6)) != 0)
+	    arg4, arg5)) != 0)
 		return (set_errno(err));
 
 	return (rval);
usr/src/uts/common/syscall/fcntl.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/syscall/fcntl.c	Mon Dec  7 18:06:21 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/syscall/fcntl.c	Wed Jun 17 17:43:44 2015
@@ -54,7 +54,8 @@
 
 #include <sys/cmn_err.h>
 
-static int flock_check(vnode_t *, flock64_t *, offset_t, offset_t);
+/* This is global so that it can be used by brand emulation. */
+int flock_check(vnode_t *, flock64_t *, offset_t, offset_t);
 static int flock_get_start(vnode_t *, flock64_t *, offset_t, u_offset_t *);
 static void fd_too_big(proc_t *);
 
usr/src/uts/common/syscall/lwp_sobj.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/syscall/lwp_sobj.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/syscall/lwp_sobj.c	Mon Dec 14 10:47:45 2015
@@ -22,6 +22,7 @@
 /*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
+ * Copyright 2015 Joyent, Inc.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -1022,7 +1023,10 @@
 }
 
 /*
- * Set the owner and ownerpid fields of a user-level mutex.
+ * Set the owner and ownerpid fields of a user-level mutex. Note, this function
+ * uses the suword*_noerr routines which must be called between
+ * on_fault/no_fault. However, this routine itself does not do the
+ * on_fault/no_fault and it is assumed all the callers will do so instead!
  */
 static void
 set_owner_pid(lwp_mutex_t *lp, uintptr_t owner, pid_t pid)
@@ -1201,9 +1205,21 @@
 	if (UPIMUTEX(type)) {
 		no_fault();
 		error = lwp_upimutex_lock(lp, type, UPIMUTEX_BLOCK, &lwpt);
-		if (error == 0 || error == EOWNERDEAD || error == ELOCKUNMAPPED)
+		if (error == 0 || error == EOWNERDEAD ||
+		    error == ELOCKUNMAPPED) {
+			volatile int locked = error != 0;
+			if (on_fault(&ljb)) {
+				if (locked != 0)
+					error = lwp_upimutex_unlock(lp, type);
+				else
+					error = EFAULT;
+				goto upierr;
+			}
 			set_owner_pid(lp, owner,
 			    (type & USYNC_PROCESS)? p->p_pid : 0);
+			no_fault();
+		}
+upierr:
 		if (tsp && !time_error)	/* copyout the residual time left */
 			error = lwp_timer_copyout(&lwpt, error);
 		if (error)
@@ -3045,9 +3061,22 @@
 	if (UPIMUTEX(type)) {
 		no_fault();
 		error = lwp_upimutex_lock(lp, type, UPIMUTEX_TRY, NULL);
-		if (error == 0 || error == EOWNERDEAD || error == ELOCKUNMAPPED)
+		if (error == 0 || error == EOWNERDEAD ||
+		    error == ELOCKUNMAPPED) {
+			volatile int locked = error != 0;
+			if (on_fault(&ljb)) {
+				if (locked != 0)
+					error = lwp_upimutex_unlock(lp, type);
+				else
+					error = EFAULT;
+				goto upierr;
+			}
 			set_owner_pid(lp, owner,
 			    (type & USYNC_PROCESS)? p->p_pid : 0);
+			no_fault();
+		}
+
+upierr:
 		if (error)
 			return (set_errno(error));
 		return (0);
usr/src/uts/common/syscall/open.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/syscall/open.c	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/syscall/open.c	Wed Jun 17 17:43:44 2015
@@ -74,12 +74,12 @@
 
 	if (filemode & (FSEARCH|FEXEC)) {
 		/*
-		 * Must be one or the other and neither FREAD nor FWRITE
+		 * Must be one or the other.
 		 * Must not be any of FAPPEND FCREAT FTRUNC FXATTR FXATTRDIROPEN
-		 * XXX: Should these just be silently ignored?
+		 * XXX: Should these just be silently ignored like we
+		 * silently ignore FREAD|FWRITE?
 		 */
-		if ((filemode & (FREAD|FWRITE)) ||
-		    (filemode & (FSEARCH|FEXEC)) == (FSEARCH|FEXEC) ||
+		if ((filemode & (FSEARCH|FEXEC)) == (FSEARCH|FEXEC) ||
 		    (filemode & (FAPPEND|FCREAT|FTRUNC|FXATTR|FXATTRDIROPEN)))
 			return (set_errno(EINVAL));
 	}
usr/src/uts/common/syscall/poll.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/syscall/poll.c	Mon Oct 19 10:48:41 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/syscall/poll.c	Mon Dec 28 16:27:39 2015
@@ -317,20 +317,58 @@
 	return (0);
 }
 
-static int
-poll_common(pollfd_t *fds, nfds_t nfds, timespec_t *tsp, k_sigset_t *ksetp)
+int
+poll_copyin(pollstate_t *ps, pollfd_t *fds, nfds_t nfds)
 {
+	pollfd_t *pollfdp;
+	nfds_t old_nfds;
+
+	/*
+	 * NOTE: for performance, buffers are saved across poll() calls.
+	 * The theory is that if a process polls heavily, it tends to poll
+	 * on the same set of descriptors.  Therefore, we only reallocate
+	 * buffers when nfds changes.  There is no hysteresis control,
+	 * because there is no data to suggest that this is necessary;
+	 * the penalty of reallocating is not *that* great in any event.
+	 */
+	old_nfds = ps->ps_nfds;
+	if (nfds != old_nfds) {
+		kmem_free(ps->ps_pollfd, old_nfds * sizeof (pollfd_t));
+		pollfdp = kmem_alloc(nfds * sizeof (pollfd_t), KM_SLEEP);
+		ps->ps_pollfd = pollfdp;
+		ps->ps_nfds = nfds;
+	}
+
+	pollfdp = ps->ps_pollfd;
+	if (copyin(fds, pollfdp, nfds * sizeof (pollfd_t))) {
+		return (EFAULT);
+	}
+
+	if (fds == NULL) {
+		/*
+		 * If the process has page 0 mapped, then the copyin() above
+		 * will succeed even if fds is NULL.  However, our cached
+		 * poll lists are keyed by the address of the passed-in fds
+		 * structure, and we use the value NULL to indicate an unused
+		 * poll cache list entry.  As such, we elect not to support
+		 * NULL as a valid (user) memory address and fail the poll()
+		 * call.
+		 */
+		return (EFAULT);
+	}
+	return (0);
+}
+
+int
+poll_common(pollstate_t *ps, pollfd_t *fds, nfds_t nfds, timespec_t *tsp,
+    int *fdcnt)
+{
 	kthread_t *t = curthread;
-	klwp_t *lwp = ttolwp(t);
 	proc_t *p = ttoproc(t);
-	int fdcnt = 0;
-	int i;
 	hrtime_t deadline; /* hrtime value when we want to return */
 	pollfd_t *pollfdp;
-	pollstate_t *ps;
 	pollcache_t *pcp;
 	int error = 0;
-	nfds_t old_nfds;
 	int cacheindex = 0;	/* which cache set is used */
 
 	/*
@@ -348,29 +386,7 @@
 	}
 
 	/*
-	 * Reset our signal mask, if requested.
-	 */
-	if (ksetp != NULL) {
-		mutex_enter(&p->p_lock);
-		schedctl_finish_sigblock(t);
-		lwp->lwp_sigoldmask = t->t_hold;
-		t->t_hold = *ksetp;
-		t->t_flag |= T_TOMASK;
-		/*
-		 * Call cv_reltimedwait_sig() just to check for signals.
-		 * We will return immediately with either 0 or -1.
-		 */
-		if (!cv_reltimedwait_sig(&t->t_delay_cv, &p->p_lock, 0,
-		    TR_CLOCK_TICK)) {
-			mutex_exit(&p->p_lock);
-			error = EINTR;
-			goto pollout;
-		}
-		mutex_exit(&p->p_lock);
-	}
-
-	/*
-	 * Check to see if this guy just wants to use poll() as a timeout.
+	 * Check to see if the caller just wants to use poll() as a timeout.
 	 * If yes then bypass all the other stuff and make him sleep.
 	 */
 	if (nfds == 0) {
@@ -385,67 +401,15 @@
 			    &t->t_delay_lock, deadline)) > 0)
 				continue;
 			mutex_exit(&t->t_delay_lock);
-			error = (error == 0) ? EINTR : 0;
 		}
-		goto pollout;
+		*fdcnt = 0;
+		return ((error == 0) ? EINTR : 0);
 	}
 
-	if (nfds > p->p_fno_ctl) {
-		mutex_enter(&p->p_lock);
-		(void) rctl_action(rctlproc_legacy[RLIMIT_NOFILE],
-		    p->p_rctls, p, RCA_SAFE);
-		mutex_exit(&p->p_lock);
-		error = EINVAL;
-		goto pollout;
-	}
-
-	/*
-	 * Need to allocate memory for pollstate before anything because
-	 * the mutex and cv are created in this space
-	 */
-	ps = pollstate_create();
-
-	if (ps->ps_pcache == NULL)
-		ps->ps_pcache = pcache_alloc();
-	pcp = ps->ps_pcache;
-
-	/*
-	 * NOTE: for performance, buffers are saved across poll() calls.
-	 * The theory is that if a process polls heavily, it tends to poll
-	 * on the same set of descriptors.  Therefore, we only reallocate
-	 * buffers when nfds changes.  There is no hysteresis control,
-	 * because there is no data to suggest that this is necessary;
-	 * the penalty of reallocating is not *that* great in any event.
-	 */
-	old_nfds = ps->ps_nfds;
-	if (nfds != old_nfds) {
-
-		kmem_free(ps->ps_pollfd, old_nfds * sizeof (pollfd_t));
-		pollfdp = kmem_alloc(nfds * sizeof (pollfd_t), KM_SLEEP);
-		ps->ps_pollfd = pollfdp;
-		ps->ps_nfds = nfds;
-	}
-
+	VERIFY(ps != NULL);
 	pollfdp = ps->ps_pollfd;
-	if (copyin(fds, pollfdp, nfds * sizeof (pollfd_t))) {
-		error = EFAULT;
-		goto pollout;
-	}
+	VERIFY(pollfdp != NULL);
 
-	if (fds == NULL) {
-		/*
-		 * If the process has page 0 mapped, then the copyin() above
-		 * will succeed even if fds is NULL.  However, our cached
-		 * poll lists are keyed by the address of the passed-in fds
-		 * structure, and we use the value NULL to indicate an unused
-		 * poll cache list entry.  As such, we elect not to support
-		 * NULL as a valid (user) memory address and fail the poll()
-		 * call.
-		 */
-		error = EINVAL;
-		goto pollout;
-	}
-
 	/*
 	 * If this thread polls for the first time, allocate ALL poll
 	 * cache data structures and cache the poll fd list. This
@@ -460,10 +424,10 @@
 		/*
 		 * poll and cache this poll fd list in ps_pcacheset[0].
 		 */
-		error = pcacheset_cache_list(ps, fds, &fdcnt, cacheindex);
-		if (fdcnt || error) {
+		error = pcacheset_cache_list(ps, fds, fdcnt, cacheindex);
+		if (error || *fdcnt) {
 			mutex_exit(&ps->ps_lock);
-			goto pollout;
+			return (error);
 		}
 	} else {
 		pollcacheset_t	*pcset = ps->ps_pcacheset;
@@ -488,11 +452,11 @@
 				 * the callee will guarantee the consistency
 				 * of cached poll list and cache content.
 				 */
-				error = pcacheset_resolve(ps, nfds, &fdcnt,
+				error = pcacheset_resolve(ps, nfds, fdcnt,
 				    cacheindex);
 				if (error) {
 					mutex_exit(&ps->ps_lock);
-					goto pollout;
+					return (error);
 				}
 				break;
 			}
@@ -509,11 +473,11 @@
 				 * found an unused entry. Use it to cache
 				 * this poll list.
 				 */
-				error = pcacheset_cache_list(ps, fds, &fdcnt,
+				error = pcacheset_cache_list(ps, fds, fdcnt,
 				    cacheindex);
-				if (fdcnt || error) {
+				if (error || *fdcnt) {
 					mutex_exit(&ps->ps_lock);
-					goto pollout;
+					return (error);
 				}
 				break;
 			}
@@ -527,10 +491,10 @@
 			cacheindex = pcacheset_replace(ps);
 			ASSERT(cacheindex < ps->ps_nsets);
 			pcset[cacheindex].pcs_usradr = (uintptr_t)fds;
-			error = pcacheset_resolve(ps, nfds, &fdcnt, cacheindex);
+			error = pcacheset_resolve(ps, nfds, fdcnt, cacheindex);
 			if (error) {
 				mutex_exit(&ps->ps_lock);
-				goto pollout;
+				return (error);
 			}
 		}
 	}
@@ -548,8 +512,8 @@
 	mutex_enter(&pcp->pc_lock);
 	for (;;) {
 		pcp->pc_flag = 0;
-		error = pcache_poll(pollfdp, ps, nfds, &fdcnt, cacheindex);
-		if (fdcnt || error) {
+		error = pcache_poll(pollfdp, ps, nfds, fdcnt, cacheindex);
+		if (error || *fdcnt) {
 			mutex_exit(&pcp->pc_lock);
 			mutex_exit(&ps->ps_lock);
 			break;
@@ -595,13 +559,116 @@
 		mutex_enter(&pcp->pc_lock);
 	}
 
+	return (error);
+}
+
+/*
+ * This is the system call trap that poll(),
+ * select() and pselect() are built upon.
+ * It is a private interface between libc and the kernel.
+ */
+int
+pollsys(pollfd_t *fds, nfds_t nfds, timespec_t *timeoutp, sigset_t *setp)
+{
+	kthread_t *t = curthread;
+	klwp_t *lwp = ttolwp(t);
+	proc_t *p = ttoproc(t);
+	timespec_t ts;
+	timespec_t *tsp;
+	k_sigset_t kset;
+	pollstate_t *ps = NULL;
+	pollfd_t *pollfdp = NULL;
+	int error = 0, fdcnt = 0;
+
+	/*
+	 * Copy in timeout
+	 */
+	if (timeoutp == NULL) {
+		tsp = NULL;
+	} else {
+		if (get_udatamodel() == DATAMODEL_NATIVE) {
+			if (copyin(timeoutp, &ts, sizeof (ts)))
+				return (set_errno(EFAULT));
+		} else {
+			timespec32_t ts32;
+
+			if (copyin(timeoutp, &ts32, sizeof (ts32)))
+				return (set_errno(EFAULT));
+			TIMESPEC32_TO_TIMESPEC(&ts, &ts32)
+		}
+
+		if (itimerspecfix(&ts))
+			return (set_errno(EINVAL));
+		tsp = &ts;
+	}
+
+	/*
+	 * Copy in and reset signal mask, if requested.
+	 */
+	if (setp != NULL) {
+		sigset_t set;
+
+		if (copyin(setp, &set, sizeof (set)))
+			return (set_errno(EFAULT));
+		sigutok(&set, &kset);
+
+		mutex_enter(&p->p_lock);
+		schedctl_finish_sigblock(t);
+		lwp->lwp_sigoldmask = t->t_hold;
+		t->t_hold = kset;
+		t->t_flag |= T_TOMASK;
+		/*
+		 * Call cv_reltimedwait_sig() just to check for signals.
+		 * We will return immediately with either 0 or -1.
+		 */
+		if (!cv_reltimedwait_sig(&t->t_delay_cv, &p->p_lock, 0,
+		    TR_CLOCK_TICK)) {
+			mutex_exit(&p->p_lock);
+			error = EINTR;
+			goto pollout;
+		}
+		mutex_exit(&p->p_lock);
+	}
+
+	/*
+	 * Initialize pollstate and copy in pollfd data if present.
+	 * If nfds == 0, we will skip all of the copying and check steps and
+	 * proceed directly into poll_common to process the supplied timeout.
+	 */
+	if (nfds != 0) {
+		if (nfds > p->p_fno_ctl) {
+			mutex_enter(&p->p_lock);
+			(void) rctl_action(rctlproc_legacy[RLIMIT_NOFILE],
+			    p->p_rctls, p, RCA_SAFE);
+			mutex_exit(&p->p_lock);
+			error = EINVAL;
+			goto pollout;
+		}
+
+		/*
+		 * Need to allocate memory for pollstate before anything
+		 * because the mutex and cv are created in this space
+		 */
+		ps = pollstate_create();
+		if (ps->ps_pcache == NULL)
+			ps->ps_pcache = pcache_alloc();
+
+		if ((error = poll_copyin(ps, fds, nfds)) != 0)
+			goto pollout;
+		pollfdp = ps->ps_pollfd;
+	}
+
+	/*
+	 * Perform the actual poll.
+	 */
+	error = poll_common(ps, fds, nfds, tsp, &fdcnt);
+
 pollout:
 	/*
-	 * If we changed the signal mask but we received
-	 * no signal then restore the signal mask.
-	 * Otherwise psig() will deal with the signal mask.
+	 * If we changed the signal mask but we received no signal then restore
+	 * the signal mask.  Otherwise psig() will deal with the signal mask.
 	 */
-	if (ksetp != NULL) {
+	if (setp != NULL) {
 		mutex_enter(&p->p_lock);
 		if (lwp->lwp_cursig == 0) {
 			t->t_hold = lwp->lwp_sigoldmask;
@@ -612,12 +679,10 @@
 
 	if (error)
 		return (set_errno(error));
-
 	/*
 	 * Copy out the events and return the fdcnt to the user.
 	 */
-	if (nfds != 0 &&
-	    copyout(pollfdp, fds, nfds * sizeof (pollfd_t)))
+	if (nfds != 0 && copyout(pollfdp, fds, nfds * sizeof (pollfd_t)))
 		return (set_errno(EFAULT));
 
 #ifdef DEBUG
@@ -625,7 +690,7 @@
 	 * Another sanity check:
 	 */
 	if (fdcnt) {
-		int	reventcnt = 0;
+		int i, reventcnt = 0;
 
 		for (i = 0; i < nfds; i++) {
 			if (pollfdp[i].fd < 0) {
@@ -638,6 +703,8 @@
 		}
 		ASSERT(fdcnt == reventcnt);
 	} else {
+		int i;
+
 		for (i = 0; i < nfds; i++) {
 			ASSERT(pollfdp[i].revents == 0);
 		}
@@ -647,52 +714,6 @@
 	return (fdcnt);
 }
 
-/*
- * This is the system call trap that poll(),
- * select() and pselect() are built upon.
- * It is a private interface between libc and the kernel.
- */
-int
-pollsys(pollfd_t *fds, nfds_t nfds, timespec_t *timeoutp, sigset_t *setp)
-{
-	timespec_t ts;
-	timespec_t *tsp;
-	sigset_t set;
-	k_sigset_t kset;
-	k_sigset_t *ksetp;
-	model_t datamodel = get_udatamodel();
-
-	if (timeoutp == NULL)
-		tsp = NULL;
-	else {
-		if (datamodel == DATAMODEL_NATIVE) {
-			if (copyin(timeoutp, &ts, sizeof (ts)))
-				return (set_errno(EFAULT));
-		} else {
-			timespec32_t ts32;
-
-			if (copyin(timeoutp, &ts32, sizeof (ts32)))
-				return (set_errno(EFAULT));
-			TIMESPEC32_TO_TIMESPEC(&ts, &ts32)
-		}
-
-		if (itimerspecfix(&ts))
-			return (set_errno(EINVAL));
-		tsp = &ts;
-	}
-
-	if (setp == NULL)
-		ksetp = NULL;
-	else {
-		if (copyin(setp, &set, sizeof (set)))
-			return (set_errno(EFAULT));
-		sigutok(&set, &kset);
-		ksetp = &kset;
-	}
-
-	return (poll_common(fds, nfds, tsp, ksetp));
-}
-
 /*
  * Clean up any state left around by poll(2). Called when a thread exits.
  */
usr/src/uts/common/syscall/stat.c
--- illumos-omnios/usr/src/uts/common/syscall/stat.c    Tue Jul 21 14:14:29 2015
+++ illumos-joyent/usr/src/uts/common/syscall/stat.c    Mon Jan 18 10:41:57 2016
@@ -61,7 +61,7 @@
  * to VOP_GETATTR
  */
 
-static int
+int
 cstatat_getvp(int fd, char *name, int follow, vnode_t **vp, cred_t **cred)
 {
        vnode_t *startvp;
usr/src/uts/common/vm/anon.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/vm/anon.h	Tue Jul 21 14:14:29 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/vm/anon.h	Wed Jun 17 17:43:44 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 1986, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
@@ -390,7 +391,8 @@
 		    uint_t, struct vpage [], struct cred *);
 extern void	anon_free(struct anon_hdr *, ulong_t, size_t);
 extern void	anon_free_pages(struct anon_hdr *, ulong_t, size_t, uint_t);
-extern void	anon_disclaim(struct anon_map *, ulong_t, size_t);
+extern int	anon_disclaim(struct anon_map *,
+		    ulong_t, size_t, uint_t, pgcnt_t *);
 extern int	anon_getpage(struct anon **, uint_t *, struct page **,
 		    size_t, struct seg *, caddr_t, enum seg_rw, struct cred *);
 extern int	swap_getconpage(struct vnode *, u_offset_t, size_t,
usr/src/uts/common/vm/seg_spt.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/vm/seg_spt.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/vm/seg_spt.c	Wed Jan  6 14:59:25 2016
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 #include <sys/param.h>
@@ -2880,7 +2881,7 @@
 
 	ASSERT(seg->s_as && AS_LOCK_HELD(seg->s_as));
 
-	if (behav == MADV_FREE) {
+	if (behav == MADV_FREE || behav == MADV_PURGE) {
 		if ((sptd->spt_flags & SHM_PAGEABLE) == 0)
 			return (0);
 
@@ -2891,7 +2892,7 @@
 		if ((ppa = sptd->spt_ppa) == NULL) {
 			mutex_exit(&sptd->spt_lock);
 			ANON_LOCK_ENTER(&amp->a_rwlock, RW_READER);
-			anon_disclaim(amp, pg_idx, len);
+			(void) anon_disclaim(amp, pg_idx, len, behav, NULL);
 			ANON_LOCK_EXIT(&amp->a_rwlock);
 			return (0);
 		}
@@ -2949,7 +2950,7 @@
 		}
 
 		ANON_LOCK_ENTER(&amp->a_rwlock, RW_READER);
-		anon_disclaim(amp, pg_idx, len);
+		(void) anon_disclaim(amp, pg_idx, len, behav, NULL);
 		ANON_LOCK_EXIT(&amp->a_rwlock);
 	} else if (lgrp_optimizations() && (behav == MADV_ACCESS_LWP ||
 	    behav == MADV_ACCESS_MANY || behav == MADV_ACCESS_DEFAULT)) {
usr/src/uts/common/vm/seg_vn.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/vm/seg_vn.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/vm/seg_vn.c	Wed Jan  6 14:59:25 2016
@@ -540,6 +540,7 @@
 int
 segvn_create(struct seg *seg, void *argsp)
 {
+	extern lgrp_mem_policy_t lgrp_mem_default_policy;
 	struct segvn_crargs *a = (struct segvn_crargs *)argsp;
 	struct segvn_data *svd;
 	size_t swresv = 0;
@@ -547,7 +548,7 @@
 	struct anon_map *amp;
 	int error = 0;
 	size_t pgsz;
-	lgrp_mem_policy_t mpolicy = LGRP_MEM_POLICY_DEFAULT;
+	lgrp_mem_policy_t mpolicy = lgrp_mem_default_policy;
 	int use_rgn = 0;
 	int trok = 0;
 
@@ -694,7 +695,6 @@
 		struct segvn_data *psvd, *nsvd;
 		lgrp_mem_policy_t ppolicy, npolicy;
 		uint_t	lgrp_mem_policy_flags = 0;
-		extern lgrp_mem_policy_t lgrp_mem_default_policy;
 
 		/*
 		 * Memory policy flags (lgrp_mem_policy_flags) is valid when
@@ -7329,7 +7329,8 @@
 	vpp = svd->vpage;
 	offset = svd->offset + (uintptr_t)(addr - seg->s_base);
 	bflags = ((flags & MS_ASYNC) ? B_ASYNC : 0) |
-	    ((flags & MS_INVALIDATE) ? B_INVAL : 0);
+	    ((flags & MS_INVALIDATE) ? B_INVAL : 0) |
+	    ((flags & MS_INVALCURPROC) ? (B_INVALCURONLY | B_INVAL) : 0);
 
 	if (attr) {
 		pageprot = attr & ~(SHARED|PRIVATE);
@@ -7354,11 +7355,11 @@
 			vpp = &svd->vpage[seg_page(seg, addr)];
 
 	} else if (svd->vp && svd->amp == NULL &&
-	    (flags & MS_INVALIDATE) == 0) {
+	    (flags & (MS_INVALIDATE | MS_INVALCURPROC)) == 0) {
 
 		/*
-		 * No attributes, no anonymous pages and MS_INVALIDATE flag
-		 * is not on, just use one big request.
+		 * No attributes, no anonymous pages and MS_INVAL* flags
+		 * are not on, just use one big request.
 		 */
 		err = VOP_PUTPAGE(svd->vp, (offset_t)offset, len,
 		    bflags, svd->cred, NULL);
@@ -7410,7 +7411,7 @@
 		 * might race in and lock the page after we unlock and before
 		 * we do the PUTPAGE, then PUTPAGE simply does nothing.
 		 */
-		if (flags & MS_INVALIDATE) {
+		if (flags & (MS_INVALIDATE | MS_INVALCURPROC)) {
 			if ((pp = page_lookup(vp, off, SE_SHARED)) != NULL) {
 				if (pp->p_lckcnt != 0 || pp->p_cowcnt != 0) {
 					page_unlock(pp);
@@ -8064,7 +8065,7 @@
 
 /*
  * Set advice from user for specified pages
- * There are 9 types of advice:
+ * There are 10 types of advice:
  *	MADV_NORMAL	- Normal (default) behavior (whatever that is)
  *	MADV_RANDOM	- Random page references
  *				do not allow readahead or 'klustering'
@@ -8078,6 +8079,7 @@
  *	MADV_ACCESS_DEFAULT- Default access
  *	MADV_ACCESS_LWP	- Next LWP will access heavily
  *	MADV_ACCESS_MANY- Many LWPs or processes will access heavily
+ *	MADV_PURGE	- Contents will be immediately discarded
  */
 static int
 segvn_advise(struct seg *seg, caddr_t addr, size_t len, uint_t behav)
@@ -8096,10 +8098,10 @@
 	ASSERT(seg->s_as && AS_LOCK_HELD(seg->s_as));
 
 	/*
-	 * In case of MADV_FREE, we won't be modifying any segment private
-	 * data structures; so, we only need to grab READER's lock
+	 * In case of MADV_FREE/MADV_PURGE, we won't be modifying any segment
+	 * private data structures; so, we only need to grab READER's lock
 	 */
-	if (behav != MADV_FREE) {
+	if (behav != MADV_FREE && behav != MADV_PURGE) {
 		SEGVN_LOCK_ENTER(seg->s_as, &svd->lock, RW_WRITER);
 		if (svd->tr_state != SEGVN_TR_OFF) {
 			SEGVN_LOCK_EXIT(seg->s_as, &svd->lock);
@@ -8175,27 +8177,65 @@
 
 	amp = svd->amp;
 	vp = svd->vp;
-	if (behav == MADV_FREE) {
-		/*
-		 * MADV_FREE is not supported for segments with
-		 * underlying object; if anonmap is NULL, anon slots
-		 * are not yet populated and there is nothing for
-		 * us to do. As MADV_FREE is advisory, we don't
-		 * return error in either case.
-		 */
-		if (vp != NULL || amp == NULL) {
+	if (behav == MADV_FREE || behav == MADV_PURGE) {
+		pgcnt_t purged;
+
+		if (behav == MADV_FREE && (vp != NULL || amp == NULL)) {
+			/*
+			 * MADV_FREE is not supported for segments with an
+			 * underlying object; if anonmap is NULL, anon slots
+			 * are not yet populated and there is nothing for us
+			 * to do. As MADV_FREE is advisory, we don't return an
+			 * error in either case.
+			 */
 			SEGVN_LOCK_EXIT(seg->s_as, &svd->lock);
 			return (0);
 		}
 
+		if (amp == NULL) {
+			/*
+			 * If we're here with a NULL anonmap, it's because we
+			 * are doing a MADV_PURGE.  We have nothing to do, but
+			 * because MADV_PURGE isn't merely advisory, we return
+			 * an error in this case.
+			 */
+			SEGVN_LOCK_EXIT(seg->s_as, &svd->lock);
+			return (EBUSY);
+		}
+
 		segvn_purge(seg);
 
 		page = seg_page(seg, addr);
 		ANON_LOCK_ENTER(&amp->a_rwlock, RW_READER);
-		anon_disclaim(amp, svd->anon_index + page, len);
+		err = anon_disclaim(amp,
+		    svd->anon_index + page, len, behav, &purged);
+
+		if (purged != 0 && (svd->flags & MAP_NORESERVE)) {
+			/*
+			 * If we purged pages on a MAP_NORESERVE mapping, we
+			 * need to be sure to now unreserve our reserved swap.
+			 * (We use the atomic operations to manipulate our
+			 * segment and address space counters because we only
+			 * have the corresponding locks held as reader, not
+			 * writer.)
+			 */
+			ssize_t bytes = ptob(purged);
+
+			anon_unresv_zone(bytes, seg->s_as->a_proc->p_zone);
+			atomic_add_long(&svd->swresv, -bytes);
+			atomic_add_long(&seg->s_as->a_resvsize, -bytes);
+		}
+
 		ANON_LOCK_EXIT(&amp->a_rwlock);
 		SEGVN_LOCK_EXIT(seg->s_as, &svd->lock);
-		return (0);
+
+		/*
+		 * MADV_PURGE and MADV_FREE differ in their return semantics:
+		 * because MADV_PURGE is designed to be bug-for-bug compatible
+		 * with its clumsy Linux forebear, it will fail where MADV_FREE
+		 * does not.
+		 */
+		return (behav == MADV_PURGE ? err : 0);
 	}
 
 	/*
@@ -8300,6 +8340,7 @@
 		case MADV_WILLNEED:	/* handled in memcntl */
 		case MADV_DONTNEED:	/* handled in memcntl */
 		case MADV_FREE:		/* handled above */
+		case MADV_PURGE:	/* handled above */
 			break;
 		default:
 			err = EINVAL;
@@ -8535,6 +8576,7 @@
 		case MADV_WILLNEED:	/* handled in memcntl */
 		case MADV_DONTNEED:	/* handled in memcntl */
 		case MADV_FREE:		/* handled above */
+		case MADV_PURGE:	/* handled above */
 			break;
 		default:
 			err = EINVAL;
usr/src/uts/common/vm/vm_anon.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/vm/vm_anon.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/vm/vm_anon.c	Wed Jun 17 17:43:44 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 1986, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
@@ -787,13 +788,21 @@
 	pgcnt_t pswap_pages = 0;
 	proc_t *p = curproc;
 
-	if (zone != NULL && takemem) {
+	if (zone != NULL) {
 		/* test zone.max-swap resource control */
 		mutex_enter(&p->p_lock);
 		if (rctl_incr_swap(p, zone, ptob(npages)) != 0) {
 			mutex_exit(&p->p_lock);
+
+			if (takemem)
+				atomic_add_64(&zone->zone_anon_alloc_fail, 1);
+
 			return (0);
 		}
+
+		if (!takemem)
+			rctl_decr_swap(zone, ptob(npages));
+
 		mutex_exit(&p->p_lock);
 	}
 	mutex_enter(&anoninfo_lock);
@@ -1660,8 +1669,9 @@
 /*
  * Make anonymous pages discardable
  */
-void
-anon_disclaim(struct anon_map *amp, ulong_t index, size_t size)
+int
+anon_disclaim(struct anon_map *amp, ulong_t index, size_t size,
+    uint_t behav, pgcnt_t *purged)
 {
 	spgcnt_t npages = btopr(size);
 	struct anon *ap;
@@ -1669,11 +1679,13 @@
 	anoff_t off;
 	page_t *pp, *root_pp;
 	kmutex_t *ahm;
-	pgcnt_t pgcnt;
+	pgcnt_t pgcnt, npurged = 0;
 	ulong_t old_idx, idx, i;
 	struct anon_hdr *ahp = amp->ahp;
 	anon_sync_obj_t cookie;
+	int err = 0;
 
+	VERIFY(behav == MADV_FREE || behav == MADV_PURGE);
 	ASSERT(RW_READ_HELD(&amp->a_rwlock));
 	pgcnt = 1;
 	for (; npages > 0; index = (pgcnt == 1) ? index + 1 :
@@ -1721,6 +1733,7 @@
 			page_unlock(pp);
 			segadvstat.MADV_FREE_miss.value.ul++;
 			anon_array_exit(&cookie);
+			err = EBUSY;
 			continue;
 		}
 
@@ -1738,6 +1751,15 @@
 			continue;
 		}
 
+		if (behav == MADV_PURGE && pp->p_szc != 0) {
+			/*
+			 * If we're purging and we have a large page, simplify
+			 * things a bit by demoting ourselves into the base
+			 * page case.
+			 */
+			(void) page_try_demote_pages(pp);
+		}
+
 		if (pp->p_szc == 0) {
 			pgcnt = 1;
 
@@ -1750,7 +1772,27 @@
 				ap->an_pvp = NULL;
 				ap->an_poff = 0;
 			}
-			mutex_exit(ahm);
+
+			if (behav == MADV_PURGE) {
+				/*
+				 * If we're purging (instead of merely freeing),
+				 * rip out this anon structure entirely to
+				 * assure that any subsequent fault pulls from
+				 * the backing vnode (if any).
+				 */
+				if (--ap->an_refcnt == 0)
+					anon_rmhash(ap);
+
+				mutex_exit(ahm);
+				(void) anon_set_ptr(ahp, index,
+				    NULL, ANON_SLEEP);
+				npurged++;
+				ANI_ADD(1);
+				kmem_cache_free(anon_cache, ap);
+			} else {
+				mutex_exit(ahm);
+			}
+
 			segadvstat.MADV_FREE_hit.value.ul++;
 
 			/*
@@ -1759,7 +1801,9 @@
 			 */
 			(void) hat_pageunload(pp, HAT_FORCE_PGUNLOAD);
 			/*LINTED: constant in conditional context */
-			VN_DISPOSE(pp, B_FREE, 0, kcred);
+			VN_DISPOSE(pp,
+			    behav == MADV_FREE ? B_FREE : B_INVAL, 0, kcred);
+
 			anon_array_exit(&cookie);
 			continue;
 		}
@@ -1771,6 +1815,7 @@
 				page_unlock(pp);
 				segadvstat.MADV_FREE_miss.value.ul++;
 				anon_array_exit(&cookie);
+				err = EBUSY;
 				continue;
 			} else {
 				pgcnt = 1;
@@ -1842,6 +1887,11 @@
 			page_unlock(pp);
 		anon_array_exit(&cookie);
 	}
+
+	if (purged != NULL)
+		*purged = npurged;
+
+	return (err);
 }
 
 /*
usr/src/uts/common/vm/vm_usage.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/common/vm/vm_usage.c	Tue Jan  5 17:20:38 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/common/vm/vm_usage.c	Wed Jan  6 14:59:25 2016
@@ -25,6 +25,10 @@
  */
 
 /*
+ * Copyright 2016, Joyent, Inc.
+ */
+
+/*
  * vm_usage
  *
  * This file implements the getvmusage() private system call.
@@ -114,7 +118,7 @@
  *	For accurate counting of map-shared and COW-shared pages.
  *
  *    - visited private anons (refcnt > 1) for each collective.
- *	(entity->vme_anon_hash)
+ *	(entity->vme_anon)
  *	For accurate counting of COW-shared pages.
  *
  * The common accounting structure is the vmu_entity_t, which represents
@@ -152,6 +156,7 @@
 #include <sys/vm_usage.h>
 #include <sys/zone.h>
 #include <sys/sunddi.h>
+#include <sys/sysmacros.h>
 #include <sys/avl.h>
 #include <vm/anon.h>
 #include <vm/as.h>
@@ -199,6 +204,14 @@
 } vmu_object_t;
 
 /*
+ * Node for tree of visited COW anons.
+ */
+typedef struct vmu_anon {
+	avl_node_t vma_node;
+	uintptr_t vma_addr;
+} vmu_anon_t;
+
+/*
  * Entity by which to count results.
  *
  * The entity structure keeps the current rss/swap counts for each entity
@@ -221,7 +234,7 @@
 	struct vmu_entity *vme_next_calc;
 	mod_hash_t	*vme_vnode_hash; /* vnodes visited for entity */
 	mod_hash_t	*vme_amp_hash;	 /* shared amps visited for entity */
-	mod_hash_t	*vme_anon_hash;	 /* COW anons visited for entity */
+	avl_tree_t	vme_anon;	 /* COW anons visited for entity */
 	vmusage_t	vme_result;	 /* identifies entity and results */
 } vmu_entity_t;
 
@@ -324,6 +337,23 @@
 }
 
 /*
+ * Comparison routine for our AVL tree of anon structures.
+ */
+static int
+vmu_anon_cmp(const void *lhs, const void *rhs)
+{
+	const vmu_anon_t *l = lhs, *r = rhs;
+
+	if (l->vma_addr == r->vma_addr)
+		return (0);
+
+	if (l->vma_addr < r->vma_addr)
+		return (-1);
+
+	return (1);
+}
+
+/*
  * Save a bound on the free list.
  */
 static void
@@ -363,14 +393,19 @@
 vmu_free_entity(mod_hash_val_t val)
 {
 	vmu_entity_t *entity = (vmu_entity_t *)val;
+	vmu_anon_t *anon;
+	void *cookie = NULL;
 
 	if (entity->vme_vnode_hash != NULL)
 		i_mod_hash_clear_nosync(entity->vme_vnode_hash);
 	if (entity->vme_amp_hash != NULL)
 		i_mod_hash_clear_nosync(entity->vme_amp_hash);
-	if (entity->vme_anon_hash != NULL)
-		i_mod_hash_clear_nosync(entity->vme_anon_hash);
 
+	while ((anon = avl_destroy_nodes(&entity->vme_anon, &cookie)) != NULL)
+		kmem_free(anon, sizeof (vmu_anon_t));
+
+	avl_destroy(&entity->vme_anon);
+
 	entity->vme_next = vmu_data.vmu_free_entities;
 	vmu_data.vmu_free_entities = entity;
 }
@@ -485,11 +520,11 @@
 		    "vmusage amp hash", VMUSAGE_HASH_SIZE, vmu_free_object,
 		    sizeof (struct anon_map));
 
-	if (entity->vme_anon_hash == NULL)
-		entity->vme_anon_hash = mod_hash_create_ptrhash(
-		    "vmusage anon hash", VMUSAGE_HASH_SIZE,
-		    mod_hash_null_valdtor, sizeof (struct anon));
+	VERIFY(avl_first(&entity->vme_anon) == NULL);
 
+	avl_create(&entity->vme_anon, vmu_anon_cmp, sizeof (struct vmu_anon),
+	    offsetof(struct vmu_anon, vma_node));
+
 	entity->vme_next = vmu_data.vmu_entities;
 	vmu_data.vmu_entities = entity;
 	vmu_data.vmu_nentities++;
@@ -518,7 +553,8 @@
 
 	zone->vmz_id = id;
 
-	if ((vmu_data.vmu_calc_flags & (VMUSAGE_ZONE | VMUSAGE_ALL_ZONES)) != 0)
+	if ((vmu_data.vmu_calc_flags &
+	    (VMUSAGE_ZONE | VMUSAGE_ALL_ZONES | VMUSAGE_A_ZONE)) != 0)
 		zone->vmz_zone = vmu_alloc_entity(id, VMUSAGE_ZONE, id);
 
 	if ((vmu_data.vmu_calc_flags & (VMUSAGE_PROJECTS |
@@ -613,21 +649,19 @@
 }
 
 static int
-vmu_find_insert_anon(mod_hash_t *hash, caddr_t key)
+vmu_find_insert_anon(vmu_entity_t *entity, void *key)
 {
-	int ret;
-	caddr_t val;
+	vmu_anon_t anon, *ap;
 
-	ret = i_mod_hash_find_nosync(hash, (mod_hash_key_t)key,
-	    (mod_hash_val_t *)&val);
+	anon.vma_addr = (uintptr_t)key;
 
-	if (ret == 0)
+	if (avl_find(&entity->vme_anon, &anon, NULL) != NULL)
 		return (0);
 
-	ret = i_mod_hash_insert_nosync(hash, (mod_hash_key_t)key,
-	    (mod_hash_val_t)key, (mod_hash_hndl_t)0);
+	ap = kmem_alloc(sizeof (vmu_anon_t), KM_SLEEP);
+	ap->vma_addr = (uintptr_t)key;
 
-	ASSERT(ret == 0);
+	avl_add(&entity->vme_anon, ap);
 
 	return (1);
 }
@@ -918,6 +952,8 @@
 			next = AVL_NEXT(tree, next);
 			continue;
 		}
+
+		ASSERT(next->vmb_type == VMUSAGE_BOUND_UNKNOWN);
 		bound_type = next->vmb_type;
 		index = next->vmb_start;
 		while (index <= next->vmb_end) {
@@ -937,7 +973,10 @@
 
 			if (ap != NULL && vn != NULL && vn->v_pages != NULL &&
 			    (page = page_exists(vn, off)) != NULL) {
-				page_type = VMUSAGE_BOUND_INCORE;
+				if (PP_ISFREE(page))
+					page_type = VMUSAGE_BOUND_NOT_INCORE;
+				else
+					page_type = VMUSAGE_BOUND_INCORE;
 				if (page->p_szc > 0) {
 					pgcnt = page_get_pagecnt(page->p_szc);
 					pgshft = page_get_shift(page->p_szc);
@@ -947,8 +986,10 @@
 			} else {
 				page_type = VMUSAGE_BOUND_NOT_INCORE;
 			}
+
 			if (bound_type == VMUSAGE_BOUND_UNKNOWN) {
 				next->vmb_type = page_type;
+				bound_type = page_type;
 			} else if (next->vmb_type != page_type) {
 				/*
 				 * If current bound type does not match page
@@ -1009,6 +1050,7 @@
 			continue;
 		}
 
+		ASSERT(next->vmb_type == VMUSAGE_BOUND_UNKNOWN);
 		bound_type = next->vmb_type;
 		index = next->vmb_start;
 		while (index <= next->vmb_end) {
@@ -1024,7 +1066,10 @@
 
 			if (vnode->v_pages != NULL &&
 			    (page = page_exists(vnode, ptob(index))) != NULL) {
-				page_type = VMUSAGE_BOUND_INCORE;
+				if (PP_ISFREE(page))
+					page_type = VMUSAGE_BOUND_NOT_INCORE;
+				else
+					page_type = VMUSAGE_BOUND_INCORE;
 				if (page->p_szc > 0) {
 					pgcnt = page_get_pagecnt(page->p_szc);
 					pgshft = page_get_shift(page->p_szc);
@@ -1034,8 +1079,10 @@
 			} else {
 				page_type = VMUSAGE_BOUND_NOT_INCORE;
 			}
+
 			if (bound_type == VMUSAGE_BOUND_UNKNOWN) {
 				next->vmb_type = page_type;
+				bound_type = page_type;
 			} else if (next->vmb_type != page_type) {
 				/*
 				 * If current bound type does not match page
@@ -1304,6 +1351,12 @@
 			}
 
 			/*
+			 * Pages on the free list aren't counted for the rss.
+			 */
+			if (PP_ISFREE(page))
+				continue;
+
+			/*
 			 * Assume anon structs with a refcnt
 			 * of 1 are not COW shared, so there
 			 * is no reason to track them per entity.
@@ -1320,8 +1373,7 @@
 				 * Track COW anons per entity so
 				 * they are not double counted.
 				 */
-				if (vmu_find_insert_anon(entity->vme_anon_hash,
-				    (caddr_t)ap) == 0)
+				if (vmu_find_insert_anon(entity, ap) == 0)
 					continue;
 
 				result->vmu_rss_all += (pgcnt << PAGESHIFT);
@@ -1461,8 +1513,9 @@
 		entities = tmp;
 	}
 	if (vmu_data.vmu_calc_flags &
-	    (VMUSAGE_ZONE | VMUSAGE_ALL_ZONES | VMUSAGE_PROJECTS |
-	    VMUSAGE_ALL_PROJECTS | VMUSAGE_TASKS | VMUSAGE_ALL_TASKS |
+	    (VMUSAGE_ZONE | VMUSAGE_ALL_ZONES | VMUSAGE_A_ZONE |
+	    VMUSAGE_PROJECTS | VMUSAGE_ALL_PROJECTS |
+	    VMUSAGE_TASKS | VMUSAGE_ALL_TASKS |
 	    VMUSAGE_RUSERS | VMUSAGE_ALL_RUSERS | VMUSAGE_EUSERS |
 	    VMUSAGE_ALL_EUSERS)) {
 		ret = i_mod_hash_find_nosync(vmu_data.vmu_zones_hash,
@@ -1594,8 +1647,7 @@
 			mod_hash_destroy_hash(te->vme_vnode_hash);
 		if (te->vme_amp_hash != NULL)
 			mod_hash_destroy_hash(te->vme_amp_hash);
-		if (te->vme_anon_hash != NULL)
-			mod_hash_destroy_hash(te->vme_anon_hash);
+		VERIFY(avl_first(&te->vme_anon) == NULL);
 		kmem_free(te, sizeof (vmu_entity_t));
 	}
 	while (vmu_data.vmu_free_zones != NULL) {
@@ -1739,12 +1791,34 @@
 }
 
 /*
+ * When new data is calculated, update the phys_mem rctl usage value in the
+ * zones.
+ */
+static void
+vmu_update_zone_rctls(vmu_cache_t *cache)
+{
+	vmusage_t	*rp;
+	size_t		i = 0;
+	zone_t		*zp;
+
+	for (rp = cache->vmc_results; i < cache->vmc_nresults; rp++, i++) {
+		if (rp->vmu_type == VMUSAGE_ZONE &&
+		    rp->vmu_zoneid != ALL_ZONES) {
+			if ((zp = zone_find_by_id(rp->vmu_zoneid)) != NULL) {
+				zp->zone_phys_mem = rp->vmu_rss_all;
+				zone_rele(zp);
+			}
+		}
+	}
+}
+
+/*
  * Copy out the cached results to a caller.  Inspect the callers flags
  * and zone to determine which cached results should be copied.
  */
 static int
 vmu_copyout_results(vmu_cache_t *cache, vmusage_t *buf, size_t *nres,
-    uint_t flags, int cpflg)
+    uint_t flags, id_t req_zone_id, int cpflg)
 {
 	vmusage_t *result, *out_result;
 	vmusage_t dummy;
@@ -1763,7 +1837,7 @@
 	/* figure out what results the caller is interested in. */
 	if ((flags & VMUSAGE_SYSTEM) && curproc->p_zone == global_zone)
 		types |= VMUSAGE_SYSTEM;
-	if (flags & (VMUSAGE_ZONE | VMUSAGE_ALL_ZONES))
+	if (flags & (VMUSAGE_ZONE | VMUSAGE_ALL_ZONES | VMUSAGE_A_ZONE))
 		types |= VMUSAGE_ZONE;
 	if (flags & (VMUSAGE_PROJECTS | VMUSAGE_ALL_PROJECTS |
 	    VMUSAGE_COL_PROJECTS))
@@ -1826,26 +1900,33 @@
 				continue;
 		}
 
-		/* Skip "other zone" results if not requested */
-		if (result->vmu_zoneid != curproc->p_zone->zone_id) {
-			if (result->vmu_type == VMUSAGE_ZONE &&
-			    (flags & VMUSAGE_ALL_ZONES) == 0)
+		if (result->vmu_type == VMUSAGE_ZONE &&
+		    flags & VMUSAGE_A_ZONE) {
+			/* Skip non-requested zone results */
+			if (result->vmu_zoneid != req_zone_id)
 				continue;
-			if (result->vmu_type == VMUSAGE_PROJECTS &&
-			    (flags & (VMUSAGE_ALL_PROJECTS |
-			    VMUSAGE_COL_PROJECTS)) == 0)
-				continue;
-			if (result->vmu_type == VMUSAGE_TASKS &&
-			    (flags & VMUSAGE_ALL_TASKS) == 0)
-				continue;
-			if (result->vmu_type == VMUSAGE_RUSERS &&
-			    (flags & (VMUSAGE_ALL_RUSERS |
-			    VMUSAGE_COL_RUSERS)) == 0)
-				continue;
-			if (result->vmu_type == VMUSAGE_EUSERS &&
-			    (flags & (VMUSAGE_ALL_EUSERS |
-			    VMUSAGE_COL_EUSERS)) == 0)
-				continue;
+		} else {
+			/* Skip "other zone" results if not requested */
+			if (result->vmu_zoneid != curproc->p_zone->zone_id) {
+				if (result->vmu_type == VMUSAGE_ZONE &&
+				    (flags & VMUSAGE_ALL_ZONES) == 0)
+					continue;
+				if (result->vmu_type == VMUSAGE_PROJECTS &&
+				    (flags & (VMUSAGE_ALL_PROJECTS |
+				    VMUSAGE_COL_PROJECTS)) == 0)
+					continue;
+				if (result->vmu_type == VMUSAGE_TASKS &&
+				    (flags & VMUSAGE_ALL_TASKS) == 0)
+					continue;
+				if (result->vmu_type == VMUSAGE_RUSERS &&
+				    (flags & (VMUSAGE_ALL_RUSERS |
+				    VMUSAGE_COL_RUSERS)) == 0)
+					continue;
+				if (result->vmu_type == VMUSAGE_EUSERS &&
+				    (flags & (VMUSAGE_ALL_EUSERS |
+				    VMUSAGE_COL_EUSERS)) == 0)
+					continue;
+			}
 		}
 		count++;
 		if (out_result != NULL) {
@@ -1901,10 +1982,12 @@
 	int cacherecent = 0;
 	hrtime_t now;
 	uint_t flags_orig;
+	id_t req_zone_id;
 
 	/*
 	 * Non-global zones cannot request system wide and/or collated
-	 * results, or the system result, so munge the flags accordingly.
+	 * results, or the system result, or usage of another zone, so munge
+	 * the flags accordingly.
 	 */
 	flags_orig = flags;
 	if (curproc->p_zone != global_zone) {
@@ -1924,6 +2007,10 @@
 			flags &= ~VMUSAGE_SYSTEM;
 			flags |= VMUSAGE_ZONE;
 		}
+		if (flags & VMUSAGE_A_ZONE) {
+			flags &= ~VMUSAGE_A_ZONE;
+			flags |= VMUSAGE_ZONE;
+		}
 	}
 
 	/* Check for unknown flags */
@@ -1934,6 +2021,21 @@
 	if ((flags & VMUSAGE_MASK) == 0)
 		return (set_errno(EINVAL));
 
+	/* If requesting results for a specific zone, get the zone ID */
+	if (flags & VMUSAGE_A_ZONE) {
+		size_t bufsize;
+		vmusage_t zreq;
+
+		if (ddi_copyin((caddr_t)nres, &bufsize, sizeof (size_t), cpflg))
+			return (set_errno(EFAULT));
+		/* Requested zone ID is passed in buf, so 0 len not allowed */
+		if (bufsize == 0)
+			return (set_errno(EINVAL));
+		if (ddi_copyin((caddr_t)buf, &zreq, sizeof (vmusage_t), cpflg))
+			return (set_errno(EFAULT));
+		req_zone_id = zreq.vmu_id;
+	}
+
 	mutex_enter(&vmu_data.vmu_lock);
 	now = gethrtime();
 
@@ -1953,7 +2055,7 @@
 			mutex_exit(&vmu_data.vmu_lock);
 
 			ret = vmu_copyout_results(cache, buf, nres, flags_orig,
-			    cpflg);
+			    req_zone_id, cpflg);
 			mutex_enter(&vmu_data.vmu_lock);
 			vmu_cache_rele(cache);
 			if (vmu_data.vmu_pending_waiters > 0)
@@ -2009,8 +2111,11 @@
 
 		mutex_exit(&vmu_data.vmu_lock);
 
+		/* update zone's phys. mem. rctl usage */
+		vmu_update_zone_rctls(cache);
 		/* copy cache */
-		ret = vmu_copyout_results(cache, buf, nres, flags_orig, cpflg);
+		ret = vmu_copyout_results(cache, buf, nres, flags_orig,
+		    req_zone_id, cpflg);
 		mutex_enter(&vmu_data.vmu_lock);
 		vmu_cache_rele(cache);
 		mutex_exit(&vmu_data.vmu_lock);
@@ -2030,3 +2135,185 @@
 	vmu_data.vmu_pending_waiters--;
 	goto start;
 }
+
+#if defined(__x86)
+/*
+ * Attempt to invalidate all of the pages in the mapping for the given process.
+ */
+static void
+map_inval(proc_t *p, struct seg *seg, caddr_t addr, size_t size)
+{
+	page_t		*pp;
+	size_t		psize;
+	u_offset_t	off;
+	caddr_t		eaddr;
+	struct vnode	*vp;
+	struct segvn_data *svd;
+	struct hat	*victim_hat;
+
+	ASSERT((addr + size) <= (seg->s_base + seg->s_size));
+
+	victim_hat = p->p_as->a_hat;
+	svd = (struct segvn_data *)seg->s_data;
+	vp = svd->vp;
+	psize = page_get_pagesize(seg->s_szc);
+
+	off = svd->offset + (uintptr_t)(addr - seg->s_base);
+
+	for (eaddr = addr + size; addr < eaddr; addr += psize, off += psize) {
+		pp = page_lookup_nowait(vp, off, SE_SHARED);
+
+		if (pp != NULL) {
+			/* following logic based on pvn_getdirty() */
+
+			if (pp->p_lckcnt != 0 || pp->p_cowcnt != 0) {
+				page_unlock(pp);
+				continue;
+			}
+
+			page_io_lock(pp);
+			hat_page_inval(pp, 0, victim_hat);
+			page_io_unlock(pp);
+
+			/*
+			 * For B_INVALCURONLY-style handling we let
+			 * page_release call VN_DISPOSE if no one else is using
+			 * the page.
+			 *
+			 * A hat_ismod() check would be useless because:
+			 * (1) we are not be holding SE_EXCL lock
+			 * (2) we've not unloaded _all_ translations
+			 *
+			 * Let page_release() do the heavy-lifting.
+			 */
+			(void) page_release(pp, 1);
+		}
+	}
+}
+
+/*
+ * vm_map_inval()
+ *
+ * Invalidate as many pages as possible within the given mapping for the given
+ * process. addr is expected to be the base address of the mapping and size is
+ * the length of the mapping. In some cases a mapping will encompass an
+ * entire segment, but at least for anon or stack mappings, these will be
+ * regions within a single large segment. Thus, the invalidation is oriented
+ * around a single mapping and not an entire segment.
+ *
+ * SPARC sfmmu hat does not support HAT_CURPROC_PGUNLOAD-style handling so
+ * this code is only applicable to x86.
+ */
+int
+vm_map_inval(pid_t pid, caddr_t addr, size_t size)
+{
+	int ret;
+	int error = 0;
+	proc_t *p;		/* target proc */
+	struct as *as;		/* target proc's address space */
+	struct seg *seg;	/* working segment */
+
+	if (curproc->p_zone != global_zone || crgetruid(curproc->p_cred) != 0)
+		return (set_errno(EPERM));
+
+	/* If not a valid mapping address, return an error */
+	if ((caddr_t)((uintptr_t)addr & (uintptr_t)PAGEMASK) != addr)
+		return (set_errno(EINVAL));
+
+again:
+	mutex_enter(&pidlock);
+	p = prfind(pid);
+	if (p == NULL) {
+		mutex_exit(&pidlock);
+		return (set_errno(ESRCH));
+	}
+
+	mutex_enter(&p->p_lock);
+	mutex_exit(&pidlock);
+
+	if (panicstr != NULL) {
+		mutex_exit(&p->p_lock);
+		return (0);
+	}
+
+	as = p->p_as;
+
+	/*
+	 * Try to set P_PR_LOCK - prevents process "changing shape"
+	 * - blocks fork
+	 * - blocks sigkill
+	 * - cannot be a system proc
+	 * - must be fully created proc
+	 */
+	ret = sprtrylock_proc(p);
+	if (ret == -1) {
+		/* Process in invalid state */
+		mutex_exit(&p->p_lock);
+		return (set_errno(ESRCH));
+	}
+
+	if (ret == 1) {
+		/*
+		 * P_PR_LOCK is already set. Wait and try again. This also
+		 * drops p_lock so p may no longer be valid since the proc may
+		 * have exited.
+		 */
+		sprwaitlock_proc(p);
+		goto again;
+	}
+
+	/* P_PR_LOCK is now set */
+	mutex_exit(&p->p_lock);
+
+	AS_LOCK_ENTER(as, RW_READER);
+	if ((seg = as_segat(as, addr)) == NULL) {
+		AS_LOCK_EXIT(as);
+		mutex_enter(&p->p_lock);
+		sprunlock(p);
+		return (set_errno(ENOMEM));
+	}
+
+	/*
+	 * The invalidation behavior only makes sense for vnode-backed segments.
+	 */
+	if (seg->s_ops != &segvn_ops) {
+		AS_LOCK_EXIT(as);
+		mutex_enter(&p->p_lock);
+		sprunlock(p);
+		return (0);
+	}
+
+	/*
+	 * If the mapping is out of bounds of the segement return an error.
+	 */
+	if ((addr + size) > (seg->s_base + seg->s_size)) {
+		AS_LOCK_EXIT(as);
+		mutex_enter(&p->p_lock);
+		sprunlock(p);
+		return (set_errno(EINVAL));
+	}
+
+	/*
+	 * Don't use MS_INVALCURPROC flag here since that would eventually
+	 * initiate hat invalidation based on curthread. Since we're doing this
+	 * on behalf of a different process, that would erroneously invalidate
+	 * our own process mappings.
+	 */
+	error = SEGOP_SYNC(seg, addr, size, 0, (uint_t)MS_ASYNC);
+	if (error == 0) {
+		/*
+		 * Since we didn't invalidate during the sync above, we now
+		 * try to invalidate all of the pages in the mapping.
+		 */
+		map_inval(p, seg, addr, size);
+	}
+	AS_LOCK_EXIT(as);
+
+	mutex_enter(&p->p_lock);
+	sprunlock(p);
+
+	if (error)
+		(void) set_errno(error);
+	return (error);
+}
+#endif
usr/src/uts/i86pc/ml/offsets.in
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/ml/offsets.in	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/ml/offsets.in	Mon Dec 14 10:47:45 2015
@@ -1,6 +1,7 @@
 \
 \ Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 \ Copyright 2012 Garrett D'Amore <garrett@damore.org>.  All rights reserved.
+\ Copyright 2015 Joyent, Inc.
 \
 \ CDDL HEADER START
 \
@@ -124,6 +125,9 @@
 	_tu._ts._t_post_sys	T_POST_SYS
 	_tu._t_post_sys_ast	T_POST_SYS_AST
 	t_copyops
+#ifdef	__amd64
+	t_useracc
+#endif
 
 ctxop
 	save_op			CTXOP_SAVE
@@ -147,6 +151,8 @@
 	lwp_thread
 	lwp_procp
 	lwp_brand
+	lwp_brand_syscall
+	lwp_brand_syscall_fast
 	lwp_eosys
 	lwp_regs
 	lwp_arg
usr/src/uts/i86pc/ml/syscall_asm.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/ml/syscall_asm.s	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/ml/syscall_asm.s	Wed Jun 17 17:43:44 2015
@@ -631,8 +631,38 @@
 	sysexit
 	SET_SIZE(sys_sysenter)
 	SET_SIZE(brand_sys_sysenter)
+#endif	/* __lint */
 
+#if defined(__lint)
 /*
+ * System call via an int80.  This entry point is only used by the Linux
+ * application environment.  Unlike the sysenter path, there is no default
+ * action to take if no callback is registered for this process.
+ */
+void
+sys_int80()
+{}
+
+#else	/* __lint */
+
+	ENTRY_NP(brand_sys_int80)
+	BRAND_CALLBACK(BRAND_CB_INT80)
+
+	ALTENTRY(sys_int80)
+	/*
+	 * We hit an int80, but this process isn't of a brand with an int80
+	 * handler.  Bad process!  Make it look as if the INT failed.
+	 * Modify %eip to point before the INT, push the expected error
+	 * code and fake a GP fault.
+	 * 
+	 */
+	subl	$2, (%esp)	/* int insn 2-bytes */
+	pushl	$_CONST(_MUL(T_INT80, GATE_DESC_SIZE) + 2)
+	jmp	gptrap			/ GP fault
+	SET_SIZE(sys_int80)
+	SET_SIZE(brand_sys_int80)
+
+/*
  * Declare a uintptr_t which covers the entire pc range of syscall
  * handlers for the stack walkers that need this.
  */
usr/src/uts/i86pc/ml/syscall_asm_amd64.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/ml/syscall_asm_amd64.s	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/ml/syscall_asm_amd64.s	Mon Dec 14 10:47:45 2015
@@ -20,7 +20,7 @@
  */
 /*
  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2012, Joyent, Inc.  All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/asm_linkage.h>
@@ -503,8 +503,25 @@
 	
 	movq	T_LWP(%r15), %r14
 	ASSERT_NO_RUPDATE_PENDING(%r14)
+
 	ENABLE_INTR_FLAGS
 
+	/*
+	 * If our LWP has a branded syscall_fast handler, execute it.  A return
+	 * code of zero indicates that the handler completely processed the syscall
+	 * and we can return directly to userspace.
+	 */
+	movq	LWP_BRAND_SYSCALL_FAST(%r14), %rdi
+	testq	%rdi, %rdi
+	jz	_syscall_no_brand_fast
+	call	*%rdi
+	testl	%eax, %eax
+	jnz	_syscall_no_brand_fast
+	incq	LWP_RU_SYSC(%r14)
+	incq	%gs:CPU_STATS_SYS_SYSCALL
+	jmp	_sys_rtt
+
+_syscall_no_brand_fast:
 	MSTATE_TRANSITION(LMS_USER, LMS_SYSTEM)
 	movl	REGOFF_RAX(%rsp), %eax	/* (%rax damaged by mstate call) */
 
@@ -516,6 +533,28 @@
 
 	incq	%gs:CPU_STATS_SYS_SYSCALL
 
+	/*
+	 * If our LWP has an alternate system call handler, run that instead of
+	 * the regular system call path.
+	 */
+	movq	LWP_BRAND_SYSCALL(%r14), %rdi
+	testq	%rdi, %rdi
+	jz	_syscall_no_brand
+
+	pushq	%rax
+	subq	$8, %rsp	/* align stack for call to C */
+	call	*%rdi
+	addq	$8, %rsp
+
+	/*
+	 * If the alternate handler returns 0, we skip straight to the return to
+	 * usermode.  Otherwise, we resume regular system call processing.
+	 */
+	testl	%eax, %eax
+	popq	%rax
+	jz	_syscall_after_brand
+
+_syscall_no_brand:
 	movw	%ax, T_SYSNUM(%r15)
 	movzbl	T_PRE_SYS(%r15), %ebx
 	ORL_SYSCALLTRACE(%ebx)
@@ -550,6 +589,8 @@
 	shrq	$32, %r13	/* upper 32-bits into %edx */
 	movl	%r12d, %r12d	/* lower 32-bits into %eax */
 5:
+
+_syscall_after_brand:
 	/*
 	 * Optimistically assume that there's no post-syscall
 	 * work to do.  (This is to avoid having to call syscall_mstate()
@@ -787,6 +828,22 @@
 
 	ENABLE_INTR_FLAGS
 
+	/*
+	 * If our LWP has a branded syscall_fast handler, execute it.  A return
+	 * code of zero indicates that the handler completely processed the syscall
+	 * and we can return directly to userspace.
+	 */
+	movq	LWP_BRAND_SYSCALL_FAST(%r14), %rdi
+	testq	%rdi, %rdi
+	jz	_syscall32_no_brand_fast
+	call	*%rdi
+	testl	%eax, %eax
+	jnz	_syscall32_no_brand_fast
+	incq	LWP_RU_SYSC(%r14)
+	incq	%gs:CPU_STATS_SYS_SYSCALL
+	jmp	_sys_rtt
+
+_syscall32_no_brand_fast:
 	MSTATE_TRANSITION(LMS_USER, LMS_SYSTEM)
 	movl	REGOFF_RAX(%rsp), %eax	/* (%rax damaged by mstate call) */
 
@@ -795,11 +852,37 @@
 	incq	 %gs:CPU_STATS_SYS_SYSCALL
 
 	/*
+	 * If our lwp has an alternate system call handler, run that instead
+	 * of the regular system call path.
+	 */
+	movq	LWP_BRAND_SYSCALL(%r14), %rax
+	testq	%rax, %rax
+	jz	_syscall32_no_brand
+
+	movb	$LWP_SYS, LWP_STATE(%r14)
+	call	*%rax
+
+	/*
+	 * If the alternate handler returns 0, we skip straight to the return
+	 * to usermode.  Otherwise, we resume regular system call processing.
+	 */
+	testl	%eax, %eax
+	jz	_syscall32_after_brand
+
+_syscall32_no_brand:
+	/*
 	 * Make some space for MAXSYSARGS (currently 8) 32-bit args placed
 	 * into 64-bit (long) arg slots, maintaining 16 byte alignment.  Or
 	 * more succinctly:
 	 *
 	 *	SA(MAXSYSARGS * sizeof (long)) == 64
+	 *
+	 * Note, this space is used both to copy in the arguments from user
+	 * land, but also to as part of the old UNIX style syscall_ap() method.
+	 * syscall_entry expects that we do not change the values of this space
+	 * that we give it. However, this means that when we end up in the more
+	 * recent model of passing the arguments based on the calling
+	 * conventions, we'll need to save an additional 16 bytes of stack.
 	 */
 #define	SYS_DROP	64			/* drop for args */
 	subq	$SYS_DROP, %rsp
@@ -827,12 +910,16 @@
 	 */
 
 	movq	%rax, %rbx
-	movl	0(%rsp), %edi
-	movl	8(%rsp), %esi
-	movl	0x10(%rsp), %edx
-	movl	0x18(%rsp), %ecx
-	movl	0x20(%rsp), %r8d
-	movl	0x28(%rsp), %r9d
+	movl	0x0(%rsp), %edi		/* arg0 */
+	movl	0x8(%rsp), %esi		/* arg1 */
+	movl	0x10(%rsp), %edx	/* arg2 */
+	movl	0x38(%rsp), %eax	/* arg7 load */
+	movl	0x18(%rsp), %ecx	/* arg3 */
+	pushq	%rax			/* arg7 saved to stack */
+	movl	0x28(%rsp), %r8d	/* arg4 */
+	movl	0x38(%rsp), %eax	/* arg6 load */
+	movl	0x30(%rsp), %r9d	/* arg5 */
+	pushq	%rax			/* arg6 saved to stack */
 
 	call	*SY_CALLC(%rbx)
 
@@ -850,6 +937,8 @@
 	shrq	$32, %r13	/* upper 32-bits into %edx */
 	movl	%eax, %r12d	/* lower 32-bits into %eax */
 
+_syscall32_after_brand:
+
 	/*
 	 * Optimistically assume that there's no post-syscall
 	 * work to do.  (This is to avoid having to call syscall_mstate()
@@ -1079,15 +1168,20 @@
 	/*
 	 * Fetch the arguments copied onto the kernel stack and put
 	 * them in the right registers to invoke a C-style syscall handler.
-	 * %rax contains the handler address.
+	 * %rax contains the handler address. For the last two arguments, we
+	 * push them onto the stack -- we can't clobber the old arguments.
 	 */
 	movq	%rax, %rbx
-	movl	0(%rsp), %edi
-	movl	8(%rsp), %esi
-	movl	0x10(%rsp), %edx
-	movl	0x18(%rsp), %ecx
-	movl	0x20(%rsp), %r8d
-	movl	0x28(%rsp), %r9d
+	movl	0x0(%rsp), %edi		/* arg0 */
+	movl	0x8(%rsp), %esi		/* arg1 */
+	movl	0x10(%rsp), %edx	/* arg2 */
+	movl	0x38(%rsp), %eax	/* arg7 load */
+	movl	0x18(%rsp), %ecx	/* arg3 */
+	pushq	%rax			/* arg7 saved to stack */
+	movl	0x28(%rsp), %r8d	/* arg4 */
+	movl	0x38(%rsp), %eax	/* arg6 load */
+	movl	0x30(%rsp), %r9d	/* arg5 */
+	pushq	%rax			/* arg6 saved to stack */
 
 	call	*SY_CALLC(%rbx)
 
@@ -1159,7 +1253,75 @@
 	SET_SIZE(brand_sys_sysenter)
 
 #endif	/* __lint */
+ 
+#if defined(__lint)
+/*
+ * System call via an int80.  This entry point is only used by the Linux
+ * application environment.  Unlike the other entry points, there is no
+ * default action to take if no callback is registered for this process.
+ */
+void
+sys_int80()
+{}
 
+#else	/* __lint */
+
+	ENTRY_NP(brand_sys_int80)
+	SWAPGS				/* kernel gsbase */
+	XPV_TRAP_POP
+	call	smap_enable
+
+	/*
+	 * We first attempt to call the "b_int80" handler from the "struct
+	 * brand_mach_ops" for this brand.  If no handler function is installed
+	 * for this brand, the BRAND_CALLBACK() macro returns here and we
+	 * check the lwp for a "lwp_brand_syscall" handler.
+	 */
+	BRAND_CALLBACK(BRAND_CB_INT80, BRAND_URET_FROM_INTR_STACK())
+
+	/*
+	 * Check to see if this lwp provides "lwp_brand_syscall".  If so, we
+	 * will route this int80 through the regular system call handling path.
+	 */
+	movq	%r15, %gs:CPU_RTMP_R15
+	movq	%gs:CPU_THREAD, %r15
+	movq	T_LWP(%r15), %r15
+	movq	LWP_BRAND_SYSCALL(%r15), %r15
+	testq	%r15, %r15
+	movq	%gs:CPU_RTMP_R15, %r15
+	jnz	nopop_syscall_int
+
+	/*
+	 * The brand provided neither a "b_int80", nor a "lwp_brand_syscall"
+	 * function, and has thus opted out of handling this trap.
+	 */
+	SWAPGS				/* user gsbase */
+	jmp	nopop_int80
+
+	ENTRY_NP(sys_int80)
+	/*
+	 * We hit an int80, but this process isn't of a brand with an int80
+	 * handler.  Bad process!  Make it look as if the INT failed.
+	 * Modify %rip to point before the INT, push the expected error
+	 * code and fake a GP fault. Note on 64-bit hypervisor we need
+	 * to undo the XPV_TRAP_POP and push rcx and r11 back on the stack
+	 * because gptrap will pop them again with its own XPV_TRAP_POP.
+	 */
+	XPV_TRAP_POP
+	call	smap_enable
+nopop_int80:
+	subq	$2, (%rsp)	/* int insn 2-bytes */
+	pushq	$_CONST(_MUL(T_INT80, GATE_DESC_SIZE) + 2)
+#if defined(__xpv)
+	push	%r11
+	push	%rcx
+#endif
+	jmp	gptrap			/ GP fault
+	SET_SIZE(sys_int80)
+	SET_SIZE(brand_sys_int80)
+#endif	/* __lint */
+
+
 /*
  * This is the destination of the "int $T_SYSCALLINT" interrupt gate, used by
  * the generic i386 libc to do system calls. We do a small amount of setup
@@ -1177,6 +1339,7 @@
 	ENTRY_NP(brand_sys_syscall_int)
 	SWAPGS				/* kernel gsbase */
 	XPV_TRAP_POP
+	call	smap_enable
 	BRAND_CALLBACK(BRAND_CB_INT91, BRAND_URET_FROM_INTR_STACK())
 	jmp	nopop_syscall_int
 
@@ -1183,6 +1346,7 @@
 	ALTENTRY(sys_syscall_int)
 	SWAPGS				/* kernel gsbase */
 	XPV_TRAP_POP
+	call	smap_enable
 
 nopop_syscall_int:
 	movq	%gs:CPU_THREAD, %r15
usr/src/uts/i86pc/os/cpuid.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/os/cpuid.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/os/cpuid.c	Mon Dec 14 10:47:45 2015
@@ -170,7 +170,10 @@
 	"bmi1",
 	"bmi2",
 	"fma",
-	"smep"
+	"smep",
+	"smap",
+	"adx",
+	"rdseed"
 };
 
 boolean_t
@@ -223,6 +226,7 @@
 static size_t xsave_state_size = 0;
 uint64_t xsave_bv_all = (XFEATURE_LEGACY_FP | XFEATURE_SSE);
 boolean_t xsave_force_disable = B_FALSE;
+extern int disable_smap;
 
 /*
  * This is set to platform type we are running on.
@@ -1249,6 +1253,24 @@
 
 		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_SMEP)
 			add_x86_feature(featureset, X86FSET_SMEP);
+
+		/*
+		 * We check disable_smap here in addition to in startup_smap()
+		 * to ensure CPUs that aren't the boot CPU don't accidentally
+		 * include it in the feature set and thus generate a mismatched
+		 * x86 feature set across CPUs. Note that at this time we only
+		 * enable SMAP for the 64-bit kernel.
+		 */
+#if defined(__amd64)
+		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_SMAP &&
+		    disable_smap == 0)
+			add_x86_feature(featureset, X86FSET_SMAP);
+#endif
+		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_RDSEED)
+			add_x86_feature(featureset, X86FSET_RDSEED);
+
+		if (ecp->cp_ebx & CPUID_INTC_EBX_7_0_ADX)
+			add_x86_feature(featureset, X86FSET_ADX);
 	}
 
 	/*
@@ -2724,6 +2746,10 @@
 			*ebx &= ~CPUID_INTC_EBX_7_0_BMI2;
 		if (!is_x86_feature(x86_featureset, X86FSET_AVX2))
 			*ebx &= ~CPUID_INTC_EBX_7_0_AVX2;
+		if (!is_x86_feature(x86_featureset, X86FSET_RDSEED))
+			*ebx &= ~CPUID_INTC_EBX_7_0_RDSEED;
+		if (!is_x86_feature(x86_featureset, X86FSET_ADX))
+			*ebx &= ~CPUID_INTC_EBX_7_0_ADX;
 
 		/*
 		 * [no explicit support required beyond x87 fp context]
@@ -2793,8 +2819,20 @@
 
 		if (*ecx & CPUID_INTC_ECX_RDRAND)
 			hwcap_flags_2 |= AV_386_2_RDRAND;
+		if (*ebx & CPUID_INTC_EBX_7_0_ADX)
+			hwcap_flags_2 |= AV_386_2_ADX;
+		if (*ebx & CPUID_INTC_EBX_7_0_RDSEED)
+			hwcap_flags_2 |= AV_386_2_RDSEED;
+
 	}
 
+	/* Detect systems with a potential CPUID limit  */
+	if (cpi->cpi_vendor == X86_VENDOR_Intel && cpi->cpi_maxeax < 4) {
+		cmn_err(CE_NOTE, "CPUID limit detected, "
+		    "see the CPUID(7D) man page for details\n");
+	}
+
+
 	if (cpi->cpi_xmaxeax < 0x80000001)
 		goto pass4_done;
 
usr/src/uts/i86pc/os/mlsetup.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/os/mlsetup.c	Thu Nov 12 15:35:32 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/os/mlsetup.c	Mon Dec 14 10:47:45 2015
@@ -269,7 +269,10 @@
 		(void) wrmsr(MSR_AMD_TSCAUX, 0);
 
 	/*
-	 * Let's get the other %cr4 stuff while we're here.
+	 * Let's get the other %cr4 stuff while we're here. Note, we defer
+	 * enabling CR4_SMAP until startup_end(); however, that's importantly
+	 * before we start other CPUs. That ensures that it will be synced out
+	 * to other CPUs.
 	 */
 	if (is_x86_feature(x86_featureset, X86FSET_DE))
 		setcr4(getcr4() | CR4_DE);
usr/src/uts/i86pc/os/mp_startup.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/os/mp_startup.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/os/mp_startup.c	Mon Dec 14 10:47:45 2015
@@ -27,7 +27,7 @@
  * All rights reserved.
  */
 /*
- * Copyright (c) 2012, Joyent, Inc.  All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
  */
 
@@ -166,6 +166,8 @@
 void
 init_cpu_syscall(struct cpu *cp)
 {
+	uint64_t flags;
+
 	kpreempt_disable();
 
 #if defined(__amd64)
@@ -199,7 +201,10 @@
 		 * This list of flags is masked off the incoming
 		 * %rfl when we enter the kernel.
 		 */
-		wrmsr(MSR_AMD_SFMASK, (uint64_t)(uintptr_t)(PS_IE | PS_T));
+		flags = PS_IE | PS_T;
+		if (is_x86_feature(x86_featureset, X86FSET_SMAP) == B_TRUE)
+			flags |= PS_ACHK;
+		wrmsr(MSR_AMD_SFMASK, flags);
 	}
 #endif
 
usr/src/uts/i86pc/os/startup.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/os/startup.c	Thu Nov 12 15:35:32 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/os/startup.c	Mon Dec 14 10:47:45 2015
@@ -22,7 +22,7 @@
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2012 DEY Storage Systems, Inc.  All rights reserved.
  * Copyright 2013 Nexenta Systems, Inc. All rights reserved.
- * Copyright 2013 Joyent, Inc.  All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 /*
  * Copyright (c) 2010, Intel Corporation.
@@ -284,6 +284,12 @@
 #endif
 
 /*
+ * Give folks an escape hatch for disabling SMAP via kmdb. Doesn't work
+ * post-boot.
+ */
+int disable_smap = 0;
+
+/*
  * new memory fragmentations are possible in startup() due to BOP_ALLOCs. this
  * depends on number of BOP_ALLOC calls made and requested size, memory size
  * combination and whether boot.bin memory needs to be freed.
@@ -673,6 +679,60 @@
 }
 
 /*
+ * Set up and enable SMAP now before we start other CPUs, but after the kernel's
+ * VM has been set up so we can use hot_patch_kernel_text().
+ *
+ * We can only patch 1, 2, or 4 bytes, but not three bytes. So instead, we
+ * replace the four byte word at the patch point. See uts/intel/ia32/ml/copy.s
+ * for more information on what's going on here.
+ */
+static void
+startup_smap(void)
+{
+	int i;
+	uint32_t inst;
+	uint8_t *instp;
+	char sym[128];
+
+	extern int _smap_enable_patch_count;
+	extern int _smap_disable_patch_count;
+
+	if (disable_smap != 0)
+		remove_x86_feature(x86_featureset, X86FSET_SMAP);
+
+	if (is_x86_feature(x86_featureset, X86FSET_SMAP) == B_FALSE)
+		return;
+
+	for (i = 0; i < _smap_enable_patch_count; i++) {
+		int sizep;
+
+		VERIFY3U(i, <, _smap_enable_patch_count);
+		VERIFY(snprintf(sym, sizeof (sym), "_smap_enable_patch_%d", i) <
+		    sizeof (sym));
+		instp = (uint8_t *)(void *)kobj_getelfsym(sym, NULL, &sizep);
+		VERIFY(instp != 0);
+		inst = (instp[3] << 24) | (SMAP_CLAC_INSTR & 0x00ffffff);
+		hot_patch_kernel_text((caddr_t)instp, inst, 4);
+	}
+
+	for (i = 0; i < _smap_disable_patch_count; i++) {
+		int sizep;
+
+		VERIFY(snprintf(sym, sizeof (sym), "_smap_disable_patch_%d",
+		    i) < sizeof (sym));
+		instp = (uint8_t *)(void *)kobj_getelfsym(sym, NULL, &sizep);
+		VERIFY(instp != 0);
+		inst = (instp[3] << 24) | (SMAP_STAC_INSTR & 0x00ffffff);
+		hot_patch_kernel_text((caddr_t)instp, inst, 4);
+	}
+
+	hot_patch_kernel_text((caddr_t)smap_enable, SMAP_CLAC_INSTR, 4);
+	hot_patch_kernel_text((caddr_t)smap_disable, SMAP_STAC_INSTR, 4);
+	setcr4(getcr4() | CR4_SMAP);
+	smap_enable();
+}
+
+/*
  * Our world looks like this at startup time.
  *
  * In a 32-bit OS, boot loads the kernel text at 0xfe800000 and kernel data
@@ -727,6 +787,7 @@
 	 * the irq routing table (used for pci labels).
 	 */
 	startup_pci_bios();
+	startup_smap();
 #endif
 #if defined(__xpv)
 	startup_xen_mca();
usr/src/uts/i86pc/os/trap.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/os/trap.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/os/trap.c	Mon Dec 14 10:47:45 2015
@@ -32,7 +32,7 @@
 /*								*/
 
 /*
- * Copyright 2012 Joyent, Inc. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/types.h>
@@ -101,6 +101,7 @@
 #include <sys/hypervisor.h>
 #endif
 #include <sys/contract/process_impl.h>
+#include <sys/brand.h>
 
 #define	USER	0x10000		/* user-mode flag added to trap type */
 
@@ -638,6 +639,21 @@
 		}
 
 		/*
+		 * We need to check if SMAP is in play. If SMAP is in play, then
+		 * any access to a user page will show up as a protection
+		 * violation. To see if SMAP is enabled we first check if it's a
+		 * user address and whether we have the feature flag set. If we
+		 * do and the interrupted registers do not allow for user
+		 * accesses (PS_ACHK is not enabled), then we need to die
+		 * immediately.
+		 */
+		if (addr < (caddr_t)kernelbase &&
+		    is_x86_feature(x86_featureset, X86FSET_SMAP) == B_TRUE &&
+		    (rp->r_ps & PS_ACHK) == 0) {
+			(void) die(type, rp, addr, cpuid);
+		}
+
+		/*
 		 * See if we can handle as pagefault. Save lofault and onfault
 		 * across this. Here we assume that an address less than
 		 * KERNELBASE is a user fault.  We can do this as copy.s
@@ -847,6 +863,17 @@
 			fault_type = F_INVAL;
 		}
 
+		/*
+		 * Allow the brand to interpose on invalid memory accesses
+		 * prior to running the native pagefault handler.  If this
+		 * brand hook returns zero, it was able to handle the fault
+		 * completely.  Otherwise, drive on and call pagefault().
+		 */
+		if (PROC_IS_BRANDED(p) && BROP(p)->b_pagefault != NULL &&
+		    BROP(p)->b_pagefault(p, lwp, addr, fault_type, rw) == 0) {
+			goto out;
+		}
+
 		res = pagefault(addr, fault_type, rw, 0);
 
 		/*
@@ -1453,12 +1480,23 @@
 
 		ct->t_sig_check = 0;
 
-		mutex_enter(&p->p_lock);
+		/*
+		 * As in other code paths that check against TP_CHANGEBIND,
+		 * we perform the check first without p_lock held -- only
+		 * acquiring p_lock in the unlikely event that it is indeed
+		 * set.  This is safe because we are doing this after the
+		 * astoff(); if we are racing another thread setting
+		 * TP_CHANGEBIND on us, we will pick it up on a subsequent
+		 * lap through.
+		 */
 		if (curthread->t_proc_flag & TP_CHANGEBIND) {
-			timer_lwpbind();
-			curthread->t_proc_flag &= ~TP_CHANGEBIND;
+			mutex_enter(&p->p_lock);
+			if (curthread->t_proc_flag & TP_CHANGEBIND) {
+				timer_lwpbind();
+				curthread->t_proc_flag &= ~TP_CHANGEBIND;
+			}
+			mutex_exit(&p->p_lock);
 		}
-		mutex_exit(&p->p_lock);
 
 		/*
 		 * for kaio requests that are on the per-process poll queue,
usr/src/uts/i86pc/sys/apic.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/sys/apic.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/sys/apic.h	Wed Jun 17 17:43:44 2015
@@ -382,7 +382,7 @@
 /* special or reserve vectors */
 #define	APIC_CHECK_RESERVE_VECTORS(v) \
 	(((v) == T_FASTTRAP) || ((v) == APIC_SPUR_INTR) || \
-	((v) == T_SYSCALLINT) || ((v) == T_DTRACE_RET))
+	((v) == T_SYSCALLINT) || ((v) == T_DTRACE_RET) || ((v) == 0x80))
 
 /* cmos shutdown code for BIOS						*/
 #define	BIOS_SHUTDOWN		0x0a
usr/src/uts/i86pc/vm/vm_machdep.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/i86pc/vm/vm_machdep.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/i86pc/vm/vm_machdep.c	Wed Jun 17 17:43:44 2015
@@ -24,6 +24,7 @@
 /*
  * Copyright (c) 2010, Intel Corporation.
  * All rights reserved.
+ * Copyright (c) 2014, Joyent, Inc. All rights reserved.
  */
 
 /* Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T */
@@ -623,10 +624,8 @@
 map_addr(caddr_t *addrp, size_t len, offset_t off, int vacalign, uint_t flags)
 {
 	struct proc *p = curproc;
-	caddr_t userlimit = (flags & _MAP_LOW32) ?
-	    (caddr_t)_userlimit32 : p->p_as->a_userlimit;
-
-	map_addr_proc(addrp, len, off, vacalign, userlimit, curproc, flags);
+	map_addr_proc(addrp, len, off, vacalign,
+	    map_userlimit(p, p->p_as, flags), curproc, flags);
 }
 
 /*ARGSUSED*/
usr/src/uts/intel/Makefile
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/Makefile	Tue Nov  3 10:15:33 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/Makefile	Mon Dec 14 10:47:45 2015
@@ -65,7 +65,7 @@
 
 .PARALLEL:	$(PARALLEL_KMODS) $(XMODS) config $(LINT_DEPS)
 
-def all install clean clobber modlist: $(KMODS) $(XMODS) config
+def all install clean clobber modlist: genassym $(KMODS) $(XMODS) config
 
 clobber: clobber.targ
 
@@ -107,7 +107,7 @@
 # intel/dtrace depends on i86pc/genassym, so we need to build both
 # i86pc/genassym and intel/genassym.
 #
-all.prereq install.prereq def.prereq: genunix FRC
+all.prereq install.prereq def.prereq: genassym genunix FRC
 	@cd ../i86pc/genassym; pwd; $(MAKE) $(@:%.prereq=%)
 
 #
@@ -125,7 +125,7 @@
 
 modlintlib clean.lint: $(LINT_KMODS) $(XMODS)
 
-$(KMODS) $(SUBDIRS) config:	FRC
+genassym $(KMODS) $(SUBDIRS) config:	FRC
 	@cd $@; pwd; $(MAKE) $(NO_STATE) $(TARGET)
 
 $(XMODS):	FRC
usr/src/uts/intel/Makefile.files
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/Makefile.files	Thu Nov 12 15:35:32 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/Makefile.files	Mon Dec 28 16:27:39 2015
@@ -21,7 +21,7 @@
 
 #
 # Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
-# Copyright (c) 2013, Joyent, Inc. All rights reserved.
+# Copyright 2015, Joyent, Inc.
 #
 
 #
@@ -99,7 +99,30 @@
 #
 CORE_OBJS +=		\
 	prmachdep.o
+ 
+LX_CGROUP_OBJS +=	\
+	cgrps_node.o	\
+	cgrps_vfsops.o	\
+	cgrps_vnops.o
 
+LX_DEVFS_OBJS +=	\
+	lxd_node.o	\
+	lxd_vfsops.o	\
+	lxd_vnops.o
+
+LX_PROC_OBJS +=	\
+	lx_prsubr.o	\
+	lx_prvfsops.o	\
+	lx_prvnops.o
+
+LX_SYS_OBJS +=	\
+	lx_syssubr.o	\
+	lx_sysvfsops.o	\
+	lx_sysvnops.o
+
+LX_AUTOFS_OBJS +=	\
+	lx_autofs.o
+
 #
 #	ZFS file system module
 #
@@ -185,8 +208,9 @@
 		   dbexec.o dbfileio.o dbhistry.o dbinput.o dbstats.o \
 		   dbutils.o dbxface.o evevent.o evgpe.o evgpeblk.o \
 		   evmisc.o evregion.o evrgnini.o evsci.o evxface.o \
-		   evxfevnt.o evxfregn.o hwacpi.o hwgpe.o hwregs.o \
-		   hwsleep.o hwtimer.o dsfield.o dsinit.o dsmethod.o \
+		   evxfevnt.o evxfregn.o hwacpi.o hwesleep.o hwgpe.o \
+		   hwregs.o hwsleep.o hwtimer.o hwxfsleep.o dsfield.o \
+		   dsinit.o dsmethod.o \
 		   dsmthdat.o dsobject.o dsopcode.o dsutils.o dswexec.o \
 		   dswload.o dswscope.o dswstate.o exconfig.o exconvrt.o \
 		   excreate.o exdump.o exfield.o exfldio.o exmisc.o \
@@ -198,16 +222,18 @@
 		   nsalloc.o nsdump.o nsdumpdv.o nseval.o nsinit.o \
 		   nsload.o nsnames.o nsobject.o nsparse.o nssearch.o \
 		   nsutils.o nswalk.o nsxfeval.o nsxfname.o nsxfobj.o \
-		   rsaddr.o rscalc.o rscreate.o rsdump.o \
+		   rsaddr.o rscalc.o rscreate.o rsdump.o rsserial.o \
 		   rsinfo.o rsio.o rsirq.o rslist.o rsmemory.o rsmisc.o \
 		   rsutils.o rsxface.o tbfadt.o tbfind.o tbinstal.o  \
-		   tbutils.o tbxface.o tbxfroot.o \
+		   tbutils.o tbxface.o tbxfroot.o utaddress.o \
 		   utalloc.o utclib.o utcopy.o utdebug.o utdelete.o \
 		   uteval.o utglobal.o utinit.o utmath.o utmisc.o \
-		   utobject.o utresrc.o utxface.o acpica.o acpi_enum.o \
+		   utobject.o utresrc.o utxface.o utxfmutex.o acpica.o \
+		   acpi_enum.o \
 		   master_ops.o osl.o osl_ml.o acpica_ec.o utcache.o \
 		   utmutex.o utstate.o dmbuffer.o dmnames.o dmobject.o \
-		   dmopcode.o dmresrc.o dmresrcl.o dmresrcs.o dmutils.o \
+		   dmopcode.o dmresrc.o dmresrcl.o dmresrcl2.o dmresrcs.o \
+		   dmutils.o \
 		   dmwalk.o psloop.o nspredef.o hwxface.o hwvalid.o \
 		   utlock.o utids.o nsrepair.o nsrepair2.o \
 		   dbmethod.o dbnames.o dsargs.o dscontrol.o dswload2.o \
@@ -263,6 +289,52 @@
 #
 SN1_BRAND_OBJS	=	sn1_brand.o sn1_brand_asm.o
 S10_BRAND_OBJS	=	s10_brand.o s10_brand_asm.o
+LX_BRAND_OBJS  =		\
+	lx_aio.o		\
+	lx_archdep.o		\
+	lx_auxv.o		\
+	lx_brand.o		\
+	lx_brk.o		\
+	lx_chmod.o		\
+	lx_chown.o		\
+	lx_clone.o		\
+	lx_close.o		\
+	lx_cpu.o		\
+	lx_errno.o		\
+	lx_epoll.o		\
+	lx_fallocate.o		\
+	lx_fcntl.o		\
+	lx_futex.o		\
+	lx_getdents.o		\
+	lx_getpid.o		\
+	lx_getrandom.o		\
+	lx_id.o			\
+	lx_ioctl.o		\
+	lx_ioprio.o		\
+	lx_kill.o		\
+	lx_misc.o		\
+	lx_mkdir.o		\
+	lx_modify_ldt.o		\
+	lx_open.o		\
+	lx_pid.o		\
+	lx_pipe.o		\
+	lx_poll.o		\
+	lx_prctl.o		\
+	lx_ptrace.o		\
+	lx_rlimit.o		\
+	lx_rw.o			\
+	lx_sched.o		\
+	lx_signal.o		\
+	lx_signum.o		\
+	lx_socket.o		\
+	lx_sync.o		\
+	lx_syscall.o		\
+	lx_sysinfo.o		\
+	lx_thread_area.o	\
+	lx_timer.o		\
+	lx_uname.o		\
+	lx_wait.o		\
+	lx_xattr.o
 
 #
 #	special files
usr/src/uts/intel/Makefile.intel
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/Makefile.intel	Tue Jan  5 17:20:22 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/Makefile.intel	Mon Dec 28 16:27:39 2015
@@ -43,6 +43,7 @@
 #
 UNIX_DIR	 = $(UTSBASE)/i86pc/unix
 GENLIB_DIR	 = $(UTSBASE)/intel/genunix
+GENASSYM_DIR	 = $(UTSBASE)/intel/genassym
 IPDRV_DIR	 = $(UTSBASE)/intel/ip
 MODSTUBS_DIR	 = $(UNIX_DIR)
 DSF_DIR		 = $(UTSBASE)/$(PLATFORM)/genassym
@@ -136,6 +137,7 @@
 ASFLAGS_XARCH		= $(ASFLAGS_XARCH_$(CLASS))
 
 ASFLAGS			+= $(ASFLAGS_XARCH)
+AS_INC_PATH		+= -I$(GENASSYM_DIR)/$(OBJS_DIR)
 
 #
 #	Define the base directory for installation.
@@ -237,6 +239,7 @@
 DRV_KMODS	+= dld
 DRV_KMODS	+= dlpistub
 DRV_KMODS_32	+= dnet
+DRV_KMODS	+= dr_sas
 DRV_KMODS	+= dump
 DRV_KMODS	+= ecpp
 DRV_KMODS	+= emlxs
@@ -250,6 +253,7 @@
 DRV_KMODS	+= i915
 DRV_KMODS	+= icmp
 DRV_KMODS	+= icmp6
+DRV_KMODS	+= inotify
 DRV_KMODS	+= intel_nb5000
 DRV_KMODS	+= intel_nhm
 DRV_KMODS	+= ip
@@ -284,6 +288,7 @@
 DRV_KMODS	+= mr_sas
 DRV_KMODS	+= mwl 
 DRV_KMODS	+= nca
+DRV_KMODS	+= nfp
 DRV_KMODS	+= nsmb
 DRV_KMODS	+= nulldriver
 DRV_KMODS	+= nv_sata
@@ -353,6 +358,8 @@
 DRV_KMODS	+= urtw
 DRV_KMODS	+= vgatext
 DRV_KMODS	+= heci
+DRV_KMODS	+= vmxnet 
+DRV_KMODS	+= vnd
 DRV_KMODS	+= vnic
 DRV_KMODS	+= vscan
 DRV_KMODS	+= wc
@@ -361,6 +368,7 @@
 DRV_KMODS	+= xge
 DRV_KMODS	+= yge
 DRV_KMODS	+= zcons
+DRV_KMODS	+= zfd
 DRV_KMODS	+= zyd
 DRV_KMODS	+= simnet
 DRV_KMODS	+= stmf
@@ -486,6 +494,15 @@
 DRV_KMODS	+= usbecm
 
 #
+#	USBGEM modules
+#
+DRV_KMODS	+= usbgem
+DRV_KMODS	+= axf
+DRV_KMODS	+= udmf 
+DRV_KMODS	+= upf
+DRV_KMODS	+= urf 
+
+#
 #	1394 modules
 #
 MISC_KMODS	+= s1394 sbp2
@@ -509,7 +526,8 @@
 #
 #	Brand modules
 #
-BRAND_KMODS	+= sn1_brand s10_brand
+BRAND_KMODS	+= sn1_brand s10_brand lx_brand
+DRV_KMODS	+= lx_systrace lx_ptm lx_audio lx_netlink
 
 #
 #	Exec Class Modules (/kernel/exec):
@@ -524,10 +542,10 @@
 #
 #	File System Modules (/kernel/fs):
 #
-FS_KMODS	+= autofs ctfs dcfs dev devfs fdfs fifofs hsfs lofs
-FS_KMODS	+= mntfs namefs nfs objfs zfs zut
-FS_KMODS	+= pcfs procfs sockfs specfs tmpfs udfs ufs sharefs
-FS_KMODS	+= smbfs bootfs
+FS_KMODS	+= autofs ctfs dcfs dev devfs fdfs fifofs hsfs hyprlofs
+FS_KMODS	+= lofs lxautofs lx_proc lxprocfs mntfs namefs nfs objfs zfs zut
+FS_KMODS	+= pcfs procfs sockfs specfs tmpfs udfs ufs sharefs lx_sysfs
+FS_KMODS	+= smbfs bootfs lx_cgroup lx_devfs
 
 #
 #	Streams Modules (/kernel/strmod):
@@ -587,6 +605,7 @@
 MISC_KMODS	+= fssnap_if
 MISC_KMODS	+= gda
 MISC_KMODS	+= gld
+MISC_KMODS	+= gsqueue
 MISC_KMODS	+= hidparser
 MISC_KMODS	+= hook
 MISC_KMODS	+= hpcsvc
@@ -703,6 +722,12 @@
 MAC_KMODS	+= mac_ib
 
 #
+#	Overlay related modules (/kernel/overlay)
+#
+DRV_KMODS	+= overlay
+OVERLAY_KMODS	+= vxlan
+
+#
 # socketmod (kernel/socketmod)
 #
 SOCKET_KMODS	+= sockpfp
@@ -710,7 +735,6 @@
 SOCKET_KMODS    += socksdp
 SOCKET_KMODS	+= sockrds
 SOCKET_KMODS	+= ksslf
-SOCKET_KMODS	+= httpfilt
 SOCKET_KMODS	+= datafilt
 
 #
usr/src/uts/intel/brand/common/brand_asm.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/brand/common/brand_asm.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/brand/common/brand_asm.h	Wed Jun 17 17:43:44 2015
@@ -161,7 +161,7 @@
 
 #define	GET_P_BRAND_DATA(sp, pcnt, reg)					\
 	GET_PROCP(sp, pcnt, reg);					\
-	mov	P_BRAND_DATA(reg), reg		/* get p_brand_data */
+	mov	__P_BRAND_DATA(reg), reg	/* get p_brand_data */
 
 /*
  * Each of the following macros returns to the standard syscall codepath if
usr/src/uts/intel/brand/lx/lx_archdep.c
usr/src/uts/intel/brand/lx/lx_brand_asm.s
usr/src/uts/intel/dtrace/dtrace_asm.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/dtrace/dtrace_asm.s	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/dtrace/dtrace_asm.s	Mon Dec 14 10:47:45 2015
@@ -23,7 +23,7 @@
  * Use is subject to license terms.
  */
 /*
- * Copyright 2011 Joyent, Inc.  All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #include <sys/asm_linkage.h>
@@ -195,6 +195,7 @@
 
 	ENTRY(dtrace_copy)
 	pushq	%rbp
+	call	smap_disable
 	movq	%rsp, %rbp
 
 	xchgq	%rdi, %rsi		/* make %rsi source, %rdi dest */
@@ -201,6 +202,7 @@
 	movq	%rdx, %rcx		/* load count */
 	repz				/* repeat for count ... */
 	smovb				/*   move from %ds:rsi to %ed:rdi */
+	call	smap_enable
 	leave
 	ret
 	SET_SIZE(dtrace_copy)
@@ -244,7 +246,7 @@
 	ENTRY(dtrace_copystr)
 	pushq	%rbp
 	movq	%rsp, %rbp
-
+	call	smap_disable
 0:
 	movb	(%rdi), %al		/* load from source */
 	movb	%al, (%rsi)		/* store to destination */
@@ -261,6 +263,7 @@
 	cmpq	$0, %rdx
 	jne	0b
 2:
+	call	smap_enable
 	leave
 	ret
 
@@ -273,7 +276,7 @@
 	pushl	%ebp			/ Setup stack frame
 	movl	%esp, %ebp
 	pushl	%ebx			/ Save registers
-
+	
 	movl	8(%ebp), %ebx		/ Load source address
 	movl	12(%ebp), %edx		/ Load destination address
 	movl	16(%ebp), %ecx		/ Load count
@@ -317,7 +320,9 @@
 #if defined(__amd64)
 
 	ENTRY(dtrace_fulword)
+	call	smap_disable
 	movq	(%rdi), %rax
+	call	smap_enable
 	ret
 	SET_SIZE(dtrace_fulword)
 
@@ -344,8 +349,10 @@
 #if defined(__amd64)
 
 	ENTRY(dtrace_fuword8_nocheck)
+	call	smap_disable
 	xorq	%rax, %rax
 	movb	(%rdi), %al
+	call	smap_enable
 	ret
 	SET_SIZE(dtrace_fuword8_nocheck)
 
@@ -372,8 +379,10 @@
 #if defined(__amd64)
 
 	ENTRY(dtrace_fuword16_nocheck)
+	call	smap_disable
 	xorq	%rax, %rax
 	movw	(%rdi), %ax
+	call	smap_enable
 	ret
 	SET_SIZE(dtrace_fuword16_nocheck)
 
@@ -400,8 +409,10 @@
 #if defined(__amd64)
 
 	ENTRY(dtrace_fuword32_nocheck)
+	call	smap_disable
 	xorq	%rax, %rax
 	movl	(%rdi), %eax
+	call	smap_enable
 	ret
 	SET_SIZE(dtrace_fuword32_nocheck)
 
@@ -428,7 +439,9 @@
 #if defined(__amd64)
 
 	ENTRY(dtrace_fuword64_nocheck)
+	call	smap_disable
 	movq	(%rdi), %rax
+	call	smap_enable
 	ret
 	SET_SIZE(dtrace_fuword64_nocheck)
 
usr/src/uts/intel/dtrace/fasttrap_isa.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/dtrace/fasttrap_isa.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/dtrace/fasttrap_isa.c	Wed Jun 17 17:43:44 2015
@@ -24,7 +24,9 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/*
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
+ */
 
 #include <sys/fasttrap_isa.h>
 #include <sys/fasttrap_impl.h>
@@ -38,6 +40,9 @@
 #include <sys/sysmacros.h>
 #include <sys/trap.h>
 #include <sys/archsystm.h>
+#include <sys/proc.h>
+#include <sys/brand.h>
+#include <sys/machbrand.h>
 
 /*
  * Lossless User-Land Tracing on x86
@@ -1394,6 +1399,14 @@
 #if defined(__amd64)
 		if (p->p_model == DATAMODEL_LP64) {
 			addr = lwp->lwp_pcb.pcb_fsbase;
+
+			/*
+			 * If we're branded, convert the fsbase from the
+			 * brand's fsbase to the native fsbase.
+			 */
+			if (PROC_IS_BRANDED(p) && BRMOP(p)->b_fsbase != NULL)
+				addr = BRMOP(p)->b_fsbase(lwp, addr);
+
 			addr += sizeof (void *);
 		} else {
 			addr = lwp->lwp_pcb.pcb_gsbase;
usr/src/uts/intel/genassym/Makefile
usr/src/uts/intel/genassym/offsets.in
usr/src/uts/intel/ia32/ml/copy.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/ml/copy.s	Mon Dec  7 18:06:21 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/ml/copy.s	Mon Dec 14 10:47:45 2015
@@ -35,6 +35,10 @@
 /*       Copyright (c) 1987, 1988 Microsoft Corporation			*/
 /*         All Rights Reserved						*/
 
+/*
+ * Copyright 2015 Joyent, Inc.
+ */
+
 #include <sys/errno.h>
 #include <sys/asm_linkage.h>
 
@@ -56,6 +60,69 @@
 #define	COUNT_ALIGN_MASK	_CONST(COUNT_ALIGN_SIZE-1)
 
 /*
+ * With the introduction of Broadwell, Intel has introduced supervisor mode
+ * access protection -- SMAP. SMAP forces the kernel to set certain bits to
+ * enable access of user pages (AC in rflags, defines as PS_ACHK in
+ * <sys/psw.h>). One of the challenges is that the implementation of many of the
+ * userland copy routines directly use the kernel ones. For example, copyin and
+ * copyout simply go and jump to the do_copy_fault label and traditionally let
+ * those deal with the return for them. In fact, changing that is a can of frame
+ * pointers.
+ *
+ * Rules and Constraints:
+ *
+ * 1. For anything that's not in copy.s, we have it do explicit calls to the
+ * smap related code. It usually is in a position where it is able to. This is
+ * restricted to the following three places: DTrace, resume() in swtch.s and
+ * on_fault/no_fault. If you want to add it somewhere else, we should be
+ * thinking twice.
+ *
+ * 2. We try to toggle this at the smallest window possible. This means that if
+ * we take a fault, need to try to use a copyop in copyin() or copyout(), or any
+ * other function, we will always leave with SMAP enabled (the kernel cannot
+ * access user pages).
+ *
+ * 3. None of the *_noerr() or ucopy/uzero routines should toggle SMAP. They are
+ * explicitly only allowed to be called while in an on_fault()/no_fault() handler,
+ * which already takes care of ensuring that SMAP is enabled and disabled. Note
+ * this means that when under an on_fault()/no_fault() handler, one must not
+ * call the non-*_noeer() routines.
+ *
+ * 4. The first thing we should do after coming out of an lofault handler is to
+ * make sure that we call smap_enable again to ensure that we are safely
+ * protected, as more often than not, we will have disabled smap to get there.
+ *
+ * 5. The SMAP functions, smap_enable and smap_disable may not touch any
+ * registers beyond those done by the call and ret. These routines may be called
+ * from arbitrary contexts in copy.s where we have slightly more special ABIs in
+ * place.
+ *
+ * 6. For any inline user of SMAP, the appropriate SMAP_ENABLE_INSTR and
+ * SMAP_DISABLE_INSTR macro should be used (except for smap_enable() and
+ * smap_disable()). If the number of these is changed, you must update the
+ * constants SMAP_ENABLE_COUNT and SMAP_DISABLE_COUNT below.
+ *
+ * 7. Note, at this time SMAP is not implemented for the 32-bit kernel. There is
+ * no known technical reason preventing it from being enabled.
+ *
+ * 8. Generally this .s file is processed by a K&R style cpp. This means that it
+ * really has a lot of feelings about whitespace. In particular, if you have a
+ * macro FOO with the arguments FOO(1, 3), the second argument is in fact ' 3'.
+ *
+ * 9. The smap_enable and smap_disable functions should not generally be called.
+ * They exist such that DTrace and on_trap() may use them, that's it.
+ *
+ * 10. In general, the kernel has its own value for rflags that gets used. This
+ * is maintained in a few different places which vary based on how the thread
+ * comes into existence and whether it's a user thread. In general, when the
+ * kernel takes a trap, it always will set ourselves to a known set of flags,
+ * mainly as part of ENABLE_INTR_FLAGS and F_OFF and F_ON. These ensure that
+ * PS_ACHK is cleared for us. In addition, when using the sysenter instruction,
+ * we mask off PS_ACHK off via the AMD_SFMASK MSR. See init_cpu_syscall() for
+ * where that gets masked off.
+ */
+
+/*
  * The optimal 64-bit bcopy and kcopy for modern x86 processors uses
  * "rep smovq" for large sizes. Performance data shows that many calls to
  * bcopy/kcopy/bzero/kzero operate on small buffers. For best performance for
@@ -72,6 +139,28 @@
  * Returns errno value on pagefault error, 0 if all ok
  */
 
+/*
+ * I'm sorry about these macros, but copy.s is unsurprisingly sensitive to
+ * additional call instructions.
+ */
+#if defined(__amd64)
+#define	SMAP_DISABLE_COUNT	16
+#define	SMAP_ENABLE_COUNT	26
+#elif defined(__i386)
+#define	SMAP_DISABLE_COUNT	0
+#define	SMAP_ENABLE_COUNT	0
+#endif
+
+#define	SMAP_DISABLE_INSTR(ITER)		\
+	.globl	_smap_disable_patch_/**/ITER;	\
+	_smap_disable_patch_/**/ITER/**/:;	\
+	nop; nop; nop;
+
+#define	SMAP_ENABLE_INSTR(ITER)			\
+	.globl	_smap_enable_patch_/**/ITER;	\
+	_smap_enable_patch_/**/ITER/**/:;	\
+	nop; nop; nop;
+
 #if defined(__lint)
 
 /* ARGSUSED */
@@ -110,6 +199,7 @@
 	movq	%rcx, T_LOFAULT(%r9)	/* new lofault */
 	call	bcopy_altentry
 	xorl	%eax, %eax		/* return 0 (success) */
+	SMAP_ENABLE_INSTR(0)
 
 	/*
 	 * A fault during do_copy_fault is indicated through an errno value
@@ -268,6 +358,7 @@
 
 	mfence
 	xorl	%eax, %eax		/* return 0 (success) */
+	SMAP_ENABLE_INSTR(1)
 
 _kcopy_nta_copyerr:
 	movq	%r11, T_LOFAULT(%r9)    /* restore original lofault */
@@ -1466,10 +1557,12 @@
 
 	movq	%gs:CPU_THREAD, %r9
 	cmpq	%rax, %rdi		/* test uaddr < kernelbase */
-	jb	do_copy_fault
-	jmp	3f
+	jae	3f			/* take copyop if uaddr > kernelbase */
+	SMAP_DISABLE_INSTR(0)
+	jmp	do_copy_fault		/* Takes care of leave for us */
 
 _copyin_err:
+	SMAP_ENABLE_INSTR(2)
 	movq	%r11, T_LOFAULT(%r9)	/* restore original lofault */	
 	addq	$8, %rsp		/* pop bcopy_altentry call ret addr */
 3:
@@ -1577,24 +1670,29 @@
 	 * pass lofault value as 4th argument to do_copy_fault
 	 */
 	leaq	_xcopyin_err(%rip), %rcx	/* doesn't set rflags */
-	jnz	do_copy_fault		/* use regular access */
+	jnz	6f			/* use regular access */
 	/*
 	 * Make sure cnt is >= XCOPY_MIN_SIZE bytes
 	 */
 	cmpq	$XCOPY_MIN_SIZE, %rdx
-	jb	do_copy_fault
+	jae	5f
+6:
+	SMAP_DISABLE_INSTR(1)
+	jmp	do_copy_fault
 	
 	/*
 	 * Make sure src and dst are NTA_ALIGN_SIZE aligned,
 	 * count is COUNT_ALIGN_SIZE aligned.
 	 */
+5:
 	movq	%rdi, %r10
 	orq	%rsi, %r10
 	andq	$NTA_ALIGN_MASK, %r10
 	orq	%rdx, %r10
 	andq	$COUNT_ALIGN_MASK, %r10
-	jnz	do_copy_fault
+	jnz	6b	
 	leaq	_xcopyin_nta_err(%rip), %rcx	/* doesn't set rflags */
+	SMAP_DISABLE_INSTR(2)
 	jmp	do_copy_fault_nta	/* use non-temporal access */
 	
 4:
@@ -1609,6 +1707,7 @@
 _xcopyin_err:
 	addq	$8, %rsp		/* pop bcopy_altentry call ret addr */
 _xcopyin_nta_err:
+	SMAP_ENABLE_INSTR(3)
 	movq	%r11, T_LOFAULT(%r9)	/* restore original lofault */
 3:
 	movq	T_COPYOPS(%r9), %r8
@@ -1745,10 +1844,12 @@
 
 	movq	%gs:CPU_THREAD, %r9
 	cmpq	%rax, %rsi		/* test uaddr < kernelbase */
-	jb	do_copy_fault
-	jmp	3f
+	jae	3f			/* take copyop if uaddr > kernelbase */
+	SMAP_DISABLE_INSTR(3)
+	jmp	do_copy_fault		/* Calls leave for us */
 
 _copyout_err:
+	SMAP_ENABLE_INSTR(4)
 	movq	%r11, T_LOFAULT(%r9)	/* restore original lofault */
 	addq	$8, %rsp		/* pop bcopy_altentry call ret addr */
 3:
@@ -1855,25 +1956,32 @@
 	 * pass lofault value as 4th argument to do_copy_fault
 	 */
 	leaq	_xcopyout_err(%rip), %rcx
-	jnz	do_copy_fault
+	jnz	6f
 	/*
 	 * Make sure cnt is >= XCOPY_MIN_SIZE bytes
 	 */
 	cmpq	$XCOPY_MIN_SIZE, %rdx
-	jb	do_copy_fault
+	jae	5f
+6:
+	SMAP_DISABLE_INSTR(4)
+	jmp	do_copy_fault
 	
 	/*
 	 * Make sure src and dst are NTA_ALIGN_SIZE aligned,
 	 * count is COUNT_ALIGN_SIZE aligned.
 	 */
+5:
 	movq	%rdi, %r10
 	orq	%rsi, %r10
 	andq	$NTA_ALIGN_MASK, %r10
 	orq	%rdx, %r10
 	andq	$COUNT_ALIGN_MASK, %r10
-	jnz	do_copy_fault
+	jnz	6b	
 	leaq	_xcopyout_nta_err(%rip), %rcx
-	jmp	do_copy_fault_nta
+	SMAP_DISABLE_INSTR(5)
+	call	do_copy_fault_nta
+	SMAP_ENABLE_INSTR(5)
+	ret
 
 4:
 	movl	$EFAULT, %eax
@@ -1887,6 +1995,7 @@
 _xcopyout_err:
 	addq	$8, %rsp		/* pop bcopy_altentry call ret addr */
 _xcopyout_nta_err:
+	SMAP_ENABLE_INSTR(6)
 	movq	%r11, T_LOFAULT(%r9)	/* restore original lofault */
 3:
 	movq	T_COPYOPS(%r9), %r8
@@ -2011,6 +2120,8 @@
 	movq	%gs:CPU_THREAD, %r9
 	movq	T_LOFAULT(%r9), %r8	/* pass current lofault value as */
 					/* 5th argument to do_copystr */
+	xorl	%r10d,%r10d		/* pass smap restore need in %r10d */
+					/* as a non-ABI 6th arg */
 do_copystr:
 	movq	%gs:CPU_THREAD, %r9	/* %r9 = thread addr */
 	movq    T_LOFAULT(%r9), %r11	/* save the current lofault */
@@ -2041,10 +2152,15 @@
 
 copystr_out:
 	cmpq	$0, %rcx		/* want length? */
-	je	copystr_done		/* no */
+	je	copystr_smap		/* no */
 	subq	%r8, %rdx		/* compute length and store it */
 	movq	%rdx, (%rcx)
 
+copystr_smap:
+	cmpl	$0, %r10d
+	jz	copystr_done
+	SMAP_ENABLE_INSTR(7)
+
 copystr_done:
 	movq	%r11, T_LOFAULT(%r9)	/* restore the original lofault */
 	leave
@@ -2178,15 +2294,21 @@
 #endif
 	/*
 	 * pass lofault value as 5th argument to do_copystr
+	 * do_copystr expects whether or not we need smap in %r10d
 	 */
 	leaq	_copyinstr_error(%rip), %r8
+	movl	$1, %r10d
 
 	cmpq	%rax, %rdi		/* test uaddr < kernelbase */
-	jb	do_copystr
+	jae	4f
+	SMAP_DISABLE_INSTR(6)
+	jmp	do_copystr
+4:
 	movq	%gs:CPU_THREAD, %r9
 	jmp	3f
 
 _copyinstr_error:
+	SMAP_ENABLE_INSTR(8)
 	movq	%r11, T_LOFAULT(%r9)	/* restore original lofault */
 3:
 	movq	T_COPYOPS(%r9), %rax
@@ -2294,15 +2416,21 @@
 #endif
 	/*
 	 * pass lofault value as 5th argument to do_copystr
+	 * pass one as 6th argument to do_copystr in %r10d
 	 */
 	leaq	_copyoutstr_error(%rip), %r8
+	movl	$1, %r10d
 
 	cmpq	%rax, %rsi		/* test uaddr < kernelbase */
-	jb	do_copystr
+	jae	4f
+	SMAP_DISABLE_INSTR(7)
+	jmp	do_copystr
+4:
 	movq	%gs:CPU_THREAD, %r9
 	jmp	3f
 
 _copyoutstr_error:
+	SMAP_ENABLE_INSTR(9)
 	movq	%r11, T_LOFAULT(%r9)	/* restore the original lofault */
 3:
 	movq	T_COPYOPS(%r9), %rax
@@ -2406,11 +2534,13 @@
 #if defined(__amd64)
 
 /*
- * (Note that we don't save and reload the arguments here
- * because their values are not altered in the copy path)
+ * Note that we don't save and reload the arguments here
+ * because their values are not altered in the copy path.
+ * Additionally, when successful, the smap_enable jmp will
+ * actually return us to our original caller.
  */
 
-#define	FUWORD(NAME, INSTR, REG, COPYOP)	\
+#define	FUWORD(NAME, INSTR, REG, COPYOP, DISNUM, EN1, EN2)	\
 	ENTRY(NAME)				\
 	movq	%gs:CPU_THREAD, %r9;		\
 	cmpq	kernelbase(%rip), %rdi;		\
@@ -2417,12 +2547,15 @@
 	jae	1f;				\
 	leaq	_flt_/**/NAME, %rdx;		\
 	movq	%rdx, T_LOFAULT(%r9);		\
+	SMAP_DISABLE_INSTR(DISNUM)		\
 	INSTR	(%rdi), REG;			\
 	movq	$0, T_LOFAULT(%r9);		\
 	INSTR	REG, (%rsi);			\
 	xorl	%eax, %eax;			\
+	SMAP_ENABLE_INSTR(EN1)			\
 	ret;					\
 _flt_/**/NAME:					\
+	SMAP_ENABLE_INSTR(EN2)			\
 	movq	$0, T_LOFAULT(%r9);		\
 1:						\
 	movq	T_COPYOPS(%r9), %rax;		\
@@ -2434,10 +2567,10 @@
 	ret;					\
 	SET_SIZE(NAME)
 	
-	FUWORD(fuword64, movq, %rax, CP_FUWORD64)
-	FUWORD(fuword32, movl, %eax, CP_FUWORD32)
-	FUWORD(fuword16, movw, %ax, CP_FUWORD16)
-	FUWORD(fuword8, movb, %al, CP_FUWORD8)
+	FUWORD(fuword64, movq, %rax, CP_FUWORD64,8,10,11)
+	FUWORD(fuword32, movl, %eax, CP_FUWORD32,9,12,13)
+	FUWORD(fuword16, movw, %ax, CP_FUWORD16,10,14,15)
+	FUWORD(fuword8, movb, %al, CP_FUWORD8,11,16,17)
 
 #elif defined(__i386)
 
@@ -2513,22 +2646,25 @@
 #if defined(__amd64)
 
 /*
- * (Note that we don't save and reload the arguments here
- * because their values are not altered in the copy path)
+ * Note that we don't save and reload the arguments here
+ * because their values are not altered in the copy path.
  */
 
-#define	SUWORD(NAME, INSTR, REG, COPYOP)	\
+#define	SUWORD(NAME, INSTR, REG, COPYOP, DISNUM, EN1, EN2)	\
 	ENTRY(NAME)				\
 	movq	%gs:CPU_THREAD, %r9;		\
 	cmpq	kernelbase(%rip), %rdi;		\
 	jae	1f;				\
 	leaq	_flt_/**/NAME, %rdx;		\
+	SMAP_DISABLE_INSTR(DISNUM)		\
 	movq	%rdx, T_LOFAULT(%r9);		\
 	INSTR	REG, (%rdi);			\
 	movq	$0, T_LOFAULT(%r9);		\
 	xorl	%eax, %eax;			\
+	SMAP_ENABLE_INSTR(EN1)			\
 	ret;					\
 _flt_/**/NAME:					\
+	SMAP_ENABLE_INSTR(EN2)			\
 	movq	$0, T_LOFAULT(%r9);		\
 1:						\
 	movq	T_COPYOPS(%r9), %rax;		\
@@ -2540,10 +2676,10 @@
 	ret;					\
 	SET_SIZE(NAME)
 
-	SUWORD(suword64, movq, %rsi, CP_SUWORD64)
-	SUWORD(suword32, movl, %esi, CP_SUWORD32)
-	SUWORD(suword16, movw, %si, CP_SUWORD16)
-	SUWORD(suword8, movb, %sil, CP_SUWORD8)
+	SUWORD(suword64, movq, %rsi, CP_SUWORD64,12,18,19)
+	SUWORD(suword32, movl, %esi, CP_SUWORD32,13,20,21)
+	SUWORD(suword16, movw, %si, CP_SUWORD16,14,22,23)
+	SUWORD(suword8, movb, %sil, CP_SUWORD8,15,24,25)
 
 #elif defined(__i386)
 
@@ -2880,6 +3016,10 @@
 	jmp	do_copy
 	SET_SIZE(ucopy)
 
+	/*
+	 * Note, the frame pointer is required here becuase do_copystr expects
+	 * to be able to pop it off!
+	 */
 	ENTRY(ucopystr)
 	pushq	%rbp
 	movq	%rsp, %rbp
@@ -2889,6 +3029,8 @@
 	cmpq	%rax, %rsi
 	cmovaeq	%rax, %rsi	/* force fault at kernelbase */
 	/* do_copystr expects lofault address in %r8 */
+	/* do_copystr expects whether or not we need smap in %r10 */
+	xorl	%r10d, %r10d
 	movq	%gs:CPU_THREAD, %r8
 	movq	T_LOFAULT(%r8), %r8
 	jmp	do_copystr
@@ -2995,3 +3137,58 @@
 #endif
 
 #endif	/* __lint */
+
+/*
+ * These functions are used for SMAP, supervisor mode access protection. They
+ * are hotpatched to become real instructions when the system starts up which is
+ * done in mlsetup() as a part of enabling the other CR4 related features.
+ *
+ * Generally speaking, smap_disable() is a stac instruction and smap_enable is a
+ * clac instruction. It's safe to call these any number of times, and in fact,
+ * out of paranoia, the kernel will likely call it at several points.
+ */
+
+#if defined(__lint)
+
+void
+smap_enable(void)
+{}
+
+void
+smap_disable(void)
+{}
+
+#else
+
+#if defined (__amd64) || defined(__i386)
+	ENTRY(smap_disable)
+	nop
+	nop
+	nop
+	ret
+	SET_SIZE(smap_disable)
+
+	ENTRY(smap_enable)
+	nop
+	nop
+	nop
+	ret
+	SET_SIZE(smap_enable)
+
+#endif /* __amd64 || __i386 */
+
+#endif /* __lint */
+
+.data
+.align 	4
+.globl	_smap_enable_patch_count
+.type	_smap_enable_patch_count,@object
+.size	_smap_enable_patch_count, 4
+_smap_enable_patch_count:
+	.long	SMAP_ENABLE_COUNT
+
+.globl	_smap_disable_patch_count
+.type	_smap_disable_patch_count,@object
+.size	_smap_disable_patch_count, 4
+_smap_disable_patch_count:
+	.long SMAP_DISABLE_COUNT
usr/src/uts/intel/ia32/ml/i86_subr.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/ml/i86_subr.s	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/ml/i86_subr.s	Mon Dec 14 10:47:45 2015
@@ -71,9 +71,12 @@
 
 /*
  * on_fault()
+ *
  * Catch lofault faults. Like setjmp except it returns one
  * if code following causes uncorrectable fault. Turned off
- * by calling no_fault().
+ * by calling no_fault(). Note that while under on_fault(),
+ * SMAP is disabled. For more information see
+ * uts/intel/ia32/ml/copy.s.
  */
 
 #if defined(__lint)
@@ -96,6 +99,7 @@
 	leaq	catch_fault(%rip), %rdx
 	movq	%rdi, T_ONFAULT(%rsi)		/* jumpbuf in t_onfault */
 	movq	%rdx, T_LOFAULT(%rsi)		/* catch_fault in t_lofault */
+	call	smap_disable			/* allow user accesses */
 	jmp	setjmp				/* let setjmp do the rest */
 
 catch_fault:
@@ -104,6 +108,7 @@
 	xorl	%eax, %eax
 	movq	%rax, T_ONFAULT(%rsi)		/* turn off onfault */
 	movq	%rax, T_LOFAULT(%rsi)		/* turn off lofault */
+	call	smap_enable			/* disallow user accesses */
 	jmp	longjmp				/* let longjmp do the rest */
 	SET_SIZE(on_fault)
 
@@ -112,6 +117,7 @@
 	xorl	%eax, %eax
 	movq	%rax, T_ONFAULT(%rsi)		/* turn off onfault */
 	movq	%rax, T_LOFAULT(%rsi)		/* turn off lofault */
+	call	smap_enable			/* disallow user accesses */
 	ret
 	SET_SIZE(no_fault)
 
usr/src/uts/intel/ia32/ml/swtch.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/ml/swtch.s	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/ml/swtch.s	Mon Dec 14 10:47:45 2015
@@ -24,7 +24,7 @@
  */
 
 /*
- * Copyright (c) 2013, Joyent, Inc. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 /*
@@ -45,6 +45,7 @@
 #include <sys/privregs.h>
 #include <sys/stack.h>
 #include <sys/segments.h>
+#include <sys/psw.h>
 
 /*
  * resume(thread_id_t t);
@@ -239,6 +240,29 @@
 	leaq	resume_return(%rip), %r11
 
 	/*
+	 * Deal with SMAP here. A thread may be switched out at any point while
+	 * it is executing. The thread could be under on_fault() or it could be
+	 * pre-empted while performing a copy interruption. If this happens and
+	 * we're not in the context of an interrupt which happens to handle
+	 * saving and restoring rflags correctly, we may lose our SMAP related
+	 * state.
+	 *
+	 * To handle this, as part of being switched out, we first save whether
+	 * or not userland access is allowed ($PS_ACHK in rflags) and store that
+	 * in t_useracc on the kthread_t and unconditionally enable SMAP to
+	 * protect the system.
+	 *
+	 * Later, when the thread finishes resuming, we potentially disable smap
+	 * if PS_ACHK was present in rflags. See uts/intel/ia32/ml/copy.s for
+	 * more information on rflags and SMAP.
+	 */
+	pushfq
+	popq	%rsi
+	andq	$PS_ACHK, %rsi
+	movq	%rsi, T_USERACC(%rax)
+	call	smap_enable
+
+	/*
 	 * Save non-volatile registers, and set return address for current
 	 * thread to resume_return.
 	 *
@@ -246,6 +270,7 @@
 	 */
 	SAVE_REGS(%rax, %r11)
 
+
 	LOADCPU(%r15)				/* %r15 = CPU */
 	movq	CPU_THREAD(%r15), %r13		/* %r13 = curthread */
 
@@ -337,13 +362,12 @@
 
 .setup_cpu:
 	/*
-	 * Setup rsp0 (kernel stack) in TSS to curthread's stack.
-	 * (Note: Since we don't have saved 'regs' structure for all
-	 *	  the threads we can't easily determine if we need to
-	 *	  change rsp0. So, we simply change the rsp0 to bottom 
-	 *	  of the thread stack and it will work for all cases.)
-	 *
-	 * XX64 - Is this correct?
+	 * Setup rsp0 (kernel stack) in TSS to curthread's saved regs
+	 * structure.  If this thread doesn't have a regs structure above
+	 * the stack -- that is, if lwp_stk_init() was never called for the
+	 * thread -- this will set rsp0 to the wrong value, but it's harmless
+	 * as it's a kernel thread, and it won't actually attempt to implicitly
+	 * use the rsp0 via a privilege change.
 	 */
 	movq	CPU_TSS(%r13), %r14
 	movq	T_STACK(%r12), %rax
@@ -387,6 +411,19 @@
 	STORE_INTR_START(%r12)
 
 	/*
+	 * If we came into swtch with the ability to access userland pages, go
+	 * ahead and restore that fact by disabling SMAP.  Clear the indicator
+	 * flag out of paranoia.
+	 */
+	movq	T_USERACC(%r12), %rax	/* should we disable smap? */
+	cmpq	$0, %rax		/* skip call when zero */
+	jz	.nosmap
+	xorq	%rax, %rax
+	movq	%rax, T_USERACC(%r12)
+	call	smap_disable
+.nosmap:
+
+	/*
 	 * Restore non-volatile registers, then have spl0 return to the
 	 * resuming thread's PC after first setting the priority as low as
 	 * possible and blocking all interrupt threads that may be active.
@@ -504,11 +541,12 @@
 	jne	.L5_2
 .L5_1:
 	/*
-	 * Setup esp0 (kernel stack) in TSS to curthread's stack.
-	 * (Note: Since we don't have saved 'regs' structure for all
-	 *	  the threads we can't easily determine if we need to
-	 *	  change esp0. So, we simply change the esp0 to bottom 
-	 *	  of the thread stack and it will work for all cases.)
+	 * Setup esp0 (kernel stack) in TSS to curthread's stack.  If this
+	 * thread doesn't have a regs structure above the stack -- that is, if
+	 * lwp_stk_init() was never called for the thread -- this will set
+	 * esp0 to the wrong value, but it's harmless as it's a kernel thread,
+	 * and it won't actually attempt to implicitly use the esp0 via a
+	 * privilege change.
 	 */
 	movl	CPU_TSS(%esi), %ecx
 	addl	$REGSIZE+MINFRAME, %eax	/* to the bottom of thread stack */
@@ -889,5 +927,83 @@
 	SET_SIZE(thread_start)
 
 #endif	/* __i386 */
+
+#endif  /* __lint */
+
+#if defined(__lint)
+
+void
+thread_splitstack_run(caddr_t stack, void (*func)(void *), void *arg)
+{}
+
+void
+thread_splitstack_cleanup(void)
+{}
+
+#else   /* __lint */
+
+#if defined(__amd64)
+
+	ENTRY(thread_splitstack_run)
+	pushq	%rbp			/* push base pointer */
+	movq	%rsp, %rbp		/* construct frame */
+	movq	%rdi, %rsp		/* set stack pinter */
+	movq	%rdx, %rdi		/* load arg */
+	call	*%rsi			/* call specified function */
+	leave				/* pop base pointer */
+	ret
+	SET_SIZE(thread_splitstack_run)
+
+	/*
+	 * Once we're back on our own stack, we need to be sure to set the
+	 * value of rsp0 in the TSS back to our original stack:  if we gave
+	 * up the CPU at all while on our split stack, the rsp0 will point
+	 * to that stack from resume (above); if were to try to return to
+	 * userland in that state, we will die absolutely horribly (namely,
+	 * trying to iretq back to registers in a bunch of freed segkp).  We
+	 * are expecting this to be called after T_STACK has been restored,
+	 * but before we return.  It's okay if we are preempted in this code:
+	 * when the new CPU picks us up, they will automatically set rsp0
+	 * correctly, which is all we're trying to do here.
+	 */
+	ENTRY(thread_splitstack_cleanup)
+	LOADCPU(%r8)
+	movq	CPU_TSS(%r8), %r9
+	movq 	CPU_THREAD(%r8), %r10
+	movq	T_STACK(%r10), %rax
+	addq    $REGSIZE+MINFRAME, %rax
+	movq	%rax, TSS_RSP0(%r9)
+	ret
+	SET_SIZE(thread_splitstack_cleanup)
+
+#elif defined(__i386)
+
+	ENTRY(thread_splitstack_run)
+	pushl	%ebp			/* push base pointer */
+	movl	%esp, %ebp		/* construct frame */
+	movl	8(%ebp), %esp		/* set stack pointer */
+	movl	12(%ebp), %eax		/* load func */
+	movl	16(%ebp), %edx		/* load arg */
+	pushl	%edx			/* push arg */
+	call	*%eax			/* call specifed function */
+	addl	$4, %esp		/* restore stack pointer */
+	leave				/* pop base pointer */
+	ret
+	SET_SIZE(thread_splitstack_run)
+
+	/*
+	 * See comment in the amd64 code, above.
+	 */
+	ENTRY(thread_splitstack_cleanup)
+	LOADCPU(%eax)
+	movl	CPU_TSS(%eax), %ecx
+	movl 	CPU_THREAD(%eax), %edx
+	movl	T_STACK(%edx), %edx
+	addl    $REGSIZE+MINFRAME, %edx
+	movl	%edx, TSS_ESP0(%ecx)
+	ret
+	SET_SIZE(thread_splitstack_cleanup)
+
+#endif	/* __i386 */
 
 #endif  /* __lint */
usr/src/uts/intel/ia32/os/archdep.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/os/archdep.c	Mon Dec  7 23:29:56 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/os/archdep.c	Mon Dec 14 10:47:45 2015
@@ -25,7 +25,7 @@
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
 /*	  All Rights Reserved  	*/
 /*
- * Copyright (c) 2012, Joyent, Inc.  All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  * Copyright 2012 Nexenta Systems, Inc.  All rights reserved.
  */
 
@@ -575,6 +575,13 @@
 	if (src->uc_flags & UC_FPU)
 		fpregset_32ton(&src->uc_mcontext.fpregs,
 		    &dst->uc_mcontext.fpregs);
+
+	/*
+	 * Copy the brand-private data:
+	 */
+	dst->uc_brand_data[0] = (void *)(uintptr_t)src->uc_brand_data[0];
+	dst->uc_brand_data[1] = (void *)(uintptr_t)src->uc_brand_data[1];
+	dst->uc_brand_data[2] = (void *)(uintptr_t)src->uc_brand_data[2];
 }
 
 #endif	/* _SYSCALL32_IMPL */
@@ -629,9 +636,11 @@
 #define	IS_NOT_CS	0
 
 /*ARGSUSED*/
-static greg_t
+greg_t
 fix_segreg(greg_t sr, int iscs, model_t datamodel)
 {
+	kthread_t *t = curthread;
+
 	switch (sr &= 0xffff) {
 
 	case 0:
@@ -667,6 +676,19 @@
 		break;
 	}
 
+	/*
+	 * Allow this process's brand to do any necessary segment register
+	 * manipulation.
+	 */
+	if (PROC_IS_BRANDED(t->t_procp) && BRMOP(t->t_procp)->b_fixsegreg) {
+		greg_t bsr = BRMOP(t->t_procp)->b_fixsegreg(sr, datamodel);
+
+		if (bsr == 0 && iscs == IS_CS)
+			return (0 | SEL_UPL);
+		else
+			return (bsr);
+	}
+
 	/*
 	 * Force it into the LDT in ring 3 for 32-bit processes, which by
 	 * default do not have an LDT, so that any attempt to use an invalid
usr/src/uts/intel/ia32/os/desctbls.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/os/desctbls.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/os/desctbls.c	Wed Jun 17 17:43:44 2015
@@ -161,7 +161,7 @@
  * The brand infrastructure interposes on two handlers, and we use one as a
  * NULL signpost.
  */
-static struct interposing_handler brand_tbl[2];
+static struct interposing_handler brand_tbl[3];
 
 /*
  * software prototypes for default local descriptor table
@@ -976,6 +976,12 @@
 	set_gatesegd(&idt[T_MCE], &mcetrap, KCS_SEL, SDT_SYSIGT, TRP_KPL, 0);
 	set_gatesegd(&idt[T_SIMDFPE], &xmtrap, KCS_SEL, SDT_SYSIGT, TRP_KPL, 0);
 
+ 	/*
+	 * install "int80" handler at, well, 0x80.
+	 */
+	set_gatesegd(&idt0[T_INT80], &sys_int80, KCS_SEL, SDT_SYSIGT, TRP_UPL,
+	    0);
+
 	/*
 	 * install fast trap handler at 210.
 	 */
@@ -1001,21 +1007,27 @@
 	    SDT_SYSIGT, TRP_UPL, 0);
 
 	/*
-	 * Prepare interposing descriptor for the syscall handler
-	 * and cache copy of the default descriptor.
+-	 * Prepare interposing descriptors for the branded "int80"
+-	 * and syscall handlers and cache copies of the default
+-	 * descriptors.
 	 */
-	brand_tbl[0].ih_inum = T_SYSCALLINT;
-	brand_tbl[0].ih_default_desc = idt0[T_SYSCALLINT];
+	brand_tbl[0].ih_inum = T_INT80;
+	brand_tbl[0].ih_default_desc = idt0[T_INT80];
+	set_gatesegd(&(brand_tbl[0].ih_interp_desc), &brand_sys_int80, KCS_SEL,
+	    SDT_SYSIGT, TRP_UPL, 0);
 
+	brand_tbl[1].ih_inum = T_SYSCALLINT;
+	brand_tbl[1].ih_default_desc = idt0[T_SYSCALLINT];
+
 #if defined(__amd64)
-	set_gatesegd(&(brand_tbl[0].ih_interp_desc), &brand_sys_syscall_int,
+	set_gatesegd(&(brand_tbl[1].ih_interp_desc), &brand_sys_syscall_int,
 	    KCS_SEL, SDT_SYSIGT, TRP_UPL, 0);
 #elif defined(__i386)
-	set_gatesegd(&(brand_tbl[0].ih_interp_desc), &brand_sys_call,
+	set_gatesegd(&(brand_tbl[1].ih_interp_desc), &brand_sys_call,
 	    KCS_SEL, SDT_SYSIGT, TRP_UPL, 0);
 #endif	/* __i386 */
 
-	brand_tbl[1].ih_inum = 0;
+	brand_tbl[2].ih_inum = 0;
 }
 
 #if defined(__xpv)
usr/src/uts/intel/ia32/os/sendsig.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/os/sendsig.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/os/sendsig.c	Mon Dec 14 10:47:45 2015
@@ -20,6 +20,9 @@
  */
 
 /*
+ * Copyright 2015 Joyent, Inc.
+ */
+/*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -87,6 +90,8 @@
 #include <sys/kdi.h>
 #include <sys/contract_impl.h>
 #include <sys/x86_archext.h>
+#include <sys/brand.h>
+#include <sys/sdt.h>
 
 /*
  * Construct the execution environment for the user's signal
@@ -186,7 +191,18 @@
 	newstack = sigismember(&PTOU(curproc)->u_sigonstack, sig) &&
 	    !(lwp->lwp_sigaltstack.ss_flags & (SS_ONSTACK|SS_DISABLE));
 
-	if (newstack) {
+	/*
+	 * If this is a branded process, the brand may provide an alternate
+	 * stack pointer for signal delivery:
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sendsig_stack != NULL) {
+		/*
+		 * Use the stack pointer value provided by the brand,
+		 * accounting for the 128-byte reserved region.
+		 */
+		newstack = 0;
+		fp = BROP(p)->b_sendsig_stack(sig) - STACK_RESERVE;
+	} else if (newstack) {
 		fp = (caddr_t)(SA((uintptr_t)lwp->lwp_sigaltstack.ss_sp) +
 		    SA(lwp->lwp_sigaltstack.ss_size) - STACK_ALIGN);
 	} else {
@@ -288,11 +304,16 @@
 	 */
 	uc = (ucontext_t *)(sp + sizeof (struct sigframe));
 	tuc = kmem_alloc(sizeof (*tuc), KM_SLEEP);
+	no_fault();
 	savecontext(tuc, &lwp->lwp_sigoldmask);
+	if (on_fault(&ljb))
+		goto badstack;
 	copyout_noerr(tuc, uc, sizeof (*tuc));
 	kmem_free(tuc, sizeof (*tuc));
 	tuc = NULL;
 
+	DTRACE_PROBE3(oldcontext__set, klwp_t *, lwp,
+	    uintptr_t, lwp->lwp_oldcontext, uintptr_t, (uintptr_t)uc);
 	lwp->lwp_oldcontext = (uintptr_t)uc;
 
 	if (newstack) {
@@ -342,6 +363,14 @@
 	}
 
 	/*
+	 * Allow the brand to perform additional book-keeping once the signal
+	 * handling frame has been fully assembled:
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sendsig != NULL) {
+		BROP(p)->b_sendsig(sig);
+	}
+
+	/*
 	 * Don't set lwp_eosys here.  sendsig() is called via psig() after
 	 * lwp_eosys is handled, so setting it here would affect the next
 	 * system call.
@@ -417,7 +446,17 @@
 	newstack = sigismember(&PTOU(curproc)->u_sigonstack, sig) &&
 	    !(lwp->lwp_sigaltstack.ss_flags & (SS_ONSTACK|SS_DISABLE));
 
-	if (newstack) {
+	/*
+	 * If this is a branded process, the brand may provide an alternate
+	 * stack pointer for signal delivery:
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sendsig_stack != NULL) {
+		/*
+		 * Use the stack pointer value provided by the brand:
+		 */
+		newstack = 0;
+		fp = BROP(p)->b_sendsig_stack(sig);
+	} else if (newstack) {
 		fp = (caddr_t)(SA32((uintptr_t)lwp->lwp_sigaltstack.ss_sp) +
 		    SA32(lwp->lwp_sigaltstack.ss_size) - STACK_ALIGN32);
 	} else if ((rp->r_ss & 0xffff) != UDS_SEL) {
@@ -432,8 +471,9 @@
 			    USEGD_GETBASE(&ldt[SELTOIDX(rp->r_ss)]);
 		else
 			fp = (caddr_t)rp->r_sp;
-	} else
+	} else {
 		fp = (caddr_t)rp->r_sp;
+	}
 
 	/*
 	 * Force proper stack pointer alignment, even in the face of a
@@ -506,11 +546,16 @@
 	fp -= SA32(sizeof (*tuc));
 	uc = (ucontext32_t *)fp;
 	tuc = kmem_alloc(sizeof (*tuc), KM_SLEEP);
+	no_fault();
 	savecontext32(tuc, &lwp->lwp_sigoldmask);
+	if (on_fault(&ljb))
+		goto badstack;
 	copyout_noerr(tuc, uc, sizeof (*tuc));
 	kmem_free(tuc, sizeof (*tuc));
 	tuc = NULL;
 
+	DTRACE_PROBE3(oldcontext__set, klwp_t *, lwp,
+	    uintptr_t, lwp->lwp_oldcontext, uintptr_t, (uintptr_t)uc);
 	lwp->lwp_oldcontext = (uintptr_t)uc;
 
 	if (newstack) {
@@ -560,6 +605,14 @@
 	}
 
 	/*
+	 * Allow the brand to perform additional book-keeping once the signal
+	 * handling frame has been fully assembled:
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sendsig != NULL) {
+		BROP(p)->b_sendsig(sig);
+	}
+
+	/*
 	 * Don't set lwp_eosys here.  sendsig() is called via psig() after
 	 * lwp_eosys is handled, so setting it here would affect the next
 	 * system call.
@@ -637,7 +690,17 @@
 	newstack = sigismember(&PTOU(curproc)->u_sigonstack, sig) &&
 	    !(lwp->lwp_sigaltstack.ss_flags & (SS_ONSTACK|SS_DISABLE));
 
-	if (newstack) {
+	/*
+	 * If this is a branded process, the brand may provide an alternate
+	 * stack pointer for signal delivery:
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sendsig_stack != NULL) {
+		/*
+		 * Use the stack pointer value provided by the brand:
+		 */
+		newstack = 0;
+		fp = BROP(p)->b_sendsig_stack(sig);
+	} else if (newstack) {
 		fp = (caddr_t)(SA((uintptr_t)lwp->lwp_sigaltstack.ss_sp) +
 		    SA(lwp->lwp_sigaltstack.ss_size) - STACK_ALIGN);
 	} else if ((rp->r_ss & 0xffff) != UDS_SEL) {
@@ -652,8 +715,9 @@
 			    USEGD_GETBASE(&ldt[SELTOIDX(rp->r_ss)]);
 		else
 			fp = (caddr_t)rp->r_sp;
-	} else
+	} else {
 		fp = (caddr_t)rp->r_sp;
+	}
 
 	/*
 	 * Force proper stack pointer alignment, even in the face of a
@@ -731,6 +795,8 @@
 	kmem_free(tuc, sizeof (*tuc));
 	tuc = NULL;
 
+	DTRACE_PROBE3(oldcontext__set, klwp_t *, lwp,
+	    uintptr_t, lwp->lwp_oldcontext, uintptr_t, (uintptr_t)uc);
 	lwp->lwp_oldcontext = (uintptr_t)uc;
 
 	if (newstack) {
@@ -767,6 +833,14 @@
 		rp->r_ss = UDS_SEL;
 	}
 
+	/*
+	 * Allow the brand to perform additional book-keeping once the signal
+	 * handling frame has been fully assembled:
+	 */
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_sendsig != NULL) {
+		BROP(p)->b_sendsig(sig);
+	}
+
 	/*
 	 * Don't set lwp_eosys here.  sendsig() is called via psig() after
 	 * lwp_eosys is handled, so setting it here would affect the next
usr/src/uts/intel/ia32/sys/psw.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/sys/psw.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/sys/psw.h	Mon Dec 14 10:47:45 2015
@@ -30,8 +30,6 @@
 #ifndef _IA32_SYS_PSW_H
 #define	_IA32_SYS_PSW_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #ifdef	__cplusplus
 extern "C" {
 #endif
@@ -98,6 +96,10 @@
 
 /*
  * kernel flags settings
+ *
+ * Note that the kernel's SMAP protection relies on PS_ACHK not being present in
+ * the following two definitions. See uts/intel/ia32/ml/copy.s for more
+ * information on SMAP.
  */
 #define	F_OFF		0x2		/* interrupts off */
 #define	F_ON		0x202		/* interrupts on */
usr/src/uts/intel/ia32/syscall/getcontext.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/ia32/syscall/getcontext.c	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/ia32/syscall/getcontext.c	Wed Jun 17 17:43:44 2015
@@ -20,6 +20,9 @@
  */
 
 /*
+ * Copyright 2015 Joyent, Inc.
+ */
+/*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -46,6 +49,7 @@
 #include <sys/schedctl.h>
 #include <sys/debug.h>
 #include <sys/sysmacros.h>
+#include <sys/sdt.h>
 
 /*
  * Save user context.
@@ -125,7 +129,23 @@
 	else
 		ucp->uc_flags &= ~UC_FPU;
 
-	sigktou(mask, &ucp->uc_sigmask);
+	if (mask != NULL) {
+		/*
+		 * Save signal mask.
+		 */
+		sigktou(mask, &ucp->uc_sigmask);
+	} else {
+		ucp->uc_flags &= ~UC_SIGMASK;
+		bzero(&ucp->uc_sigmask, sizeof (ucp->uc_sigmask));
+	}
+
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_savecontext != NULL) {
+		/*
+		 * Allow the brand the chance to modify the context we
+		 * saved:
+		 */
+		BROP(p)->b_savecontext(ucp);
+	}
 }
 
 /*
@@ -136,7 +156,19 @@
 {
 	kthread_t *t = curthread;
 	klwp_t *lwp = ttolwp(t);
+	proc_t *p = lwptoproc(lwp);
 
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_restorecontext != NULL) {
+		/*
+		 * Allow the brand the chance to modify the context before
+		 * we restore it:
+		 */
+		BROP(p)->b_restorecontext(ucp);
+	}
+
+	DTRACE_PROBE3(oldcontext__set, klwp_t *, lwp,
+	    uintptr_t, lwp->lwp_oldcontext,
+	    uintptr_t, (uintptr_t)ucp->uc_link);
 	lwp->lwp_oldcontext = (uintptr_t)ucp->uc_link;
 
 	if (ucp->uc_flags & UC_STACK) {
@@ -184,6 +216,7 @@
 	ucontext_t *ucp;
 	klwp_t *lwp = ttolwp(curthread);
 	stack_t dummy_stk;
+	proc_t *p = lwptoproc(lwp);
 
 	/*
 	 * In future releases, when the ucontext structure grows,
@@ -228,6 +261,15 @@
 			return (set_errno(EFAULT));
 		}
 
+		/*
+		 * If this is a branded process, copy in the brand-private
+		 * data:
+		 */
+		if (PROC_IS_BRANDED(p) && copyin(&ucp->uc_brand_data,
+		    &uc.uc_brand_data, sizeof (uc.uc_brand_data)) != 0) {
+			return (set_errno(EFAULT));
+		}
+
 		restorecontext(&uc);
 
 		if ((uc.uc_flags & UC_STACK) && (lwp->lwp_ustack != 0))
@@ -311,7 +353,23 @@
 	else
 		ucp->uc_flags &= ~UC_FPU;
 
-	sigktou(mask, &ucp->uc_sigmask);
+	if (mask != NULL) {
+		/*
+		 * Save signal mask.
+		 */
+		sigktou(mask, &ucp->uc_sigmask);
+	} else {
+		ucp->uc_flags &= ~UC_SIGMASK;
+		bzero(&ucp->uc_sigmask, sizeof (ucp->uc_sigmask));
+	}
+
+	if (PROC_IS_BRANDED(p) && BROP(p)->b_savecontext32 != NULL) {
+		/*
+		 * Allow the brand the chance to modify the context we
+		 * saved:
+		 */
+		BROP(p)->b_savecontext32(ucp);
+	}
 }
 
 int
@@ -323,6 +381,7 @@
 	klwp_t *lwp = ttolwp(curthread);
 	caddr32_t ustack32;
 	stack32_t dummy_stk32;
+	proc_t *p = lwptoproc(lwp);
 
 	switch (flag) {
 	default:
@@ -353,6 +412,15 @@
 		    sizeof (uc.uc_mcontext.fpregs))) {
 			return (set_errno(EFAULT));
 		}
+
+		/*
+		 * If this is a branded process, copy in the brand-private
+		 * data:
+		 */
+		if (PROC_IS_BRANDED(p) && copyin(&ucp->uc_brand_data,
+		    &uc.uc_brand_data, sizeof (uc.uc_brand_data)) != 0) {
+			return (set_errno(EFAULT));
+		}
 
 		ucontext_32ton(&uc, &ucnat);
 		restorecontext(&ucnat);
usr/src/uts/intel/ldlinux/Makefile
usr/src/uts/intel/lx_afs/Makefile
usr/src/uts/intel/lx_afs/Makefile.rules
usr/src/uts/intel/lx_audio/Makefile
usr/src/uts/intel/lx_brand/Makefile
usr/src/uts/intel/lx_brand/Makefile.rules
usr/src/uts/intel/lx_cgroup/Makefile
usr/src/uts/intel/lx_cgroup/Makefile.rules
usr/src/uts/intel/lx_devfs/Makefile
usr/src/uts/intel/lx_devfs/Makefile.rules
usr/src/uts/intel/lx_netlink/Makefile
usr/src/uts/intel/lx_proc/Makefile
usr/src/uts/intel/lx_proc/Makefile.rules
usr/src/uts/intel/lx_ptm/Makefile
usr/src/uts/intel/lx_sysfs/Makefile
usr/src/uts/intel/lx_sysfs/Makefile.rules
usr/src/uts/intel/lx_systrace/Makefile
usr/src/uts/intel/lxautofs/Makefile
usr/src/uts/intel/lxautofs/Makefile.rules
usr/src/uts/intel/sys/archsystm.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/sys/archsystm.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/sys/archsystm.h	Mon Dec 14 10:47:45 2015
@@ -21,6 +21,7 @@
 
 /*
  * Copyright (c) 1993, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2015 Joyent, Inc.
  */
 
 #ifndef _SYS_ARCHSYSTM_H
@@ -181,6 +182,17 @@
 
 extern void *plat_traceback(void *);
 
+/*
+ * The following two macros are the four byte instruction sequence of stac, ret
+ * and clac, ret. These are used in startup_smap() as a part of properly setting
+ * up the valid instructions. For more information on SMAP, see
+ * uts/intel/ia32/ml/copy.s.
+ */
+#define	SMAP_CLAC_INSTR	0xc3ca010f
+#define	SMAP_STAC_INSTR	0xc3cb010f
+extern void smap_disable(void);
+extern void smap_enable(void);
+
 #if defined(__xpv)
 extern void xen_init_callbacks(void);
 extern void xen_set_callback(void (*)(void), uint_t, uint_t);
usr/src/uts/intel/sys/controlregs.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/sys/controlregs.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/sys/controlregs.h	Mon Dec 14 10:47:45 2015
@@ -110,9 +110,11 @@
 #define	CR4_SMXE	0x4000
 #define	CR4_OSXSAVE	0x40000		/* OS xsave/xrestore support	*/
 #define	CR4_SMEP	0x100000	/* NX for user pages in kernel */
+#define	CR4_SMAP	0x200000	/* kernel can't access user pages */
 
-#define	FMT_CR4							\
-	"\20\25smep\23osxsav\17smxe\16vmxe\13xmme\12fxsr\11pce\10pge"	\
+#define	FMT_CR4						\
+	"\20\26smap\25smep\23osxsav"			\
+	"\17smxe\16vmxe\13xmme\12fxsr\11pce\10pge"	\
 	"\7mce\6pae\5pse\4de\3tsd\2pvi\1vme"
 
 /*
usr/src/uts/intel/sys/machbrand.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/sys/machbrand.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/sys/machbrand.h	Wed Jun 17 17:43:44 2015
@@ -20,6 +20,7 @@
  */
 /*
  * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Joyent, Inc. All rights reserved.
  */
 
 #ifndef _SYS_MACHBRAND_H
@@ -35,17 +36,21 @@
 
 struct brand_mach_ops {
 	void	(*b_sysenter)(void);
+	void	(*b_int80)(void);
 	void	(*b_int91)(void);
 	void	(*b_syscall)(void);
 	void	(*b_syscall32)(void);
+	greg_t	(*b_fixsegreg)(greg_t, model_t);
+	uintptr_t (*b_fsbase)(klwp_t *, uintptr_t);
 };
 
 #endif	/* _ASM */
 
 #define	BRAND_CB_SYSENTER	0
-#define	BRAND_CB_INT91		1
-#define	BRAND_CB_SYSCALL	2
-#define	BRAND_CB_SYSCALL32	3
+#define	BRAND_CB_INT80		1
+#define	BRAND_CB_INT91		2
+#define	BRAND_CB_SYSCALL	3
+#define	BRAND_CB_SYSCALL32	4
 
 #ifdef	__cplusplus
 }
usr/src/uts/intel/sys/segments.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/sys/segments.h	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/sys/segments.h	Wed Jun 17 17:43:44 2015
@@ -683,6 +683,8 @@
 extern void achktrap(), mcetrap();
 extern void xmtrap();
 extern void fasttrap();
+extern void sys_int80();
+extern void brand_sys_int80();
 extern void dtrace_ret();
 
 #if !defined(__amd64)
usr/src/uts/intel/sys/ucontext.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/sys/ucontext.h	Mon Dec  7 23:29:56 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/sys/ucontext.h	Mon Dec 14 10:47:45 2015
@@ -20,6 +20,7 @@
  */
 
 /*
+ * Copyright 2015 Joyent, Inc.
  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.
  *
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
@@ -84,9 +85,16 @@
 	sigset_t   	uc_sigmask;
 	stack_t 	uc_stack;
 	mcontext_t 	uc_mcontext;
-	long		uc_filler[5];	/* see ABI spec for Intel386 */
+	/*
+	 * The Intel386 ABI specification includes a 5-element array of longs
+	 * called "uc_filler", padding the size of the struct to 512 bytes.  To
+	 * allow zone brands to communicate extra data right the way through
+	 * the signal handling process, from sigacthandler to setcontext, we
+	 * steal the first three of these longs as a brand-private member.
+	 */
+	void		*uc_brand_data[3];
+	long		uc_filler[2];
 };
-
 #if defined(_SYSCALL32)
 
 /* Kernel view of user ILP32 ucontext structure */
@@ -97,7 +105,8 @@
 	sigset_t	uc_sigmask;
 	stack32_t	uc_stack;
 	mcontext32_t	uc_mcontext;
-	int32_t		uc_filler[5];
+	caddr32_t	uc_brand_data[3];
+	int32_t		uc_filler[2];
 } ucontext32_t;
 
 #if defined(_KERNEL)
usr/src/uts/intel/sys/x86_archext.h
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/intel/sys/x86_archext.h	Tue Jan  5 17:20:22 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/intel/sys/x86_archext.h	Mon Dec 14 10:47:45 2015
@@ -28,7 +28,7 @@
  * All rights reserved.
  */
 /*
- * Copyright (c) 2015, Joyent, Inc.
+ * Copyright 2015 Joyent, Inc.
  * Copyright 2012 Jens Elkner <jel+illumos@cs.uni-magdeburg.de>
  * Copyright 2012 Hans Rosenfeld <rosenfeld@grumpf.hope-2000.org>
  * Copyright 2014 Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
@@ -203,7 +203,10 @@
 #define	CPUID_INTC_EBX_7_0_BMI1		0x00000008	/* BMI1 instrs */
 #define	CPUID_INTC_EBX_7_0_AVX2		0x00000020	/* AVX2 supported */
 #define	CPUID_INTC_EBX_7_0_SMEP		0x00000080	/* SMEP in CR4 */
-#define	CPUID_INTC_EBX_7_0_BMI2		0x00000100	/* BMI2 Instrs */
+#define	CPUID_INTC_EBX_7_0_BMI2		0x00000100	/* BMI2 instrs */
+#define	CPUID_INTC_EBX_7_0_RDSEED	0x00040000	/* RDSEED instr */
+#define	CPUID_INTC_EBX_7_0_ADX		0x00080000	/* ADX instrs */
+#define	CPUID_INTC_EBX_7_0_SMAP		0x00100000	/* SMAP in CR 4 */
 
 #define	P5_MCHADDR	0x0
 #define	P5_CESR		0x11
@@ -379,6 +382,9 @@
 #define	X86FSET_BMI2		43
 #define	X86FSET_FMA		44
 #define	X86FSET_SMEP		45
+#define	X86FSET_SMAP		46
+#define	X86FSET_ADX		47
+#define	X86FSET_RDSEED		48
 
 /*
  * flags to patch tsc_read routine.
@@ -639,7 +645,7 @@
 
 #if defined(_KERNEL) || defined(_KMEMUSER)
 
-#define	NUM_X86_FEATURES	46
+#define	NUM_X86_FEATURES	49
 extern uchar_t x86_featureset[];
 
 extern void free_x86_featureset(void *featureset);
usr/src/uts/intel/zfd/Makefile
usr/src/uts/sparc/Makefile.sparc
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/sparc/Makefile.sparc	Tue Jan  5 17:20:22 2016
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/sparc/Makefile.sparc	Mon Dec 14 10:47:45 2015
@@ -218,7 +218,7 @@
 DRV_KMODS	+= pseudo ptc ptm pts ptsl ramdisk random rsm rts sad
 DRV_KMODS	+= simnet softmac sppp sppptun sy sysevent sysmsg 
 DRV_KMODS	+= spdsock
-DRV_KMODS	+= tcp tcp6 tl tnf ttymux udp udp6 wc winlock zcons
+DRV_KMODS	+= tcp tcp6 tl tnf ttymux udp udp6 wc winlock zcons zfd
 DRV_KMODS	+= ippctl
 DRV_KMODS	+= dld
 DRV_KMODS	+= ipd
@@ -238,8 +238,10 @@
 DRV_KMODS	+= bridge trill
 DRV_KMODS	+= bpf
 DRV_KMODS	+= dca
+DRV_KMODS	+= inotify
 DRV_KMODS	+= eventfd
 DRV_KMODS	+= signalfd
+DRV_KMODS	+= timerfd
 
 #
 #       Hardware Drivers in common space
@@ -493,7 +495,6 @@
 SOCKET_KMODS	+= socksdp
 SOCKET_KMODS	+= sockrds
 SOCKET_KMODS	+= ksslf
-SOCKET_KMODS	+= httpfilt
 SOCKET_KMODS	+= datafilt
 
 #
usr/src/uts/sparc/syscall/getcontext.c
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/sparc/syscall/getcontext.c	Mon Dec  7 23:29:56 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/sparc/syscall/getcontext.c	Mon Dec 14 10:47:45 2015
@@ -20,6 +20,9 @@
  */
 
 /*
+ * Copyright 2015 Joyent, Inc.
+ */
+/*
  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
@@ -110,10 +113,15 @@
 		ucp->uc_flags &= ~UC_FPU;
 	ucp->uc_mcontext.gwins = (gwindows_t *)NULL;
 
-	/*
-	 * Save signal mask.
-	 */
-	sigktou(mask, &ucp->uc_sigmask);
+	if (mask != NULL) {
+		/*
+		 * Save signal mask.
+		 */
+		sigktou(mask, &ucp->uc_sigmask);
+	} else {
+		ucp->uc_flags &= ~UC_SIGMASK;
+		bzero(&ucp->uc_sigmask, sizeof (ucp->uc_sigmask));
+	}
 }
 
 
@@ -412,11 +420,16 @@
 		ucp->uc_flags &= ~UC_FPU;
 	ucp->uc_mcontext.gwins = (caddr32_t)NULL;
 
-	/*
-	 * Save signal mask (the 32- and 64-bit sigset_t structures are
-	 * identical).
-	 */
-	sigktou(mask, (sigset_t *)&ucp->uc_sigmask);
+	if (mask != NULL) {
+		/*
+		 * Save signal mask (the 32- and 64-bit sigset_t structures are
+		 * identical).
+		 */
+		sigktou(mask, (sigset_t *)&ucp->uc_sigmask);
+	} else {
+		ucp->uc_flags &= ~UC_SIGMASK;
+		bzero(&ucp->uc_sigmask, sizeof (ucp->uc_sigmask));
+	}
 }
 
 int
usr/src/uts/sparc/zfd/Makefile
usr/src/uts/sun4/brand/common/brand_solaris.s
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/sun4/brand/common/brand_solaris.s	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/sun4/brand/common/brand_solaris.s	Wed Jun 17 17:43:44 2015
@@ -236,7 +236,7 @@
 #endif /* sun4v */
 	ldn	[%g2 + CPU_THREAD], %g3;	/* get thread ptr */
 	ldn	[%g3 + T_PROCP], %g4;		/* get proc ptr */
-	ldn	[%g4 + P_BRAND_DATA], %g5;	/* get brand data ptr */
+	ldn	[%g4 + __P_BRAND_DATA], %g5;	/* get brand data ptr */
 	ldn	[%g5 + SPD_HANDLER], %g5;	/* get userland brnd hdlr ptr */
 	brz	%g5, _exit;			/* has it been set? */
 	nop;
usr/src/uts/sun4/ml/offsets.in
--- /export/home/danmcd/ws/illumos-omnios/usr/src/uts/sun4/ml/offsets.in	Tue Jul 21 14:14:30 2015
+++ /export/home/danmcd/ws/illumos-joyent/usr/src/uts/sun4/ml/offsets.in	Wed Jun 17 17:43:44 2015
@@ -109,7 +109,7 @@
 	p_utraps
 	p_agenttp
 	p_brand
-	p_brand_data
+	__p_brand_data
 
 \#define	P_UTRAP4	(UT_ILLTRAP_INSTRUCTION * CPTRSIZE)
 \#define	P_UTRAP7	(UT_FP_DISABLED * CPTRSIZE)
